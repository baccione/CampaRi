{
    "collab_server" : "",
    "contents" : "  #' @title Load trajectory\n#' @description\n#'      This is a wonderful description(X)\n#'\n#' @param fl file location\n#' @param n_fold Number of links contractions (folds)\n#' Default: \\code{0}\n#'\n#' @examples\n#' tree <- adjl_from_pi(fil = \"data/PROGIDX_000000000001.dat\")\n#'\n#' @return tree: degree list, connectivity matrix and weights\n#'\n#' @export load_trj_dcd\n#' @import bio3d\nload_trj_dcd<-function(t_file){\n return(read.dcd(trjfile = t_file)) \n}\n\n#' @title Build the network from the trajectory file\n#' @description\n#'      This is a wonderful description(X)\n#'\n#' @param fl file location\n#' @param n_fold Number of links contractions (folds)\n#' Default: \\code{0}\n#'\n#' @examples\n#' tree <- adjl_from_trj(fil = \"data/PROGIDX_000000000001.dat\")\n#'\n#' @return tree: degree list, connectivity matrix and weights\n#'\n#' @export adjl_from_trj\n#' @import parallel bio3d\n\nadjl_from_trj<-function(trj, clu_radius=NULL, clu_hardcut=NULL, cores=NULL, mode=NULL, min_span_tree=TRUE){ # to add functional of distance\n  if(!is.matrix(trj)){\n    if(!is.data.frame(trj)) stop('trj input must be a matrix or a data.frame')\n    trj <- as.matrix(trj)\n  }\n  #memory handling\n  data_management <- getOption(\"campackage.data_management\")\n  if(data_management == \"R\") cat(\"Normal memory handling selected. Without hdf5 backend file management it will be difficult for R to handle big data-sets.\\n\")\n  else if(data_management == \"h5pfc\") cat(\"Selected data support: hdf5 with mpi support\\n\")\n  else if(data_management == \"h5fc\") cat(\"Selected data support: hdf5 without mpi support\\n\")\n  else stop(\"Invalid data management keyword inserted. Check the available methods on the guide.\\n\")\n  \n  cat(\"To set new data_management method: options(list(campackage.data_management = 'R'))\\n\")\n\n  if(data_management != \"R\"){\n    warning(paste0('The dumping filename will be ',getOption(\"campackage.data_filename\"),'. If already existent it will be overwritten'))\n    cat(\"Checking for hdf5 support...\")\n    command_loc <- system(paste0(\"which \",data_management))\n    if(command_loc==\"\") stop(\"No support for hdf5. Please check installation and correct linkage of the command to your enviroment.\")\n  }\n  \n  #Input setting\n  r1 <- nrow(trj)\n  c1 <- ncol(trj)\n  \n  #normal -LONG- mode (parallel)\n  if(is.null(mode)){\n    n_cores <- detectCores() - 1\n    if(!is.null(cores)&&(cores%%1==0)) n_cores=cores\n    else warning(\"No or wrong entry for number of cores: using all of them -1\")\n    \n    dim<-attributes(trj)$dim\n    if(dim>1000) warning('the computation could be incredibly long. We advise to use mode = \"fortran\" option')\n    \n    # Initiate cluster\n    cl <- makeCluster(n_cores)\n    # clusterExport(cl, \"trj\")\n    # cl <- makeCluster(mc <- getOption(\"cl.cores\", 4))\n    # clusterExport(cl=cl, varlist=c(\"text.var\", \"ntv\", \"gc.rate\", \"pos\"))\n    # clusterEvalQ(cl, library(rms))\n  \n    adjl<-c()\n    for(i in 1:dim[1]){\n      # if(n_cores>1) clusterExport(cl, \"i\")\n      adjl<-c(adjl,parLapply(cl = cl,X = trj[(i+1):dim[1],],fun = function(x){\n        bio3d::rmsd(trj[i,],x)\n      }))\n    }\n  \n    stopCluster(cl)\n    rm(trj)\n    \n    \n  }else if(is.character(mode)&&(mode==\"fortran\")){\n    #Fortran mode\n    #default vars\n    distance_method <- 5\n    if(is.null(clu_radius)){\n      clu_radius <- 50\n      warning(paste(\"clu_radius variable (a priori fixed clustering radius) has not been selected. \n              A standard value of\",clu_radius,\"will be used.\"))\n    }\n    if(is.null(clu_hardcut)){\n      clu_hardcut <- 150\n      warning(paste(\"clu_hardcut variable (a priori fixed distance threshold between different cluster members) has not been selected. \n              A standard value of\",clu_hardcut,\"will be used.\"))\n    }\n    if(!is.numeric(clu_radius)||!is.numeric(clu_hardcut)) stop(\"clu_radius and clu_hardcut must be numeric\")\n    \n    if(data_management == \"R\"){\n      #input-output initialization\n      output_fin <- list()\n      max_d <- 0\n      adj_deg <- as.integer(rep(0,r1))\n      adj_ix <- matrix(as.integer(rep(0,r1*r1)),r1,r1)\n      adj_dis <- matrix(as.single(rep(0.0,r1*r1)),r1,r1)\n      trj <- matrix(as.single(trj),ncol = c1,nrow = r1)\n      #double Cstyle deginitions\n      attr(trj,\"Csingle\") <- TRUE\n      attr(adj_dis,\"Csingle\") <- TRUE\n      #main fortran talker\n      output<-.Fortran(\"generate_neighbour_list\", PACKAGE=\"campackage\",\n                      trj_data=trj,\n                      n_xyz_in=as.integer(c1),\n                      n_snaps_in=as.integer(r1),\n                      clu_radius_in=as.single(clu_radius),\n                      clu_hardcut_in=as.single(clu_hardcut), \n                      adjl_deg=adj_deg, \n                      adjl_ix=adj_ix, \n                      adjl_dis=adj_dis, \n                      max_degr=as.integer(max_d),\n                      dis_method_in=as.integer(distance_method),\n                      mst_log_in=as.logical(min_span_tree),\n                      data_meth_in=as.integer(1),\n                      verbose_in=as.logical(TRUE))\n      #output adjustment\n      output_fin[[1]] <- output$adjl_deg\n      output_fin[[2]] <- output$adjl_ix[,1:output$max_degr]\n      output_fin[[3]] <- output$adjl_dis[,1:output$max_degr]\n      return(output_fin)\n    }else if(data_management==\"h5pfc\"){\n      stop(\"still to-do\")\n    }else if(data_management==\"h5fc\"){\n      stop(\"still to-do\")\n    }else{\n      stop(\"Data_management assigned to an unknown value. Please complain to the developers.\")\n    }\n  }else{\n      stop(\"Mode entry not correct.\")\n    }\n}\n\n#' @title Build the network from the already processed Progress Index file\n#' @description\n#'      This is a wonderful description(X)\n#'\n#' @param fl file location\n#' @param n_fold Number of links contractions (folds)\n#' Default: \\code{0}\n#'\n#' @examples\n#' tree <- adjl_from_pi(fil = \"data/PROGIDX_000000000001.dat\")\n#'\n#' @return tree: degree list, connectivity matrix and weights\n#'\n#' @export adjl_from_pi\n#' @useDynLib campackage\n\nadjl_from_pi<-function(fil){\n  # extract the SST or MST from the output of the analysis already made with campari.\n  # Here we will reconstruct a bit of the tree in order to be able to find again the MST/SST\n  piOut<-read.table(file = fil)\n\n  # number of snapshots\n  nsnaps <- nrow(piOut)\n  nbl<-piOut[,6] #number list\n  itl<-piOut[,3] #index teo? list\n  ditl<-piOut[,5] #distance of 6 from 3\n  #max number of connections\n  maxnb <- max(hist(breaks=seq(from=0.5,by=1,to=nsnaps+0.5),x=nbl,plot=FALSE)$counts) + 1\n  # empty vector of future number of connections for each node in column 6\n  treennb <- array(as.integer(0),c(nsnaps))\n  # adjlist matrix with obvious limit in maxnb of connections\n  treenbl <- array(as.integer(0),c(nsnaps,maxnb))\n  # distance of each connection\n  treedis <- array(as.single(0.0),c(nsnaps,maxnb))\n  # slow\n  for (i in 2:nsnaps) {\n    treennb[nbl[i]] <- treennb[nbl[i]] + 1\n    treenbl[nbl[i],treennb[nbl[i]]] <- itl[i]\n    treedis[nbl[i],treennb[nbl[i]]] <- ditl[i]\n    treennb[itl[i]] <- treennb[itl[i]] + 1\n    treenbl[itl[i],treennb[itl[i]]] <- nbl[i]\n    treedis[itl[i],treennb[itl[i]]] <- ditl[i]\n    # list of breaks (must be passed at least of size 1, but n_breaks can be zero) eh?\n  }\n  return(list(treennb,treenbl,treedis))\n}\n\n#' @title Transform from an adjmatrix to an adjlist of variables\n#' @description\n#'      This is a wonderful description(X)\n#'\n#' @param adj_mat Matrix \n#' @param n_fold Number of links contractions (folds)\n#' Default: \\code{0}\n#'\n#' @examples\n#' tree <- adjl_from_adjmat(adj_m)\n#'\n#' @return tree: degree list, connectivity matrix and weights\n#'\n#' @export adjl_from_adjmat\n#' @useDynLib campackage\n\nadjl_from_adjmat<-function(adj_m){\n  # extract the SST or MST from the output of the analysis already made with campari.\n  # Here we will reconstruct a bit of the tree in order to be able to find again the MST/SST\n  adjl_nmbrs<-c()\n  adjl<-list()\n  adjl_dis<-list()\n  for (i in 1:nrow(adj_m)){\n    tmp <- sort(adj_m[i,adj_m[i,]!=0], index.return = TRUE)\n    adjl_nmbrs[i] <- length(tmp$ix)\n    adjl[[i]] <- tmp$ix\n    adjl_dis[[i]] <- tmp$x \n  }\n  adjl <- array(unlist(adjl),dim = c(length(adjl_nmbrs),max(adjl_nmbrs)))\n  adjl_dis <- array(unlist(adjl_dis),dim = c(length(adjl_nmbrs),max(adjl_nmbrs)))\n  return(list(array(adjl_nmbrs), adjl, adjl_dis))\n}",
    "created" : 1474279485146.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4053417357",
    "id" : "7FAE192F",
    "lastKnownWriteTime" : 1474279545,
    "last_content_update" : 1474279545212,
    "path" : "~/Projects/2016/CampaR/campackage/R/loader.R",
    "project_path" : "R/loader.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}