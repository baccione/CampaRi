#' @title Sapphire plot - plotting annotation and progrex index
#' @description
#'      \code{sapphire_plot} is able to generate a sapphire plot using the progrex index file (e.g. \code{"REPIX_000000000001.dat"})
#'      generated by \code{\link{gen_annotation}}.
#'
#' @param sap_file Annotated progrex index file. This can be left unused if \code{sap_table} is used instead.
#' This input must be the file output of \code{gen_annotation}.
#' @param sap_table Annotated progrex index table. As for \code{sap_file} it can be left unused if the other input is used.
#' Also in this case the format of the table must be the file output of \code{gen_annotation}.
#' @param write A logical indicating whether to write the plot to file.
#' @param folderPlot A character string that defines the folder in which save the plots (\code{write} argument must be \code{TRUE}).
#' @param timeline A logical indicating whether add a timeline annotation (with the original order) on the bottom of the plot.
#' @param local_cut A logical that, if \code{TRUE} plots the local cut annotation function (see \code{gen_annotation}).
#' @param ann_trace This argument can be set to logical, an integer or a matrix of integers. If logical, the annotation will be a horizontal thick line
#' that follows a split in half of the original timeline. If only an integer have been inserted the time line will be split in that number of splits.
#' Instead if a matrix have been inserted it will be a plotted as it is on the top of the plot mapping the range of numbers in order to
#' produce a gray scale horizontal annotation.
#' @param return_plot if \code{TRUE} it returns the plot object (ggplot).
# @param annotate_snap_dist if \code{TRUE} the distance between snapshots will be added on the top of the plot
#' @param sub_sampling_factor if a number is inserted the annotation will be subsampled by that factor.
#' @param return_ann_trace If \code{TRUE} the annotation vector is returned. This option can be really useful for adding layers and specific text using \code{ggplot2}.
# @param ann_height Defines the height on which to put the annotation (integer between 1 and 14).
# @param ann_names_L Vector of characther strings indicating, from top on the left, the names of the annotation horizontal bars.
# @param ann_names_R Vector of characther strings indicating, from top on the right, the names of the annotation horizontal bars.
#' @param use_plotly This option, if turned on will use the plotly format to represent the plot which is usually generated using ggplot2 only
#' @param title Title of the plot (default "")
#' @param ... Other options are: 
#'      \itemize{
#'        \item "\code{only_timeline}" 
#'        \item "\code{reorder_annotation}"   
#'        \item "\code{annotate_snap_dist}" should I plot a special annotation on top with the intersnaps dist? it follows the uniform color timeline
#'        \item "\code{snap_dist_annotation_height}" how hight should it be? std: y_max/8
#'        \item "\code{rescaling_ann_col}" 
#'        \item "\code{reorder_horizline_on_timeline}" 
#'        \item "\code{reorder_points_on_timeline}" 
#'        \item "\code{horiz_lines_on_timeline}" 
#'        \item "\code{horiz_colored_areas}" 
#'        \item "\code{points_on_timeline}" 
#'        \item "\code{vertical_barriers_points}" 
#'        \item "\code{specific_palette_timeline}" 
#'        \item "\code{specific_palette_annotation}" 
#'        \item "\code{general_size_annPoints}" 
#'        \item "\code{size_points_on_timeline}" 
#'        \item "\code{plot_legend}" 
#'        \item "\code{uniform_color_timeline}" to put an uniform color on timeline and snap dist (std: T)
#'        \item "\code{which_uniform_color_timeline}" std: 'black'. if you put 'annotation' you get the first of the lines in the annotation (colorwise)
#'        \item "\code{legend_title}" Title of the legend
#'        \item "\code{annotation_type}" 'continuous' or 'discrete' - it defines the legend and the colors according to specific_palette_annotation
#'        \item "\code{timeline_proportion}" std:1/6*y_max set y_max from local_cut and standard_cut this defines a 
#'        proportion of that y_max (e.g. 0.5 meaning that the timeline will be placed in the 0 - 0.5*ymax space)
#'        \item "\code{ann_height}" std:1/8*y_max set the height of the annotation
#'        \item "\code{ann_initial_point}" std:3/4*y_max set the starting point of the annotation from the top
#'        \item "\code{localcutbasin_prop_height}" std:1/4*y_max set the heigth space of the localcut
#'        \item "\code{basin_prop_height}" std:1/4*y_max set the heigth space of the stdcut
#'        \item "\code{parabolic_subtraction}" you can avoid the randomness of the parabolic curve (on annotation) by using parabolic subtraction.
#'      }
#' @details For details, please refer to the main documentation of the original campari software \url{http://campari.sourceforge.net/documentation.html}.
#'
#' @return If \code{ann_trace_ret} is active it will return the annotation trace used for the plot.
#' @seealso
#' \code{\link{mst_from_trj}}, \code{\link{gen_progindex}}, \code{\link{gen_annotation}}.
#'
#' @examples
#' adjl <- mst_from_trj(trj = matrix(rnorm(1000), nrow = 100, ncol = 10))
#' ret <- gen_progindex(adjl = adjl)
#' gen_annotation(ret_data = ret, local_cut_width = 10)
#' \dontrun{
#' sapphire_plot("REPIX_000000000001.dat")
#' }
#' 
#' @importFrom data.table fread
#' @importFrom grDevices dev.off jpeg
#' @importFrom graphics hist plot 
#' @importFrom plotly ggplotly
#' @export sapphire_plot
#' @import ggplot2


sapphire_plot <- function(sap_file = NULL, sap_table = NULL, write = F, folderPlot = "plots/", return_plot = F, local_cut = TRUE,
                          timeline = FALSE, sub_sampling_factor = NULL, ann_trace = FALSE, return_ann_trace = FALSE, use_plotly = FALSE,
                          title = "", ...){
  
  # Analysis of extra args
  input_args <- list(...)
  avail_extra_argoments <- c('only_timeline',
                             'reorder_annotation', 
                             'annotate_snap_dist',
                             'rescaling_ann_col', # if true the numerical ann are rescaled in grey
                             'snap_dist_annotation_height',
                             'reorder_horizline_on_timeline',
                             'reorder_points_on_timeline',
                             'plot_legend', # plot the legend for the annotation
                             'uniform_color_timeline', # to put the timeline (and the distance annotation trace) in a simple black
                             'which_uniform_color_timeline',
                             
                             'timeline_proportion',
                             'ann_height',
                             'ann_initial_point', # annotation trace initial point (between 0 and 1)
                             'localcutbasin_prop_height',
                             'basin_prop_height',
                             'horiz_lines_on_timeline', 
                             'horiz_colored_areas',
                             'points_on_timeline', 
                             'vertical_barriers_points', 
                             'specific_palette_timeline', 
                             'specific_palette_annotation',
                             
                             'legend_title',
                             'legend_labels',
                             'annotation_type',
                             
                             'parabolic_subtraction',
                             
                             'general_size_annPoints',
                             'size_points_on_timeline')
                             

  if(any(!(names(input_args) %in% avail_extra_argoments))) 
    warning('There is a probable mispelling in one of the inserted variables. Please check the available extra input arguments.')
  
  # Default handling
  if(!('only_timeline' %in% names(input_args))) only_timeline <- FALSE else only_timeline <- input_args[['only_timeline']]
  if(!('reorder_annotation' %in% names(input_args))) reorder_annotation <- TRUE else reorder_annotation <- input_args[['reorder_annotation']]
  if(!('annotate_snap_dist' %in% names(input_args))) annotate_snap_dist <- FALSE  else annotate_snap_dist <- input_args[['annotate_snap_dist']]
  if(!('rescaling_ann_col' %in% names(input_args))) rescaling_ann_col <- TRUE  else rescaling_ann_col <- input_args[['rescaling_ann_col']]
  if(!('reorder_horizline_on_timeline' %in% names(input_args))) reorder_horizline_on_timeline <- FALSE else reorder_horizline_on_timeline <- input_args[['reorder_horizline_on_timeline']]
  if(!('reorder_points_on_timeline' %in% names(input_args))) reorder_points_on_timeline <- FALSE  else reorder_points_on_timeline <- input_args[['reorder_points_on_timeline']]
  if(!('plot_legend' %in% names(input_args))) plot_legend <- FALSE  else plot_legend <- input_args[['plot_legend']]
  if(!('uniform_color_timeline' %in% names(input_args))) uniform_color_timeline <- TRUE  else uniform_color_timeline <- input_args[['uniform_color_timeline']]
  if(!('parabolic_subtraction' %in% names(input_args))) parabolic_subtraction <- FALSE  else parabolic_subtraction <- input_args[['parabolic_subtraction']]
  if(!('which_uniform_color_timeline' %in% names(input_args))) which_uniform_color_timeline <- "black"  else which_uniform_color_timeline <- input_args[['which_uniform_color_timeline']]
  
  if(!('timeline_proportion' %in% names(input_args))) timeline_proportion <- NULL else timeline_proportion <- input_args[['timeline_proportion']]
  if(!('ann_height' %in% names(input_args))) ann_height <- NULL else ann_height <- input_args[['ann_height']]
  if(!('snap_dist_annotation_height' %in% names(input_args))) snap_dist_annotation_height <- NULL  else snap_dist_annotation_height <- input_args[['snap_dist_annotation_height']]
  if(!('localcutbasin_prop_height' %in% names(input_args))) localcutbasin_prop_height <- NULL else localcutbasin_prop_height <- input_args[['localcutbasin_prop_height']]
  if(!('basin_prop_height' %in% names(input_args))) basin_prop_height <- NULL else basin_prop_height <- input_args[['basin_prop_height']]
  if(!('ann_initial_point' %in% names(input_args))) ann_initial_point <- NULL else ann_initial_point <- input_args[['ann_initial_point']]
  if(!('horiz_lines_on_timeline' %in% names(input_args))) horiz_lines_on_timeline <- NULL else horiz_lines_on_timeline <- input_args[['horiz_lines_on_timeline']]
  if(!('horiz_colored_areas' %in% names(input_args))) horiz_colored_areas <- NULL else horiz_colored_areas <- input_args[['horiz_colored_areas']]
  if(!('points_on_timeline' %in% names(input_args))) points_on_timeline <- NULL else points_on_timeline <- input_args[['points_on_timeline']]
  if(!('vertical_barriers_points' %in% names(input_args))) vertical_barriers_points <- NULL else vertical_barriers_points <- input_args[['vertical_barriers_points']]
  if(!('specific_palette_timeline' %in% names(input_args))) specific_palette_timeline <- NULL else specific_palette_timeline <- input_args[['specific_palette_timeline']]
  if(!('specific_palette_annotation' %in% names(input_args))) specific_palette_annotation <- NULL else specific_palette_annotation <- input_args[['specific_palette_annotation']]
  if(!('legend_title' %in% names(input_args))) legend_title <- NULL else legend_title <- input_args[['legend_title']]
  if(!('legend_labels' %in% names(input_args))) legend_labels <- NULL else legend_labels <- input_args[['legend_labels']]
  if(!('annotation_type' %in% names(input_args))) annotation_type <- NULL else annotation_type <- input_args[['annotation_type']]
  
  if(!('general_size_annPoints' %in% names(input_args))) general_size_annPoints <- 1. else general_size_annPoints <- input_args[['general_size_annPoints']]
  if(!('size_points_on_timeline' %in% names(input_args))) size_points_on_timeline <- 0.005 else size_points_on_timeline <- input_args[['size_points_on_timeline']]

  # ============================
  #          CHECKS
  # ============================
  #
  #
  # ---------------------
  # check on title
  if(!is.character(title)) stop("title var must be a string")
  # ---------------------
  # check on output folder
  if(file.exists(folderPlot)&&write) print(paste0(folderPlot," already exixts. Posting plots there."))
  else if(write){
    dir.create(folderPlot)
    cat(paste0(folderPlot," created in order to contain new plots.\n"))
  }
  # ---------------------
  # checking the logicals
  if(!is.logical(return_plot))
    stop('return_plot must be a logical.')
  if(!is.logical(return_ann_trace))
    stop('return_ann_trace must be a logical.')
  if(!is.logical(timeline))
    stop('timeline must be a logical.')
  if(!is.logical(local_cut))
    stop('local_cut must be a logical.')
  if(!is.logical(write))
    stop('write must be a logical.')
  if(!is.logical(annotate_snap_dist))
    stop('annotate_snap_dist must be a logical.')
  if(!is.logical(only_timeline))
    stop('only_timeline must be a logical.')
  if(!is.logical(reorder_annotation))
    stop('reorder_annotation must be a logical.')
  if(!is.logical(reorder_points_on_timeline))
    stop('reorder_points_on_timeline must be a logical.')
  if(!is.logical(reorder_horizline_on_timeline))
    stop('reorder_horizline_on_timeline must be a logical.')
  if(!is.logical(rescaling_ann_col))
    stop('rescaling_ann_col must be a logical.')
  if(!is.logical(use_plotly))
    stop('use_plotly must be a logical.')
  if(!is.logical(plot_legend))
    stop('plot_legend must be a logical.')
  if(!is.logical(uniform_color_timeline))
    stop('uniform_color_timeline must be a logical.')
  
  # --------------------- 
  # putting on timeline if only timeline is on
  if(only_timeline && !timeline)
    timeline <- TRUE
  
  # ---------------------  
  # general_size_annPoints = 1 must be a numeric
  if(!is.numeric(general_size_annPoints) || length(general_size_annPoints) != 1)
    stop('general_size_annPoints must be a single numeric.')
  
  # ---------------------  
  # size_points_on_timeline = 0.01 must be a numeric
  if(!is.numeric(size_points_on_timeline) || length(size_points_on_timeline) != 1)
    stop('size_points_on_timeline must be a single numeric.')

  # ---------------------
  # timeline_proportion must be single numeric
  if(!is.null(timeline_proportion) && (!is.numeric(timeline_proportion) || length(timeline_proportion) != 1))
    stop('timeline_proportion must be a single numeric.')
  
  # ---------------------
  # loading data - sapphire table
  # the coercion to data.frame is made for retrocompatibili with non-data.table code
  if(is.null(sap_table)&&!is.null(sap_file)) pin <- data.frame(fread(sap_file)) 
  else if(is.null(sap_file)&&!is.null(sap_table)) pin <- sap_table
  else stop("Sapphire table needed in input. Check the documentation")
  dp <- dim(pin)
  Nsnap <- dp[1]
  
  # ---------------------
  # checking single numbers 
  if(!is.null(sub_sampling_factor) && (!is.numeric(sub_sampling_factor) || length(sub_sampling_factor) != 1 || (Nsnap%%sub_sampling_factor != 0))){
    warning('Wrong sub_sampling_factor insertion. It should be a number divisible by the number of snapshots. Otherwise, it will be used anyway with a truncated ending.')
    # cat('Checking a different value for sub_sampling factor (the first divisible number).')
    # divisible_sub_sampling values
    # for(i in 2:Nsnap){
    #   {if(Nsnap%%i==0) print(sum(trial_len)/i)}
    # }
  }else if(!is.null(sub_sampling_factor)){
    do_subsam_ann <- TRUE
  }else{
    do_subsan_ann <- FALSE
    sub_sampling_factor <- 1
  }
  if(!.isSingleInteger(sub_sampling_factor) || sub_sampling_factor > (Nsnap-2)/2 || sub_sampling_factor < 0)
    stop('sub_sampling factor is more than half or less than 0 (or not a single integer).')
  
  # ---------------------
  # checking the horiz_lines_on_timeline
  if(!is.null(horiz_lines_on_timeline)) {
    if(!is.numeric(horiz_lines_on_timeline))
      stop('horiz_lines_on_timeline must be a numeric.')
    if(any(horiz_lines_on_timeline%%1 != 0) || any(horiz_lines_on_timeline > Nsnap) || any(horiz_lines_on_timeline < 1))
      stop('horiz_lines_on_timeline must be an integer in the trj dimensions.')
  }
  
  # ---------------------
  # checking the barriers
  if(!is.null(vertical_barriers_points)) {
    if(!is.numeric(vertical_barriers_points))
      stop('vertical_barriers_points must be a numeric.')
    if(any(vertical_barriers_points%%1 != 0) || any(vertical_barriers_points > Nsnap) || any(vertical_barriers_points < 1))
      stop('vertical_barriers_points must be an integer in the trj dimensions.')
  }
  
  # ---------------------
  # checking the horiz_colored_areas (plotted vertically)
  if(!is.null(horiz_colored_areas)){
    if((!is.numeric(horiz_colored_areas) || 
        any(horiz_colored_areas%%1 != 0) || any(horiz_colored_areas > 5) || any(horiz_colored_areas < 1)))
      stop('horiz_lines_on_timeline must be a numeric vector (integer between 1 and 5). It will color the section of horiz_lines_on_timeline.')
    if(is.null(horiz_lines_on_timeline))
      stop('Current implementation does not handle area labeling on the timeline with different steps than horizontal lines (horiz_lines_on_timeline).')
    n_h_partitions <- length(horiz_colored_areas)
    if(! length(horiz_lines_on_timeline) %in% c(n_h_partitions - 1, n_h_partitions, n_h_partitions + 1))
      stop('Number of colored areas labels must match the number of horizontal lines. ')
  } 
  
  # ---------------------
  # checking the points on the timeline
  if(!is.null(points_on_timeline)){
    if(!is.numeric(points_on_timeline))
      stop('points_on_timeline must be a numeric.')
    if(any(points_on_timeline%%1 != 0) || any(points_on_timeline > Nsnap) || any(points_on_timeline < 1))
      stop('points_on_timeline must be an integer in the trj dimensions.')
  }
  
  # ---------------------
  # checking the color palette
  if(!is.null(specific_palette_timeline) &&
     (!all(is.character(specific_palette_timeline)) || !all(nchar(specific_palette_timeline)==7) || !all(sapply(specific_palette_timeline, function(x){substring(x,1,1)}) == "#")))
    stop('specific_palette_timeline must be of the type "#b47b00", "#D9E000" (7 characters starting with #')
  
  if(!is.null(specific_palette_annotation) &&
     (!all(is.character(specific_palette_annotation)) || !all(nchar(specific_palette_annotation)==7) || !all(sapply(specific_palette_annotation, function(x){substring(x,1,1)}) == "#")))
    stop('specific_palette_annotation must be of the type "#b47b00", "#D9E000" (7 characters starting with #')
  
  # possible color overlapping
  if(!is.null(specific_palette_annotation) && rescaling_ann_col)
    warning('As you inserted a specific palette the color rescaling (grayscale) will not considered.')
  if(!is.null(specific_palette_annotation) && rescaling_ann_col) rescaling_ann_col <- FALSE
  # ---------------------
  # checking assignments for legend title and legend labels
  leg_tit <- NULL
  leg_lab <- NULL
  if(!plot_legend && (!is.null(legend_title) || !is.null(legend_labels))){
    warning('Inserted legend_title or legend_labels variables WITHOUT activating plot_legend. This option will be turned on automatically.')
    plot_legend <- TRUE
  }
  if(plot_legend){
    
    # checking the legend title
    if(!is.null(legend_title)){
      if(!is.character(legend_title))
        stop('legend_title must be a character.')
      if(length(legend_title) != 1)
        stop('legend_title must be a SINGLE character.')
      
      leg_tit <- legend_title
    }else{
      leg_tit <- 'Legend'
    }
    
    # checking the labels
    if(!is.null(legend_labels)){
      if(!is.character(legend_labels))
        stop('legend_labels must be a vector of characters.')
      if(!is.null(dim(legend_labels)))
         stop('legend_labels must be a vector of characters (found more than 1 dimension).')
      leg_lab <- c(legend_labels)
    }else{
      warning('No label inserted for the legend. they will be assigned to integers.')
      leg_lab <- NULL
    }
  }
  
  # ---------------------
  # checking ann_trace input
  # ---------------------
  # logic standards
  no_trace <- FALSE
  automatic_trace_half <- FALSE
  # manual insertion std
  one_line_trace <- FALSE
  multi_line_trace <- FALSE
  numeric_trace <- FALSE
  character_trace <- FALSE
  n_partitions_trace <- FALSE
  
  # Main switcher
  if(is.logical(ann_trace) && ann_trace){
    automatic_trace_half <- TRUE 
    one_line_trace <- TRUE
  }else if(is.logical(ann_trace) && !ann_trace){
    no_trace <- TRUE
  # if not logical
  }else{
    # one line 
    if(is.null(dim(ann_trace)) || length(dim(ann_trace)) == 1){
      one_line_trace <- TRUE
      # correct length
      if(length(ann_trace) == Nsnap){
        # is numeric?
        if(is.numeric(ann_trace)){
          # if(rescaling_ann_col) ann_trace <- as.integer(ann_trace) # not needed: it can generate imprecisions before the division and floor done afterwards
          if(any(ann_trace < 0)){
            warning('Inserted negative values in the annotation trace. ', sum(ann_trace < 0), ' values have been coerced to pos.')
            ann_trace <- abs(ann_trace)
          }
          # if(any(ann_trace == 0)){
          #   warning('Inserted 0 values (', sum(ann_trace==0), ') in the annotation trace. 1 is added to all values.')
          #   ann_trace <- ann_trace + 1
          # }
          numeric_trace <- TRUE
        # is character?
        }else if(is.character(ann_trace)){
          character_trace <- TRUE
        }else{
          warning('The single line annotation trace must be an integer vector or a character vector (NOTE: factors must be coherced to char BEFORE the call). 
                  Annotation deactivated.')
          no_trace <- TRUE
        }
      # one line different length < n_snaps
      }else if(length(ann_trace) < Nsnap){
        # case one number -> number of partitions to do
        if(length(ann_trace) == 1){
          n_partitions_trace <- TRUE
        }else{
          warning('If you use single line annotation, you can use a whole line (length identical to the number of snapshots) 
                  or a single number with the partitions. None of those found, therefore annotation has been deactivated.')
          no_trace <- TRUE
        }
      }else{
        warning('The single line annotation trace must have length identical to the number of snapshots. Annotation deactivated.')
        no_trace <- TRUE
      }
      
    # multiple lines
    }else if(length(dim(ann_trace)) == 2){
      # warning("MULTIPLE LINES NOT WORKING FOR GGPLOT2 UPDATE - TODO")
      multi_line_trace <- TRUE
      n_lines_annotation <- dim(ann_trace)[1]
      if(is.numeric(ann_trace)){
        # if(rescaling_ann_col){
        #   for(i in 1:n_lines_annotation)
        #     ann_trace[i,] <- as.integer(ann_trace[i,])
        # }
        numeric_trace <- TRUE
        # is character?
      }else if(is.character(ann_trace)){
        character_trace <- TRUE
      }else{
        warning('The multiple line annotation trace must be an integer vector or a character vector (NOTE: factors must be coherced to char BEFORE the call). 
                Annotation deactivated.')
        no_trace <- TRUE
      }
    # boh, deactivated
    }else{
      warning('Found strange annotation values. Please check them (annotation function deactivated)')
      no_trace <- TRUE
    }
  } 
  
  # some warning check on the overlapping of color modes
  if(!is.null(specific_palette_annotation) && character_trace)
    warning('As you inserted a specific palette the character trace inserted will not be considered.')
  if(character_trace && rescaling_ann_col)
    warning('As you inserted a character trace the color rescaling (grayscale) will not be considered.')
  
  # ---------------------
  # checking the reordering of the annotation (functionality that is working only with one-line whatever) TODO extend it
  if(reorder_annotation){
    if(n_partitions_trace || automatic_trace_half){
      warning('reorder_annotation is supported only for direct (==nrow(trj)) numeric-character insertion')
      warning('WARNING WARNING: the reordering has been set to NO. In the case of direct insertion it could be a problem.
               NOTE: it is automatically done in the case of half split (ann_trace = T) or number of splits (ann_trace = whatever number).')
      reorder_annotation <- FALSE
    }
  }else{
    warning('WARNING WARNING: reorder_annotation is false. We suppose that you know it and your annotation has been already reordered accordingly.')
  }
  
  # ============================
  # Main ann_trace constructor
  # ============================
  #
  if(!no_trace){
    ann_tr <- array("NA", dim = Nsnap)
    # ---------------------
    # AUTOMATIC 2 divisions: ann_trace == TRUE 
    if(automatic_trace_half){
      message("Annotation trace set to automatic. It will be considered bipartite along the timeline.")
      cat("Half random mode selected for the trace annotation. First half will be light grey.\n")
      ann_tr[pin[,3] >= Nsnap/2 & ann_tr == "NA"] <- "gray75"
      ann_tr[pin[,3] < Nsnap/2 & ann_tr == "NA"] <- "gray30"
    }
    # ---------------------
    # AUTOMATIC n partitions: ann_trace == number of partitions
    if(n_partitions_trace){
      message("Only 10 shades of grey are possible for the 'number' option of ann_trace.
              If you inserted more than 10 it will be truncated. Please consider manual color insertion.")
      if(ann_trace>10) {
        warning('inserted more than 10 possible division of the timeline. It has been truncated to 10.')
        ann_trace = 10
      }
      ann_tr[pin[,3]<Nsnap/ann_trace] <- "gray1"
      for(i in 1:(ann_trace-1)) 
        ann_tr[pin[,3] < Nsnap*(i+1)/ann_trace
               & pin[,3] >= Nsnap*(i)/ann_trace
               & ann_tr == "NA"] <- paste0("gray",floor(100/ann_trace)*i)
    }
    # ---------------------
    # DIRECT INSERTION (ONE LINE): ann_trace == exactly the ann_trace
    if(!automatic_trace_half && one_line_trace){
      
      # as character
      if(character_trace){
        
        # reordering
        if(reorder_annotation)
          ann_tr <- ann_trace[pin[,3]]
        else
          ann_tr <- ann_trace
        
      # as numeric
      }else if(numeric_trace){
        
        # rescaling colors (grey based)
        if(rescaling_ann_col){
          max_value_ann_trace <- max(ann_trace)
          ann_tr <- sapply(ann_trace, FUN = function(x){ paste0("gray",floor(70/max_value_ann_trace*x)) })
        }else{
          ann_tr <- ann_trace
        }
        # reordering      
        if(reorder_annotation)
          ann_tr <- ann_tr[pin[,3]]
      }
    }
    # ---------------------
    # DIRECT INSERTION (MULTI LINE):ann_trace == multi-lines annotation
    if(multi_line_trace){
      ann_tr <- array("NA", dim = dim(ann_trace))
      
      # as character
      if(character_trace){
        # reordering
        if(reorder_annotation)    
          for(i in 1:n_lines_annotation)
            ann_tr[i,] <- ann_trace[i, pin[,3]]
        else
          ann_tr <- ann_trace
        
      # as numeric
      }else if(numeric_trace){
        
        # rescaling colors (grey based)
        if(rescaling_ann_col){
          for(i in 1:n_lines_annotation){
            max_value_ann_trace <- max(ann_trace[i,])
            ann_tr[i,] <- sapply(ann_trace[i,],FUN = function(x){paste0("gray",floor(70/max_value_ann_trace*x))})
          }
        }else{
          # reordering
          if(reorder_annotation)    
            for(i in 1:n_lines_annotation)
              ann_tr[i,] <- ann_trace[i, pin[,3]]
            else
              ann_tr <- ann_trace
        }
      }
    }
  }else{
    warning("Annotation trace option not used.")
  }
  
  
  # ============================
  #         The plot
  # ============================
  #
  #
  #
  # ---------------------
  # Set range of x and y values for the plot:
  xx <- seq(from=1, by=1, to=Nsnap)[seq(1, Nsnap, sub_sampling_factor)]
  
  ymin = 0
  y_cut = -log(pin[,4]/Nsnap)
  if(any(is.na(y_cut))){ # is na check. what about the inf?
    warning('Attention: the basic annotation generated NAs during the -log(it) in number equal to ', sum(is.na(y_cut)),'. they will be set to the min (without them).')
    y_cut[is.na(y_cut)] <- min(y_cut[!is.na(y_cut)])
  }
  if(any(is.infinite(y_cut))){ # is na check. what about the inf?
    warning('Attention: the basic annotation generated Inf during the -log(it) in number equal to ', sum(is.infinite(y_cut)),'. they will be set to the max (without them).')
    y_cut[is.infinite(y_cut)] <- max(y_cut[!is.infinite(y_cut)])
  }
  if(local_cut) {
    y_local_cut = 2.5 - (1./3.)*log((pin[,10] + pin[,12]) / Nsnap)
    if(any(is.na(y_local_cut))){ # is na check. what about the inf?
      warning('Attention: the local cut annotation generated NAs during the -log(it) in number equal to ', sum(is.na(y_local_cut)),'. they will be set to the min (without them).')
      y_local_cut[is.na(y_local_cut)] <- min(y_local_cut[!is.na(y_local_cut)])
    }
    if(any(is.infinite(y_local_cut))){ # is na check. what about the inf?
      warning('Attention: the local cut annotation generated Infs during the -log(it) in number equal to ', sum(is.infinite(y_local_cut)),'. they will be set to the max (without them).')
      y_local_cut[is.infinite(y_local_cut)] <- max(y_local_cut[!is.infinite(y_local_cut)])
    }
  }
  if(local_cut) ymax_local_cut = max(y_local_cut)
  ymax_cut = max(y_cut)
  if(local_cut) ymax = max(c(ymax_cut, ymax_local_cut))
  else ymax = max(ymax_cut)
  
  # baseline of the local cut and basin cut
  if(local_cut){
    if(!is.null(localcutbasin_prop_height) && is.numeric(localcutbasin_prop_height) && length(localcutbasin_prop_height) == 1L){
      if(localcutbasin_prop_height >= 1 || localcutbasin_prop_height < 0){
        warning("Inserted initial annotation point too small or too big (between 0-1).")
        localcutbasin_prop_height <- ymax_local_cut*1/4.
      }
      localcutbasin_prop_height <- localcutbasin_prop_height*ymax_local_cut
    }else{
      localcutbasin_prop_height <- ymax_local_cut*1/4.
    }
  }
  if(!is.null(basin_prop_height) && is.numeric(basin_prop_height) && length(basin_prop_height) == 1L){
    if(basin_prop_height >= 1 || basin_prop_height < 0){
      warning("Inserted initial annotation point too small or too big (between 0-1).")
      basin_prop_height <- ymax_cut*1/4.
    }
    basin_prop_height <- basin_prop_height*ymax_cut
  }else{
    basin_prop_height <- ymax_cut*1/4.
  }
  
  if(local_cut) y_local_cut = y_local_cut - localcutbasin_prop_height
  y_cut = y_cut - basin_prop_height
  
  # ---------------------
  # initial creation of the plot
  gg <- ggplot() +
    xlab("Progress Index") + ylab("Annotation")
  # theme_bw() +
  # theme(panel.grid.minor = element_line(colour="gray80"))
  
  # ---------------------
  # Trace height from the top. This is the 0-16 parts out of ymax
  if(!is.null(ann_height) && is.numeric(ann_height) && length(ann_height) == 1L){
    if(ann_height > 1 || ann_height < 0){
      warning("Inserted background height too small or too big (0-1 must be).")
      ann_height <- ymax/8.
    }
    ann_height <- ann_height*ymax
  }else{
    ann_height <- ymax/8.
  }
  
  # height of the snap_dist annotation
  if(!is.null(snap_dist_annotation_height)){
    if(.isSingleElement(snap_dist_annotation_height) && 
     is.numeric(snap_dist_annotation_height)){
      if(ann_height > 1 || ann_height < 0){
        warning("Inserted background height too small or too big (0-1 must be).")
        snap_dist_annotation_height <- ymax/8.
      }
      if(!annotate_snap_dist){
        warning('You inserted snap_dist_annotation_height without putting annotate_snap_dist = T. We will do it for you.')
        annotate_snap_dist <- T
      }
    }else{
      warning('Inserted strange snap_dist_annotation_height. Should be a number between 0-1.')
    }
    snap_dist_annotation_height <- snap_dist_annotation_height*ymax
  }else{
    snap_dist_annotation_height <- ymax/8.
  }
  
  # initial point of the annotation
  if(!is.null(ann_initial_point) && is.numeric(ann_initial_point) && length(ann_initial_point) == 1L){
    if(ann_initial_point >= 1 || ann_initial_point < 0){
      warning("Inserted initial annotation point too small or too big (between 0-1).")
      ann_init <- ymax*3/4.
    }
    ann_init <- ann_initial_point*ymax
  }else{
    ann_init <- ymax*3/4.
  }

  # -------------------------------------------------------------------------------------
  # main trace - plotting
  # some specific search and check for the legend (continuous vs discrete)
  # checks on annotation type
  if(!no_trace){
    ann_tmp <- NULL
    if(!is.null(annotation_type))
      cat('No option selected for the kind of annotation (annotation_type will be mainly used for the legend). 
           Trying to guess. \n')
    
    # checking if which annotation is meaningful (if set or not)  
    ann_tmp <- factor(ann_tr)
    if(length(levels(ann_tmp)) <= 10) annotation_type_tmp <- 'discrete'
    else annotation_type_tmp <- 'continuous'
    if(rescaling_ann_col) annotation_type_tmp <- 'discrete'
    
    # check annotation_type insertion
    if(!is.null(annotation_type)){
      if(!.isSingleElement(annotation_type) || !is.character(annotation_type) || !(annotation_type %in% c('discrete', 'continuous')))
        stop('Annotation_type variable must be a signle character between "discrete" and "continuous".')
      if(annotation_type_tmp != annotation_type)
        warning('The analysis of the annotation type (continuous vs discrete) collides with the inserted one. 
                Please check that the number of classes in the discrete one are less than 10.')
    }else{
      annotation_type <- annotation_type_tmp
    }
    # discrete
    if(annotation_type == 'discrete'){
      if(!is.null(specific_palette_annotation)){
        if(length(specific_palette_annotation) != length(levels(ann_tmp)))
          stop('When using a discrete annotation_type please set the specific_palette_annotation to the same number of factors in the annotation.')
      }else{
        specific_palette_annotation <- levels(ann_tmp)
      }
      # continuous
    }else if(annotation_type == 'continuous'){
      if(is.null(specific_palette_annotation)){
        specific_palette_annotation <- levels(factor(ann_tr))
        # if(is.character(ann_tr) || rescaling_ann_col) # there seems no need of this check because it is already considered before
        #   stop('You inserted a characther annotation trace or decided to rescale the annotation colors. When using annotation_type = "continuous"
        #          this can be tricky without a proper specific_palette_annotation. Please specify a palette.')
      }
    }  
    # legend check
    if(plot_legend){
      # checks on the discrete annotation_type
      if(annotation_type == 'discrete'){
        if(is.null(leg_lab)) leg_lab <- seq(1, length(specific_palette_annotation))
        if(!is.null(leg_lab) && length(leg_lab) != length(specific_palette_annotation))
          stop('Inserted different number of labels than colors. In the discrete annotation mode this cannot be done.')
        if(!is.null(leg_lab) && length(leg_lab) != length(levels(ann_tmp)))
          stop('Inserted different number of labels than factors in the annotation (e.g. different numbers 1-2-3). In the discrete annotation mode this cannot be done.') 
        if(length(levels(ann_tmp)) > 10)
          warning('There are a lot of levels (>10) in the discrete annotation. Consider using a continuous annotation type along with a continuous legending.')
        if(length(levels(ann_tmp)) > 20){
          warning('There are too many levels (>20). Continuous legending activated.')
          annotation_type <- 'continuous'
        }
      }
      # checks on the continuous annotation_type
      if(annotation_type == 'continuous'){
        if(is.null(leg_lab)) leg_lab <- seq(1, length(specific_palette_annotation))
        # check on the leg_lab
        if(!is.null(leg_lab) && length(leg_lab) > length(specific_palette_annotation))
          warning('Inserted more labels than colors. It will be done anyway.')
      }
    }
  }
  if(!no_trace && plot_legend) cat('Annotation inserted for the legend consists of the following kind of clusters:', annotation_type, '\n')
  # ------------------------------------------------------------------------------------- one line trace
  if(!no_trace && one_line_trace){
    if(is.null(specific_palette_annotation)){
      gg <- gg + geom_segment(aes(xx,
                                  y = rep(ann_init, length(xx)),
                                  xend = xx,
                                  yend = rep(ann_init + ann_height, length(xx))),
                              col = ann_tr[seq(1, Nsnap, sub_sampling_factor)], # color must be out if no palette is used
                              size = 0.1*general_size_annPoints)
      
    # specific color palette
    }else{
      
      # putting the right 'discrete' 'continuous' swapper
      if(annotation_type == 'discrete') ann_tr_tmp <- as.factor(ann_tr)
      else if(!rescaling_ann_col && annotation_type == 'continuous') ann_tr_tmp <- as.numeric(ann_tr) 
      else stop('rescaling the colors force to put strings in the annotation. No continuous annotation_type can work with this option on.')
      
      gg <- gg + geom_segment(aes(xx, 
                                  y = rep(ann_init, length(xx)),
                                  xend = xx, 
                                  yend = rep(ann_init + ann_height, length(xx)), 
                                  col = ann_tr_tmp[seq(1, Nsnap, sub_sampling_factor)]), # col is INSIDE aes
                              size = 0.1*general_size_annPoints)
      
      # If the legend must be plotted:
      if(plot_legend){
        # discrete case
        if(annotation_type == 'discrete'){
          gg <- gg + scale_color_manual(name = leg_tit,
                                        values = specific_palette_annotation,
                                        labels = leg_lab) +
            guides(color = guide_legend(override.aes = list(size=5))) # makes the lagend box bigger 
        # continuous case
        }else if(annotation_type == 'continuous'){
          # if(is.character(ann_tr_tmp))
          #   stop('The specific insertion of a palette collides with the rescaling of the colors. Please turn it off to use the specific palette option.')
          gg <- gg + scale_color_gradientn(leg_tit, na.value = 'transparent', colours = specific_palette_annotation,
                                           breaks = seq(min(ann_tr_tmp), max(ann_tr_tmp), length.out = length(leg_lab)),
                                           labels = leg_lab) 
        }else{
          stop('annotation_type must be continuous or discrete')
        }
        # no legend to plot
      }else{
        # discrete case
        if(annotation_type == 'discrete'){
          gg <- gg + scale_color_manual(values = specific_palette_annotation, guide = FALSE) 
        # continuous case
        }else if(annotation_type == 'continuous'){
          gg <- gg + scale_color_gradientn(colours = specific_palette_annotation, guide = FALSE) #  guide_legend(title = "Days")
        }
      }
    }
    
  # ------------------------------------------------------------------------------------- multi line trace
  }else if(!no_trace && multi_line_trace){
    
    # var init
    tmp_ann <- c()
    height_one_band <- ann_height/n_lines_annotation
    y_multilines <- array(NA, dim = c(n_lines_annotation, length(xx)))
    x_multilines <- rep(xx, n_lines_annotation)
    # sequential add of the height of the horizontal band
    for(i in 1:n_lines_annotation){
      y_multilines[i,] <- rep(ann_init, length(xx)) + height_one_band*(i-1)
      if(sub_sampling_factor!=1)
        tmp_ann <- c(tmp_ann, ann_tr[i,][seq(1, Nsnap, sub_sampling_factor)])
    }
    if(sub_sampling_factor==1) tmp_ann <- c(t(ann_tr))
    
    # main vectorization and plot 
    # -------------------------------------- no colorpalette
    if(is.null(specific_palette_annotation)){ 
      gg <- gg + geom_segment(aes(x = c(x_multilines),
                              y = c(t(y_multilines)),
                              xend = c(x_multilines),
                              yend = c(t(y_multilines) + height_one_band)),
                              col = tmp_ann,
                              size = 0.1*general_size_annPoints)
      
    # --------------------------------------  specific color palette
    }else{
      
      # putting the right 'discrete' 'continuous' swapper
      if(annotation_type == 'discrete') ann_tr_tmp <- as.factor(tmp_ann)
      else if(!rescaling_ann_col && annotation_type == 'continuous') ann_tr_tmp <- as.numeric(tmp_ann) 
      else stop('rescaling the colors force to put strings in the annotation. No continuous annotation_type can work with this option on.')
      
      # normal handling of the plot
      gg <- gg + geom_segment(aes(x = c(x_multilines),
                                  y = c(t(y_multilines)),
                                  xend = c(x_multilines),
                                  yend = c(t(y_multilines) + height_one_band),
                                  col = ann_tr_tmp), # WRONG must go inside the aes
                              size = 0.1*general_size_annPoints)
      
      # If the legend must be plotted:
      if(plot_legend){
        
        # discrete case
        if(annotation_type == 'discrete'){
          gg <- gg + scale_color_manual(name = leg_tit,
                                        values = specific_palette_annotation,
                                        labels = leg_lab) +
                guides(color = guide_legend(override.aes = list(size=5))) # makes the lagend box bigger 
          
        # continuous case
        }else if(annotation_type == 'continuous'){
          # if(is.character(ann_tr_tmp))
          #   stop('The specific insertion of a palette collides with the rescaling of the colors. Please turn it off to use the specific palette option.')
          gg <- gg + scale_color_gradientn(leg_tit, na.value = 'transparent', colours = specific_palette_annotation,
                                           breaks = seq(min(ann_tr_tmp), max(ann_tr_tmp), length.out = length(leg_lab)),
                                           labels = leg_lab) 
        }else{
          stop('annotation_type must be continuous or discrete')
        }
        
      # no legend to plot
      }else{
        
        # discrete case
        if(annotation_type == 'discrete'){
          gg <- gg + scale_color_manual(values = specific_palette_annotation, guide = FALSE)
          
        # continuous case
        }else if(annotation_type == 'continuous'){
          gg <- gg + scale_color_gradientn(colours = specific_palette_annotation, guide = FALSE) #  guide_legend(title = "Days")
        }
      }
    }
  }
  
  # -------------------------------------------------------------------------------------
  # SETING: NO MORE THAN ONE ANN LINE AVAILABLE - annotation preparation for timeline and annotation of snap distance
  # todo - manual insertion of a color coded stuff!
  if(timeline || annotate_snap_dist){ # 'black' is the standard along with uniform_color_timeline = T if put 'annotation' it uses the trace
    if(!.isSingleElement(which_uniform_color_timeline))
      stop('which_uniform_color_timeline must be a single element.')
    if(which_uniform_color_timeline != 'annotation' && !uniform_color_timeline){ 
      warning('Detected insertion of which_uniform_color_timeline without the uniform_color_timeline mode active. It has been automatically activated.')
      uniform_color_timeline <- T
    }
    if(which_uniform_color_timeline == 'annotation' && !uniform_color_timeline){
      if(!no_trace) stop('To select which_uniform_color_timeline using the annotation reference and colors please keep the annotation active.')
      if(one_line_trace){
        single_line_general_ann <- ann_tr
      }else if(multi_line_trace){
        single_line_general_ann <- ann_tr[1,]
        warning('Timeline color kept as first line in annotation trace inserted (it is multiple lines).\n')
      }
    }else{
      single_line_general_ann <- array(which_uniform_color_timeline, dim = Nsnap)
    }
    color_timeline <- single_line_general_ann
  }
  # -------------------------------------------------------------------------------------
  # plotting the distance between snapshots (on top of everything)
  if(annotate_snap_dist){
    max_snap_dist <- max(pin[,5])
    gg <- gg + geom_segment(aes(xx,
                                y = rep(ymax , length(xx)),
                                xend = xx, 
                                yend = ((pin[,5]*1.*snap_dist_annotation_height)/max_snap_dist + ymax)[seq(1, Nsnap, sub_sampling_factor)]),
                            col = color_timeline[seq(1, Nsnap, sub_sampling_factor)],
                            size = 0.1*general_size_annPoints)
  }
  
  # -------------------------------------------------------------------------------------
  # timeline at the bottom
  if(timeline){
    # setting timeline proportions
    if(!is.null(timeline_proportion)){
      tp <- timeline_proportion
      if(tp > 1 || tp < 0.1){
        warning('the timeline proportions was too big in comparison to the plot (it must be between 0.1 and 1). It is coerced to standard value.')
        tp <- 1.0/6
      }
    }else{
      tp <- 1.0/6
    }
    
    # ---------------------------------------- only timeline
    if(only_timeline){
      
      ymax <- Nsnap
      tp <- 1.0
      
      # without palette
      if(is.null(specific_palette_timeline)){
        gg <- ggplot() + geom_point(aes(x=xx,
                                  y = (pin[,3][seq(1, Nsnap, sub_sampling_factor)])),
                                  col=color_timeline[seq(1, Nsnap, sub_sampling_factor)],
                              size=size_points_on_timeline*general_size_annPoints) 
        
      # with palette
      }else{
        # The following will work once the difference between specific_palette_timeline and *_annotation will be adressed
        # if(!no_trace) stop('To put a palette in the only_timeline option you need to put ONE line annotation. 
        #                    If you do not use that this palette does not know how to color the timeline with the inserted palette.')
        # putting the right 'discrete' 'continuous' swapper
        if(annotation_type == 'discrete') color_timeline <- as.factor(color_timeline)
        else if(!rescaling_ann_col && annotation_type == 'continuous') color_timeline <- as.numeric(color_timeline) 
        else stop('rescaling the colors force to put strings in the annotation. No continuous annotation_type can work with this option on.')
        
        gg <- ggplot() + geom_point(aes(x=xx,
                                        y = (pin[,3][seq(1, Nsnap, sub_sampling_factor)]),
                                        col=color_timeline[seq(1, Nsnap, sub_sampling_factor)]), # col INSIDE
                                    size=size_points_on_timeline*general_size_annPoints) 
        gg <- gg + scale_color_gradientn(colours = specific_palette_timeline, guide = FALSE) #  guide_legend(title = "Days")
      } 
      
      # standard add
      gg <- gg + theme_minimal() + 
        annotate("text", label = "0%", x = -Nsnap/90, y = 0, size = 3, angle = 90) +
        annotate("text", label = "100%", x = -Nsnap/90, y = Nsnap, size = 3, angle = 90) +
        xlab("Progress Index") + ylab("Temporal annotation")

    # ----------------------------------------  normal timeline trace (no only)      
    }else{
      # without palette
      if(is.null(specific_palette_timeline)){
        gg <- gg + geom_point(aes(x=xx,
                                  y = ((pin[,3]*1.0*ymax*tp)/Nsnap)[seq(1, Nsnap, sub_sampling_factor)]),
                              col=color_timeline[seq(1, Nsnap, sub_sampling_factor)],
                              size=size_points_on_timeline*general_size_annPoints)
      # with palette
      }else{
        # The following will work once the difference between specific_palette_timeline and *_annotation will be adressed
        # if(!no_trace) stop('To put a palette in the only_timeline option you need to put ONE line annotation. 
        #                    If you do not use that this palette does not know how to color the timeline with the inserted palette.')
        # putting the right 'discrete' 'continuous' swapper
        if(annotation_type == 'discrete') color_timeline <- as.factor(color_timeline)
        else if(!rescaling_ann_col && annotation_type == 'continuous') color_timeline <- as.numeric(color_timeline) 
        else stop('rescaling the colors force to put strings in the annotation. No continuous annotation_type can work with this option on.')
        gg <- gg + geom_point(aes(x=xx,
                                  y = ((pin[,3]*1.0*ymax*tp)/Nsnap)[seq(1, Nsnap, sub_sampling_factor)],
                                  col=color_timeline[seq(1, Nsnap, sub_sampling_factor)]), # col INSIDE
                              size=size_points_on_timeline*general_size_annPoints)
        gg <- gg + scale_color_gradientn(colours = specific_palette_timeline, guide = FALSE) #  guide_legend(title = "Days")
      }
      # standard add
      gg <- gg +
        annotate("text", label = "0%", x = -Nsnap/90, y = 0, size = 3, angle = 90) +
        annotate("text", label = "100%", x = -Nsnap/90, y = 1.0*ymax*tp, size = 3, angle = 90)
    }
    
    # -------------------------------------------------------------------------------------
    # printing horizontal lines on the timeline annotation
    if(!is.null(horiz_lines_on_timeline)){
      
      # adding the initial value to have a correct plotting in color
      if(all(horiz_lines_on_timeline != 1))
        horiz_lines_on_timeline <- c(1, horiz_lines_on_timeline)
      # adding the ending value for identical reasons
      if(all(horiz_lines_on_timeline != Nsnap))
        horiz_lines_on_timeline <- c(horiz_lines_on_timeline, Nsnap)
      
      if(reorder_horizline_on_timeline)
        y_horiz_line <- ((pin[,3]*1.0*ymax*tp)/Nsnap)[horiz_lines_on_timeline]
      else
        y_horiz_line <- ((horiz_lines_on_timeline * 1.0) / Nsnap) * (ymax * tp)
      
      # plotting areas of horizontal lines
      if(!is.null(horiz_colored_areas)){
        gg<- gg + geom_segment(aes(x = 0, xend = 0, 
                                   y = y_horiz_line[1:(length(y_horiz_line)-1)], 
                                   yend = y_horiz_line[2:length(y_horiz_line)]),
                               size=2*general_size_annPoints, col = horiz_colored_areas)
      }
      
      # plotting horizontal lines
      color_horiz_line <- "black"
      gg <- gg + geom_segment(aes(x = xx[1], xend = xx[Nsnap], 
                                  y = y_horiz_line, yend = y_horiz_line),
                              size=0.4*general_size_annPoints, col = color_horiz_line)
    }
    
    # Printing points on the timeline annotation
    if(!is.null(points_on_timeline)){
      
      # adding the initial value to have a correct plotting in color (no just because we can)
      if(all(points_on_timeline != 1))
        points_on_timeline <- c(1, points_on_timeline)
      # adding the ending value for identical reasons
      if(all(points_on_timeline != Nsnap))
        points_on_timeline <- c(points_on_timeline, Nsnap)
      
      if(reorder_points_on_timeline)
        y_points <- ((pin[,3]*1.0*ymax*tp)/Nsnap)[points_on_timeline]
      else
        y_points <- ((points_on_timeline * 1.0) / Nsnap) * (ymax * tp)
      
      color_points <- "green4"
      
      gg <- gg + geom_point(aes(x=xx[points_on_timeline], y=y_points),
                            size=1.5*general_size_annPoints, col = color_points)
    }
  }else if(!is.null(horiz_lines_on_timeline)){
    stop('To use horiz_lines_on_timeline you must have active the timeline options.')
  }else if(!is.null(points_on_timeline)){
    stop('To use points_on_timeline you must have active the timeline options.')
  }
  
  # --------------------- NO MORE NECESSARY. IT IS ENOUGH TO RETURN THE PLOT AND DO IT MANUALLY
  # annotation names LEFT
  # if(!is.null(ann_names_L)&&is.character(ann_names_L)&&length(ann_names_L)==n_lines_annotation){
  #   for(i in 0:(n_lines_annotation-1))
  #     gg <- gg + annotate("text",x = -(length(xx)/24)*nchar(ann_names_L[i+1])/2,
  #                         y = ymax*((tr_init + (((i+0.5)*(16-tr_init))/n_lines_annotation))/16), label = ann_names_L[i+1])
  # }else if(!is.null(ann_names_L)){
  #   stop('The annotation names have not been inserted correctly')
  # }
  # ---------------------
  # annotation names RIGHT
  # if(!is.null(ann_names_R)&&is.character(ann_names_R)&&length(ann_names_R)==n_lines_annotation){
  #   for(i in 0:(n_lines_annotation-1))
  #     gg <- gg + annotate("text",x = length(xx)+(length(xx)/24)*nchar(ann_names_R[i+1])/2,
  #                         y = ymax*((tr_init + (((i+0.5)*(16-tr_init))/n_lines_annotation))/16), label = ann_names_R[i+1])
  # }else if(!is.null(ann_names_R)){
  #   stop('The annotation names have not been inserted correctly')
  # }
  # ---------------------
  # vertical annotation points
  # if(!is.null(vertical_barriers_points)){
  #   # plotting vertical lines
  #   color_vertical_line <- "black"
  #   gg <- gg + geom_segment(aes(x = vertical_barriers_points, xend = (vertical_barriers_points + 1), 
  #                               y = ymin + ymax/8, yend = ymax-ymax/7),
  #                           size=0.4*general_size_annPoints, col = color_vertical_line)
  # }

  
  
  # -------------------------------------------------------------------------------------
  # basic annotation (principal cut)
  if(!only_timeline){
    main_col <- 'darkblue'
    if((timeline && (min(y_cut[seq(1, Nsnap, sub_sampling_factor)]) < tp*ymax)) || (!no_trace && (ann_height > ymax/2.1)))
      main_col <- 'dodgerblue'
    
    if(!parabolic_subtraction){
      gg <- gg + geom_line(aes(x = xx, y = y_cut[seq(1, Nsnap, sub_sampling_factor)]), color=main_col, size=0.8) # SHALL WE KEEP THE NAs?
    }else{
      xx_tmp <- seq(from=1, by=1, to=Nsnap)
      parabol <- 2 * xx_tmp * (Nsnap - xx_tmp)/Nsnap
      parabol <- replace(parabol, which(parabol == 0), min(parabol[-which(parabol == 0)]))
      parabol.log <- -log(parabol/Nsnap)
      cutf <- replace(pin[,4], which(pin[,4] == 0), min(pin[,4][which(pin[,4] > 0)]))
      kin <- -log(cutf/Nsnap) - parabol.log
      if(any(kin > 0)){
        n_neg_kin <- sum(kin > 0)
        warning(paste0('We found negative values in the kinetic trace during parabolic subtraction. This is inexpected. The number of them is: ', n_neg_kin,' 
                       Every value under -0.3 will be truncated automatically.'))
        kin[kin < -0.3] <- 0
      }
      gg <- gg + geom_line(aes(x = xx, y = kin[seq(1, Nsnap, sub_sampling_factor)]), color=main_col, size=0.8) # SHALL WE KEEP THE NAs?
    }
  }
  
  # local cut
  if(!only_timeline){
    if(local_cut){
      if(!parabolic_subtraction){
        gg <- gg + geom_point(mapping = aes(x = xx, y = y_local_cut[seq(1, Nsnap, sub_sampling_factor)]), color = "red3", size = 0.08) 
      }else{
        xx_tmp <- seq(from=1, by=1, to=Nsnap)
        parabol <- 2 * xx_tmp * (Nsnap - xx_tmp)/Nsnap
        parabol <- replace(parabol, which(parabol == 0), min(parabol[-which(parabol == 0)]))
        parabol.log <- -log(parabol/Nsnap)
        cutf <- replace((pin[,10] + pin[,12]), which((pin[,10] + pin[,12]) == 0), min((pin[,10] + pin[,12])[which((pin[,10] + pin[,12]) > 0)]))
        kin <- 2.5 - (1./3.)*log(cutf/Nsnap) - parabol.log
        if(any(kin > 0)){
          n_neg_kin <- sum(kin > 0)
          warning(paste0('We found negative values in the local kinetic trace during parabolic subtraction. This is inexpected. The number of them is: ', n_neg_kin,' 
                       Every value under -0.3 will be truncated automatically.'))
          kin[kin < -0.3] <- 0
        }
        gg <- gg + geom_point(mapping = aes(x = xx, y = kin[seq(1, Nsnap, sub_sampling_factor)]), color = "red3", size = 0.08) 
      }
    }
  }
  
  # -------------------------------------------------------------------------------------
  # title and theme
  gg <- gg + ggtitle(title) + theme_minimal()
  
  
  # writing options should be checked TODO
  if(write) {
    jpeg_file <- 'rplot.jpg'
    jpeg_file_tm <- 0
    while(T){
      if(file.exists(paste0(folderPlot,"/",jpeg_file))){
        jpeg_file_tm <- jpeg_file_tm + 1
        jpeg_file <- paste0('rplot',jpeg_file_tm,".jpg")
      }else
        break
    }
    jpeg(paste0(folderPlot,"/",jpeg_file),width = 1200, height = 900)
    plot(gg)
    dev.off()
  }
  
  # -------------------------------------------------------------------------------------
  # Plotly options
  if(use_plotly) {
    if(length(xx) > 15000)
      warning('time-points (on the x downsampled eventually) are more than 15000. Ggplotly would be stupidly slow and crash. It will be plotted normally.')
    else
      gg <- ggplotly(gg)
  }
  
  # -------------------------------------------------------------------------------------
  # returning and/or plotting
  if(return_plot){
    if(return_ann_trace) warning('No returning of ann_trace is possible if return_plot option is activated')
    invisible(gg)
  }else{
    print(gg)
    if(return_ann_trace) invisible(ann_tr)
  }
}
