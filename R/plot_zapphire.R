#' @title Sapphire plot - plotting annotation and progrex index
#' @description
#'      \code{sapphire_plot} is able to generate a sapphire plot using the progrex index file (e.g. \code{"REPIX_000000000001.dat"})
#'      generated by \code{\link{gen_annotation}}.
#'
#' @param sap_file Annotated progrex index file. This can be left unused if \code{sap_table} is used instead.
#' This input must be the file output of \code{gen_annotation}.
#' @param sap_table Annotated progrex index table. As for \code{sap_file} it can be left unused if the other input is used.
#' Also in this case the format of the table must be the file output of \code{gen_annotation}.
#' @param write A logical indicating whether to write the plot to file.
#' @param folderPlot A character string that defines the folder in which save the plots (\code{write} argument must be \code{TRUE}).
#' @param timeline A logical indicating whether add a timeline annotation (with the original order) on the bottom of the plot.
#' @param local_cut A logical that, if \code{TRUE} plots the local cut annotation function (see \code{gen_annotation}).
#' @param ann_trace This argument can be set to logical, an integer or a matrix of integers. If logical, the annotation will be a horizontal thick line
#' that follows a split in half of the original timeline. If only an integer have been inserted the time line will be split in that number of splits.
#' Instead if a matrix have been inserted it will be a plotted as it is on the top of the plot mapping the range of numbers in order to
#' produce a gray scale horizontal annotation.
#' @param return_plot if \code{TRUE} it returns the plot object (ggplot).
# @param annotate_snap_dist if \code{TRUE} the distance between snapshots will be added on the top of the plot
#' @param sub_sampling_factor if a number is inserted the annotation will be subsampled by that factor.
#' @param return_ann_trace If \code{TRUE} the annotation vector is returned. This option can be really useful for adding layers and specific text using \code{ggplot2}.
# @param background_height Defines the height on which to put the annotation (integer between 1 and 14).
# @param ann_names_L Vector of characther strings indicating, from top on the left, the names of the annotation horizontal bars.
# @param ann_names_R Vector of characther strings indicating, from top on the right, the names of the annotation horizontal bars.
#' @param title Title of the plot (default "")
#' @param ... Other options are: 'only_timeline', 'reorder_annotation', 'annotate_snap_dist', 'rescaling_ann_col', 'reorder_horizline_on_timeline', 
#' 'reorder_points_on_timeline', 'timeline_proportion', 'background_height', 'ann_initial_point', 'horiz_lines_on_timeline',  'horiz_colored_areas', 'points_on_timeline',  
#' 'vertical_barriers_points', 'specific_palette_timeline', 'specific_palette_annotation',  'general_size_annPoints', 'size_points_on_timeline'
#' @details For details, please refer to the main documentation of the original campari software \url{http://campari.sourceforge.net/documentation.html}.
#'
#' @return If \code{ann_trace_ret} is active it will return the annotation trace used for the plot.
#' @seealso
#' \code{\link{mst_from_trj}}, \code{\link{gen_progindex}}, \code{\link{gen_annotation}}.
#'
#' @examples
#' adjl <- mst_from_trj(trj = matrix(rnorm(1000), nrow = 100, ncol = 10))
#' ret <- gen_progindex(adjl = adjl)
#' gen_annotation(ret_data = ret, local_cut_width = 10)
#' \dontrun{
#' sapphire_plot("REPIX_000000000001.dat")
#' }
#' 
#' @importFrom data.table fread
#' @importFrom grDevices dev.off jpeg
#' @importFrom graphics hist plot 
#' @export sapphire_plot
#' @import ggplot2


sapphire_plot <- function(sap_file = NULL, sap_table = NULL, write = F, folderPlot = "plots/", return_plot = F, local_cut = TRUE,
                          timeline = FALSE, sub_sampling_factor = NULL, ann_trace = FALSE, return_ann_trace = FALSE,
                          title = "", ...){
  
  # Analysis of extra args
  input_args <- list(...)
  avail_extra_argoments <- c('only_timeline',
                             'reorder_annotation', 
                             'annotate_snap_dist',
                             'rescaling_ann_col', # if true the numerical ann are rescaled in grey
                             'reorder_horizline_on_timeline',
                             'reorder_points_on_timeline',
                             
                             'timeline_proportion',
                             'background_height',
                             'ann_initial_point', # annotation trace initial point (between 0 and 1)
                             'localcutbasin_prop_height',
                             'basin_prop_height',
                             'horiz_lines_on_timeline', 
                             'horiz_colored_areas',
                             'points_on_timeline', 
                             'vertical_barriers_points', 
                             'specific_palette_timeline', 
                             'specific_palette_annotation',
                             
                             'general_size_annPoints',
                             'size_points_on_timeline')
                             

  if(any(!(names(input_args) %in% avail_extra_argoments))) 
    warning('There is a probable mispelling in one of the inserted variables. Please check the available extra input arguments.')
  
  # Default handling
  if(!('only_timeline' %in% names(input_args))) only_timeline <- FALSE else only_timeline <- input_args[['only_timeline']]
  if(!('reorder_annotation' %in% names(input_args))) reorder_annotation <- FALSE else reorder_annotation <- input_args[['reorder_annotation']]
  if(!('annotate_snap_dist' %in% names(input_args))) annotate_snap_dist <- FALSE  else annotate_snap_dist <- input_args[['annotate_snap_dist']]
  if(!('rescaling_ann_col' %in% names(input_args))) rescaling_ann_col <- TRUE  else rescaling_ann_col <- input_args[['rescaling_ann_col']]
  if(!('reorder_horizline_on_timeline' %in% names(input_args))) reorder_horizline_on_timeline <- FALSE else reorder_horizline_on_timeline <- input_args[['reorder_horizline_on_timeline']]
  if(!('reorder_points_on_timeline' %in% names(input_args))) reorder_points_on_timeline <- FALSE  else reorder_points_on_timeline <- input_args[['reorder_points_on_timeline']]
  
  if(!('timeline_proportion' %in% names(input_args))) timeline_proportion <- NULL else timeline_proportion <- input_args[['timeline_proportion']]
  if(!('background_height' %in% names(input_args))) background_height <- NULL else background_height <- input_args[['background_height']]
  if(!('localcutbasin_prop_height' %in% names(input_args))) localcutbasin_prop_height <- NULL else localcutbasin_prop_height <- input_args[['localcutbasin_prop_height']]
  if(!('basin_prop_height' %in% names(input_args))) basin_prop_height <- NULL else basin_prop_height <- input_args[['basin_prop_height']]
  if(!('ann_initial_point' %in% names(input_args))) ann_initial_point <- NULL else ann_initial_point <- input_args[['ann_initial_point']]
  if(!('horiz_lines_on_timeline' %in% names(input_args))) horiz_lines_on_timeline <- NULL else horiz_lines_on_timeline <- input_args[['horiz_lines_on_timeline']]
  if(!('horiz_colored_areas' %in% names(input_args))) horiz_colored_areas <- NULL else horiz_colored_areas <- input_args[['horiz_colored_areas']]
  if(!('points_on_timeline' %in% names(input_args))) points_on_timeline <- NULL else points_on_timeline <- input_args[['points_on_timeline']]
  if(!('vertical_barriers_points' %in% names(input_args))) vertical_barriers_points <- NULL else vertical_barriers_points <- input_args[['vertical_barriers_points']]
  if(!('specific_palette_timeline' %in% names(input_args))) specific_palette_timeline <- NULL else specific_palette_timeline <- input_args[['specific_palette_timeline']]
  if(!('specific_palette_annotation' %in% names(input_args))) specific_palette_annotation <- NULL else specific_palette_annotation <- input_args[['specific_palette_annotation']]
  
  if(!('general_size_annPoints' %in% names(input_args))) general_size_annPoints <- 1. else general_size_annPoints <- input_args[['general_size_annPoints']]
  if(!('size_points_on_timeline' %in% names(input_args))) size_points_on_timeline <- 0.01 else size_points_on_timeline <- input_args[['size_points_on_timeline']]

  # ============================
  #          CHECKS
  # ============================
  #
  #
  # ---------------------
  # check on title
  if(!is.character(title)) stop("title var must be a string")
  # ---------------------
  # check on output folder
  if(file.exists(folderPlot)&&write) print(paste0(folderPlot," already exixts. Posting plots there."))
  else if(write){
    dir.create(folderPlot)
    cat(paste0(folderPlot," created in order to contain new plots."))
  }
  # ---------------------
  # checking the logicals
  if(!is.logical(return_plot))
    stop('return_plot must be a logical.')
  if(!is.logical(return_ann_trace))
    stop('return_ann_trace must be a logical.')
  if(!is.logical(timeline))
    stop('timeline must be a logical.')
  if(!is.logical(local_cut))
    stop('local_cut must be a logical.')
  if(!is.logical(write))
    stop('write must be a logical.')
  if(!is.logical(annotate_snap_dist))
    stop('annotate_snap_dist must be a logical.')
  if(!is.logical(only_timeline))
    stop('only_timeline must be a logical.')
  if(!is.logical(reorder_annotation))
    stop('reorder_annotation must be a logical.')
  if(!is.logical(reorder_points_on_timeline))
    stop('reorder_points_on_timeline must be a logical.')
  if(!is.logical(reorder_horizline_on_timeline))
    stop('reorder_horizline_on_timeline must be a logical.')
  if(!is.logical(rescaling_ann_col))
    stop('rescaling_ann_col must be a logical.')

  # --------------------- 
  # putting on timeline if only timeline is on
  if(only_timeline && !timeline)
    timeline <- TRUE
  
  # ---------------------  
  # general_size_annPoints = 1 must be a numeric
  if(!is.numeric(general_size_annPoints) || length(general_size_annPoints) != 1)
    stop('general_size_annPoints must be a single numeric.')
  
  # ---------------------  
  # size_points_on_timeline = 0.01 must be a numeric
  if(!is.numeric(size_points_on_timeline) || length(size_points_on_timeline) != 1)
    stop('size_points_on_timeline must be a single numeric.')

  # ---------------------
  # timeline_proportion must be single numeric
  if(!is.null(timeline_proportion) && (!is.numeric(timeline_proportion) || length(timeline_proportion) != 1))
    stop('timeline_proportion must be a single numeric.')
  
  # ---------------------
  # loading data - sapphire table
  # the coercion to data.frame is made for retrocompatibili with non-data.table code
  if(is.null(sap_table)&&!is.null(sap_file)) pin <- data.frame(fread(sap_file)) 
  else if(is.null(sap_file)&&!is.null(sap_table)) pin <- sap_table
  else stop("Sapphire table needed in input. Check the documentation")
  dp <- dim(pin)
  Nsnap <- dp[1]
  
  # ---------------------
  # checking single numbers 
  if(!is.null(sub_sampling_factor) && (!is.numeric(sub_sampling_factor) || length(sub_sampling_factor) != 1 || (Nsnap%%sub_sampling_factor != 0))){
    warning('Wrong sub_sampling_factor insertion. It should be a number divisible by the number of snapshots. Otherwise, it will be used anyway with a truncated ending.')
    # cat('Checking a different value for sub_sampling factor (the first divisible number).')
    # divisible_sub_sampling values
    # for(i in 2:Nsnap){
    #   {if(Nsnap%%i==0) print(sum(trial_len)/i)}
    # }
  }else if(!is.null(sub_sampling_factor)){
    do_subsam_ann <- TRUE
  }else{
    do_subsan_ann <- FALSE
    sub_sampling_factor <- 1
  }
  
  # ---------------------
  # checking the horiz_lines_on_timeline
  if(!is.null(horiz_lines_on_timeline)) {
    if(!is.numeric(horiz_lines_on_timeline))
      stop('horiz_lines_on_timeline must be a numeric.')
    if(any(horiz_lines_on_timeline%%1 != 0) || any(horiz_lines_on_timeline > Nsnap) || any(horiz_lines_on_timeline < 1))
      stop('horiz_lines_on_timeline must be an integer in the trj dimensions.')
  }
  
  # ---------------------
  # checking the barriers
  if(!is.null(vertical_barriers_points)) {
    if(!is.numeric(vertical_barriers_points))
      stop('vertical_barriers_points must be a numeric.')
    if(any(vertical_barriers_points%%1 != 0) || any(vertical_barriers_points > Nsnap) || any(vertical_barriers_points < 1))
      stop('vertical_barriers_points must be an integer in the trj dimensions.')
  }
  
  # ---------------------
  # checking the horiz_colored_areas (plotted vertically)
  if(!is.null(horiz_colored_areas)){
    if((!is.numeric(horiz_colored_areas) || 
        any(horiz_colored_areas%%1 != 0) || any(horiz_colored_areas > 5) || any(horiz_colored_areas < 1)))
      stop('horiz_lines_on_timeline must be a numeric vector (integer between 1 and 5). It will color the section of horiz_lines_on_timeline.')
    if(is.null(horiz_lines_on_timeline))
      stop('Current implementation does not handle area labeling on the timeline with different steps than horizontal lines (horiz_lines_on_timeline).')
    n_h_partitions <- length(horiz_colored_areas)
    if(! length(horiz_lines_on_timeline) %in% c(n_h_partitions - 1, n_h_partitions, n_h_partitions + 1))
      stop('Number of colored areas labels must match the number of horizontal lines. ')
  } 
  
  # ---------------------
  # checking the points on the timeline
  if(!is.null(points_on_timeline)){
    if(!is.numeric(points_on_timeline))
      stop('points_on_timeline must be a numeric.')
    if(any(points_on_timeline%%1 != 0) || any(points_on_timeline > Nsnap) || any(points_on_timeline < 1))
      stop('points_on_timeline must be an integer in the trj dimensions.')
  }
  
  # ---------------------
  # checking the color palette
  if(!is.null(specific_palette_timeline) &&
     (!all(is.character(specific_palette_timeline)) || !all(nchar(specific_palette_timeline)==7) || !all(sapply(specific_palette_timeline, function(x){substring(x,1,1)}) == "#")))
    stop('specific_palette_timeline must be of the type "#b47b00", "#D9E000" (7 characters starting with #')
  
  if(!is.null(specific_palette_annotation) &&
     (!all(is.character(specific_palette_annotation)) || !all(nchar(specific_palette_annotation)==7) || !all(sapply(specific_palette_annotation, function(x){substring(x,1,1)}) == "#")))
    stop('specific_palette_annotation must be of the type "#b47b00", "#D9E000" (7 characters starting with #')
  
  # ---------------------
  # checking ann_trace input
  # ---------------------
  # logic standards
  no_trace <- FALSE
  automatic_trace_half <- FALSE
  # manual insertion std
  one_line_trace <- FALSE
  multi_line_trace <- FALSE
  numeric_trace <- FALSE
  character_trace <- FALSE
  n_partitions_trace <- FALSE
  
  # Main switcher
  if(is.logical(ann_trace) && ann_trace){
    automatic_trace_half <- TRUE 
    one_line_trace <- TRUE
  }else if(is.logical(ann_trace) && !ann_trace){
    no_trace <- TRUE
  # if not logical
  }else{
    # one line 
    if(is.null(dim(ann_trace)) || length(dim(ann_trace)) == 1){
      one_line_trace <- TRUE
      # correct length
      if(length(ann_trace) == Nsnap){
        # is numeric?
        if(is.numeric(ann_trace)){
          # if(rescaling_ann_col) ann_trace <- as.integer(ann_trace) # not needed: it can generate imprecisions before the division and floor done afterwards
          if(any(ann_trace < 0)){
            warning('Inserted negative values in the annotation trace. ', sum(ann_trace < 0), ' values have been coerced to pos.')
            ann_trace <- abs(ann_trace)
          }
          if(any(ann_trace == 0)){
            warning('Inserted 0 values (', sum(ann_trace==0), ') in the annotation trace. 1 is added to all values.')
            ann_trace <- ann_trace + 1
          }
          numeric_trace <- TRUE
        # is character?
        }else if(is.character(ann_trace)){
          character_trace <- TRUE
        }else{
          warning('The single line annotation trace must be an integer vector or a charachter vector. Annotation deactivated.')
          no_trace <- TRUE
        }
      # one line different length < n_snaps
      }else if(length(ann_trace) < Nsnap){
        # case one number -> number of partitions to do
        if(length(ann_trace) == 1){
          n_partitions_trace <- TRUE
        }else{
          warning('If you use single line annotation, you can use a whole line (length identical to the number of snapshots) 
                  or a single number with the partitions. None of those found, therefore annotation has been deactivated.')
          no_trace <- TRUE
        }
      }else{
        warning('The single line annotation trace must have length identical to the number of snapshots. Annotation deactivated.')
        no_trace <- TRUE
      }
      
    # multiple lines
    }else if(length(dim(ann_trace)) == 2){
      # warning("MULTIPLE LINES NOT WORKING FOR GGPLOT2 UPDATE - TODO")
      multi_line_trace <- TRUE
      n_lines_annotation <- dim(ann_trace)[1]
      if(is.numeric(ann_trace)){
        # if(rescaling_ann_col){
        #   for(i in 1:n_lines_annotation)
        #     ann_trace[i,] <- as.integer(ann_trace[i,])
        # }
        numeric_trace <- TRUE
        # is character?
      }else if(is.character(ann_trace)){
        character_trace <- TRUE
      }else{
        warning('The multiple line annotation trace must be an integer vector or a charachter vector. Annotation deactivated.')
        no_trace <- TRUE
      }
    # boh, deactivated
    }else{
      warning('Found strange annotation values. Please check them (annotation function deactivated)')
      no_trace <- TRUE
    }
  } 
  
  # ---------------------
  # checking the reordering of the annotation (functionality that is working only with one-line whatever) TODO extend it
  if(reorder_annotation){
    if(n_partitions_trace || automatic_trace_half)
      stop('reorder_annotation is supported only for direct (==nrow(trj)) numeric-character insertion')
  }
  
  
  # ============================
  # Main ann_trace constructor
  # ============================
  #
  if(!no_trace){
    ann_tr <- array("NA", dim = Nsnap)
    # ---------------------
    # AUTOMATIC 2 divisions: ann_trace == TRUE 
    if(automatic_trace_half){
      message("Annotation trace set to automatic. It will be considered bipartite along the timeline.")
      cat("Half random mode selected for the trace annotation. First half will be light grey")
      ann_tr[pin[,3]>=Nsnap/2 & ann_tr == "NA"]<-"gray75"
      ann_tr[pin[,3] < Nsnap/2 & ann_tr == "NA"] <- "gray30"
    }
    # ---------------------
    # AUTOMATIC n partitions: ann_trace == number of partitions
    if(n_partitions_trace){
      message("Only 10 shades of grey are possible for the 'number' option of ann_trace.
              If you inserted more than 10 it will be truncated. Please consider manual color insertion.")
      if(ann_trace>10) {
        warning('inserted more than 10 possible division of the timeline. It has been truncated to 10.')
        ann_trace = 10
      }
      ann_tr[pin[,3]<Nsnap/ann_trace] <- "gray1"
      for(i in 1:(ann_trace-1)) ann_tr[pin[,3]<Nsnap*(i+1)/ann_trace
                                       & pin[,3]>=Nsnap*(i)/ann_trace
                                       & ann_tr == "NA"] <- paste0("gray",floor(100/ann_trace)*i)
    }
    # ---------------------
    # DIRECT INSERTION (ONE LINE): ann_trace == exactly the ann_trace
    if(!automatic_trace_half && one_line_trace){
      
      # as character
      if(character_trace){
        
        # reordering
        if(reorder_annotation)
          ann_tr <- ann_trace[pin[,3]]
        else
          ann_tr <- ann_trace
        
      # as numeric
      }else if(numeric_trace){
        
        # rescaling colors (grey based)
        if(rescaling_ann_col){
          max_value_ann_trace <- max(ann_trace)
          ann_tr <- sapply(ann_trace, FUN = function(x){ paste0("gray",floor(70/max_value_ann_trace*x)) })
        }else{
          ann_tr <- ann_trace
        }
        # reordering      
        if(reorder_annotation)
          ann_tr <- ann_tr[pin[,3]]
      }
    }
    # ---------------------
    # DIRECT INSERTION (MULTI LINE):ann_trace == multi-lines annotation
    if(multi_line_trace){
      ann_tr <- array("NA", dim = dim(ann_trace))
      
      # as character
      if(character_trace){
        # reordering
        if(reorder_annotation)    
          for(i in 1:n_lines_annotation)
            ann_tr[i,] <- ann_trace[i, pin[,3]]
        else
          ann_tr <- ann_trace
        
      # as numeric
      }else if(numeric_trace){
        
        # rescaling colors (grey based)
        if(rescaling_ann_col){
          for(i in 1:n_lines_annotation){
            max_value_ann_trace <- max(ann_trace[i,])
            ann_tr[i,] <- sapply(ann_trace[i,],FUN = function(x){paste0("gray",floor(70/max_value_ann_trace*x))})
          }
        }else{
          # reordering
          if(reorder_annotation)    
            for(i in 1:n_lines_annotation)
              ann_tr[i,] <- ann_trace[i, pin[,3]]
            else
              ann_tr <- ann_trace
        }
      }
    }
  }else{
    warning("Annotation trace option not used.")
  }
  
  
  # ============================
  #         The plot
  # ============================
  #
  #
  #
  # ---------------------
  # Set range of x and y values for the plot:
  xx <- seq(from=1, by=1, to=Nsnap)[seq(1, Nsnap, sub_sampling_factor)]
  
  ymin = 0
  y_cut = -log(pin[,4]/Nsnap)
  if(any(is.na(y_cut))){ # is na check. what about the inf?
    warning('Attention: the basic annotation generated NAs during the -log(it) in number equal to ', sum(is.na(y_cut)),'. they will be set to the min (without them).')
    y_cut[is.na(y_cut)] <- min(y_cut[!is.na(y_cut)])
  }
  if(any(is.infinite(y_cut))){ # is na check. what about the inf?
    warning('Attention: the basic annotation generated Inf during the -log(it) in number equal to ', sum(is.infinite(y_cut)),'. they will be set to the max (without them).')
    y_cut[is.infinite(y_cut)] <- max(y_cut[!is.infinite(y_cut)])
  }
  if(local_cut) {
    y_local_cut = 2.5 - (1./3.)*log((pin[,10] + pin[,12]) / Nsnap)
    if(any(is.na(y_local_cut))){ # is na check. what about the inf?
      warning('Attention: the local cut annotation generated NAs during the -log(it) in number equal to ', sum(is.na(y_local_cut)),'. they will be set to the min (without them).')
      y_local_cut[is.na(y_local_cut)] <- min(y_local_cut[!is.na(y_local_cut)])
    }
    if(any(is.infinite(y_local_cut))){ # is na check. what about the inf?
      warning('Attention: the local cut annotation generated Infs during the -log(it) in number equal to ', sum(is.infinite(y_local_cut)),'. they will be set to the max (without them).')
      y_local_cut[is.infinite(y_local_cut)] <- max(y_local_cut[!is.infinite(y_local_cut)])
    }
  }
  if(local_cut) ymax_local_cut = max(y_local_cut)
  ymax_cut = max(y_cut)
  if(local_cut) ymax = max(c(ymax_cut, ymax_local_cut))
  else ymax = max(ymax_cut)
  
  # baseline of the local cut and basin cut
  if(local_cut){
    if(!is.null(localcutbasin_prop_height) && is.numeric(localcutbasin_prop_height) && length(localcutbasin_prop_height) == 1L){
      if(localcutbasin_prop_height >= 1 || localcutbasin_prop_height < 0){
        warning("Inserted initial annotation point too small or too big (between 0-1).")
        localcutbasin_prop_height <- ymax_local_cut*1/4.
      }
      localcutbasin_prop_height <- localcutbasin_prop_height*ymax_local_cut
    }else{
      localcutbasin_prop_height <- ymax_local_cut*1/4.
    }
  }
  if(!is.null(basin_prop_height) && is.numeric(basin_prop_height) && length(basin_prop_height) == 1L){
    if(basin_prop_height >= 1 || basin_prop_height < 0){
      warning("Inserted initial annotation point too small or too big (between 0-1).")
      basin_prop_height <- ymax_cut*1/4.
    }
    basin_prop_height <- basin_prop_height*ymax_cut
  }else{
    basin_prop_height <- ymax_cut*1/4.
  }
  
  if(local_cut) y_local_cut = y_local_cut - localcutbasin_prop_height
  y_cut = y_cut - basin_prop_height
  
  # ---------------------
  # initial creation of the plot
  gg <- ggplot() +
    xlab("Progress Index") + ylab("Annotation")
  # theme_bw() +
  # theme(panel.grid.minor = element_line(colour="gray80"))
  
  # ---------------------
  # Trace height from the top. This is the 0-16 parts out of ymax
  if(!is.null(background_height) && is.numeric(background_height) && length(background_height) == 1L){
    if(background_height > 1 || background_height < 0){
      warning("Inserted background height too small or too big.")
      background_height <- ymax/8.
    }
    background_height <- background_height*ymax
  }else{
    background_height <- ymax/8.
  }
  if(!is.null(ann_initial_point) && is.numeric(ann_initial_point) && length(ann_initial_point) == 1L){
    if(ann_initial_point >= 1 || ann_initial_point < 0){
      warning("Inserted initial annotation point too small or too big (between 0-1).")
      ann_init <- ymax*3/4.
    }
    ann_init <- ann_initial_point*ymax
  }else{
    ann_init <- ymax*3/4.
  }
  
  # ---------------------
  # main trace - plotting
  # one line trace
  if(!no_trace && one_line_trace && !annotate_snap_dist){
    if(is.null(specific_palette_annotation)){
      gg <- gg + geom_segment(aes(xx, 
                                  y = rep(ann_init, length(xx))[seq(1, Nsnap, sub_sampling_factor)],
                                  xend = xx, 
                                  yend = rep(ann_init + background_height, length(xx))[seq(1, Nsnap, sub_sampling_factor)]),
                              col = ann_tr[seq(1, Nsnap, sub_sampling_factor)], # color must be out if no palette is used
                              size = 0.1*general_size_annPoints)
    # specific color palette
    }else{
      if(rescaling_ann_col)
        stop('The specific insertion of a palette collides with the rescaling of the colors. Please turn it off to use the specific palette option.')
      gg <- gg + geom_segment(aes(xx, 
                                  y = rep(ann_init, length(xx))[seq(1, Nsnap, sub_sampling_factor)],
                                  xend = xx, 
                                  yend = rep(ann_init + background_height, length(xx))[seq(1, Nsnap, sub_sampling_factor)], 
                                  col = ann_tr[seq(1, Nsnap, sub_sampling_factor)]), # col is INSIDE aes
                              size = 0.1*general_size_annPoints)
      gg <- gg + scale_color_gradientn(colours = specific_palette_annotation, guide = FALSE) #  guide_legend(title = "Days")
      # gg <- gg + guides(colour=FALSE)
    }
    # multi line trace
    }else if(!no_trace && multi_line_trace && !annotate_snap_dist){
      
      # var init  
      height_one_band <- background_height/n_lines_annotation
      y_multilines <- array(NA, dim = c(n_lines_annotation, length(xx)))
      x_multilines <- rep(xx, n_lines_annotation)
      # sequential add of the height of the horizontal band
      for(i in 1:n_lines_annotation){
        y_multilines[i,] <- rep(ann_init, length(xx))[seq(1, Nsnap, sub_sampling_factor)] + height_one_band*(i-1)
        if(sub_sampling_factor!=1)
          ann_tr[i,] <- ann_tr[i,][seq(1, Nsnap, sub_sampling_factor)]
      }
      # main vectorization and plot
      if(is.null(specific_palette_annotation)){
        gg <- gg + geom_segment(aes(x = c(x_multilines),
                                y = c(t(y_multilines)),
                                xend = c(x_multilines),
                                yend = c(t(y_multilines) + height_one_band)),
                                col = c(t(ann_tr)),
                                size = 0.1*general_size_annPoints)
    # specific color palette
    }else{
      if(rescaling_ann_col)
        stop('The specific insertion of a palette collides with the rescaling of the colors. Please turn it off to use the specific palette option.')
      # here I need a loop for the specific palette
      # gg <- gg + geom_segment(aes(x = c(x_multilines),
      #                             y = c(t(y_multilines)),
      #                             xend = c(x_multilines),
      #                             yend = c(t(y_multilines) + height_one_band)),
      #                             col = c(t(ann_tr)), # WRONG must go inside the aes 
      #                         size = 0.1*general_size_annPoints)
      # for(i in 1:n_lines_annotation){
      #   gg + geom_segment(aes(x = c(x_multilines)[(1:Nsnap)*i],
      #                         y = c(t(y_multilines))[(1:Nsnap)*i],
      #                         xend = c(x_multilines)[(1:Nsnap)*i],
      #                         yend = c(t(y_multilines) + height_one_band)[(1:Nsnap)*i], 
      #                         col = c(t(ann_tr))[(1:Nsnap)*i]),
      #                     size = 0.1*general_size_annPoints)
      #   gg <- gg + scale_color_gradientn(colours = specific_palette_annotation, guide = FALSE) #  guide_legend(title = "Days")
      # }
      gg <- gg + geom_segment(aes(x = c(x_multilines),
                                  y = c(t(y_multilines)),
                                  xend = c(x_multilines),
                                  yend = c(t(y_multilines) + height_one_band),
                                  col = c(t(ann_tr))), # WRONG must go inside the aes
                              size = 0.1*general_size_annPoints)
      gg <- gg + scale_color_gradientn(colours = specific_palette_annotation, guide = FALSE) #  guide_legend(title = "Days")
    } 
  }
  
  # ---------------------
  # SETING: NO MORE THAN ONE ANN LINE AVAILABLE - annotation preparation for timeline and annotation of snap distance
  if(timeline || annotate_snap_dist){
    single_line_general_ann <- array("gray1", dim = Nsnap)
    if(one_line_trace){
      single_line_general_ann <- ann_tr
    }else if(multi_line_trace){
      single_line_general_ann <- ann_tr[1,]
      warning('timeline color kept as first line in annotation trace inserted (it is multiple lines).')
    }
  }
  # ---------------------
  # plotting the distance between snapshots (on top of everything)
  if(annotate_snap_dist){
    max_snap_dist <- max(pin[,5])
    gg <- gg + geom_segment(aes(xx,
                                y = rep(ann_init , length(xx))[seq(1, Nsnap, sub_sampling_factor)],
                                xend = xx, 
                                yend = ((pin[,5]*1.*background_height)/max_snap_dist + ann_init)[seq(1, Nsnap, sub_sampling_factor)]),
                            col = single_line_general_ann[seq(1, Nsnap, sub_sampling_factor)],
                            size = 0.1*general_size_annPoints)
  }
  
  # ---------------------
  # timeline at the bottom
  if(timeline){
    # setting timeline proportions
    if(!is.null(timeline_proportion)){
      tp <- timeline_proportion
      if(tp > 1 || tp < 0.1){
        warning('the timeline proportions was too big in comparison to the plot (it must be between 0.1 and 1). It is coerced to standard value.')
        tp <- 1.0/6
      }
    }else{
      tp <- 1.0/6
    }
    
    # only timeline
    if(only_timeline){
      
      ymax <- Nsnap
      tp <- 1.0
      
      # without palette
      if(is.null(specific_palette_timeline)){
        gg <- ggplot() + geom_point(aes(x=xx,
                                  y = (pin[,3][seq(1, Nsnap, sub_sampling_factor)])),
                                  col=single_line_general_ann[seq(1, Nsnap, sub_sampling_factor)],
                              size=size_points_on_timeline*general_size_annPoints) 
        
      # with palette
      }else{
        if(rescaling_ann_col)
          stop('The specific insertion of a palette collides with the rescaling of the colors. Please turn it off to use the specific palette option.')
        gg <- ggplot() + geom_point(aes(x=xx,
                                        y = (pin[,3][seq(1, Nsnap, sub_sampling_factor)]),
                                        col=single_line_general_ann[seq(1, Nsnap, sub_sampling_factor)]), # col INSIDE
                                    size=size_points_on_timeline*general_size_annPoints) 
        gg <- gg + scale_color_gradientn(colours = specific_palette_timeline, guide = FALSE) #  guide_legend(title = "Days")
      } 
      
      # standard add
      gg <- gg + theme_minimal() + 
        annotate("text", label = "0%", x = -Nsnap/90, y = 0, size = 3, angle = 90) +
        annotate("text", label = "100%", x = -Nsnap/90, y = Nsnap, size = 3, angle = 90) +
        xlab("Progress Index") + ylab("Temporal annotation")

    # normal timeline trace (no only)      
    }else{
      # without palette
      if(is.null(specific_palette_timeline)){
        gg <- gg + geom_point(aes(x=xx,
                                  y = ((pin[,3]*1.0*ymax*tp)/Nsnap)[seq(1, Nsnap, sub_sampling_factor)]),
                              col=single_line_general_ann[seq(1, Nsnap, sub_sampling_factor)],
                              size=size_points_on_timeline*general_size_annPoints)
      # with palette
      }else{
        gg <- gg + geom_point(aes(x=xx,
                                  y = ((pin[,3]*1.0*ymax*tp)/Nsnap)[seq(1, Nsnap, sub_sampling_factor)],
                                  col=single_line_general_ann[seq(1, Nsnap, sub_sampling_factor)]), # col INSIDE
                              size=size_points_on_timeline*general_size_annPoints)
        gg <- gg + scale_color_gradientn(colours = specific_palette_timeline, guide = FALSE) #  guide_legend(title = "Days")
      }
      # standard add
      gg <- gg +
        annotate("text", label = "0%", x = -Nsnap/90, y = 0, size = 3, angle = 90) +
        annotate("text", label = "100%", x = -Nsnap/90, y = 1.0*ymax*tp, size = 3, angle = 90)
    }
    
    # printing horizontal lines on the timeline annotation
    if(!is.null(horiz_lines_on_timeline)){
      
      # adding the initial value to have a correct plotting in color
      if(all(horiz_lines_on_timeline != 1))
        horiz_lines_on_timeline <- c(1, horiz_lines_on_timeline)
      # adding the ending value for identical reasons
      if(all(horiz_lines_on_timeline != Nsnap))
        horiz_lines_on_timeline <- c(horiz_lines_on_timeline, Nsnap)
      
      if(reorder_horizline_on_timeline)
        y_horiz_line <- ((pin[,3]*1.0*ymax*tp)/Nsnap)[horiz_lines_on_timeline]
      else
        y_horiz_line <- ((horiz_lines_on_timeline * 1.0) / Nsnap) * (ymax * tp)
      
      # plotting areas of horizontal lines
      if(!is.null(horiz_colored_areas)){
        gg<- gg + geom_segment(aes(x = 0, xend = 0, 
                                   y = y_horiz_line[1:(length(y_horiz_line)-1)], 
                                   yend = y_horiz_line[2:length(y_horiz_line)]),
                               size=2*general_size_annPoints, col = horiz_colored_areas)
      }
      
      # plotting horizontal lines
      color_horiz_line <- "black"
      gg <- gg + geom_segment(aes(x = xx[1], xend = xx[Nsnap], 
                                  y = y_horiz_line, yend = y_horiz_line),
                              size=0.4*general_size_annPoints, col = color_horiz_line)
    }
    
    # Printing points on the timeline annotation
    if(!is.null(points_on_timeline)){
      
      # adding the initial value to have a correct plotting in color (no just because we can)
      if(all(points_on_timeline != 1))
        points_on_timeline <- c(1, points_on_timeline)
      # adding the ending value for identical reasons
      if(all(points_on_timeline != Nsnap))
        points_on_timeline <- c(points_on_timeline, Nsnap)
      
      if(reorder_points_on_timeline)
        y_points <- ((pin[,3]*1.0*ymax*tp)/Nsnap)[points_on_timeline]
      else
        y_points <- ((points_on_timeline * 1.0) / Nsnap) * (ymax * tp)
      
      color_points <- "green4"
      
      gg <- gg + geom_point(aes(x=xx[points_on_timeline], y=y_points),
                            size=1.5*general_size_annPoints, col = color_points)
    }
  }else if(!is.null(horiz_lines_on_timeline)){
    stop('To use horiz_lines_on_timeline you must have active the timeline options.')
  }else if(!is.null(points_on_timeline)){
    stop('To use points_on_timeline you must have active the timeline options.')
  }
  
  # --------------------- NO MORE NECESSARY. IT IS ENOUGH TO RETURN THE PLOT AND DO IT MANUALLY
  # annotation names LEFT
  # if(!is.null(ann_names_L)&&is.character(ann_names_L)&&length(ann_names_L)==n_lines_annotation){
  #   for(i in 0:(n_lines_annotation-1))
  #     gg <- gg + annotate("text",x = -(length(xx)/24)*nchar(ann_names_L[i+1])/2,
  #                         y = ymax*((tr_init + (((i+0.5)*(16-tr_init))/n_lines_annotation))/16), label = ann_names_L[i+1])
  # }else if(!is.null(ann_names_L)){
  #   stop('The annotation names have not been inserted correctly')
  # }
  # ---------------------
  # annotation names RIGHT
  # if(!is.null(ann_names_R)&&is.character(ann_names_R)&&length(ann_names_R)==n_lines_annotation){
  #   for(i in 0:(n_lines_annotation-1))
  #     gg <- gg + annotate("text",x = length(xx)+(length(xx)/24)*nchar(ann_names_R[i+1])/2,
  #                         y = ymax*((tr_init + (((i+0.5)*(16-tr_init))/n_lines_annotation))/16), label = ann_names_R[i+1])
  # }else if(!is.null(ann_names_R)){
  #   stop('The annotation names have not been inserted correctly')
  # }
  # ---------------------
  # vertical annotation points
  # if(!is.null(vertical_barriers_points)){
  #   # plotting vertical lines
  #   color_vertical_line <- "black"
  #   gg <- gg + geom_segment(aes(x = vertical_barriers_points, xend = (vertical_barriers_points + 1), 
  #                               y = ymin + ymax/8, yend = ymax-ymax/7),
  #                           size=0.4*general_size_annPoints, col = color_vertical_line)
  # }

  # basic annotation (principal cut)
  if(!only_timeline){
    main_col <- 'darkblue'
    if((timeline && (min(y_cut) < tp*ymax)) || (!no_trace && (background_height > ymax/2.1)))
      main_col <- 'dodgerblue'
    gg <- gg + geom_line(aes(x = xx, y = y_cut), color=main_col, size=0.8) # SHALL WE KEEP THE NAs?
  }
  
  # local cut
  if(!only_timeline)
    if(local_cut) gg <- gg + 
      geom_point(mapping = aes(x=xx,y=y_local_cut), color="red3", size=0.08) 
  
  
  
  
  # -----------------------
  # title and theme
  gg <- gg + ggtitle(title) + theme_minimal()
  
  if(write) {
    jpeg_file <- 'rplot.jpg'
    jpeg_file_tm <- 0
    while(T){
      if(file.exists(paste0(folderPlot,"/",jpeg_file))){
        jpeg_file_tm <- jpeg_file_tm + 1
        jpeg_file <- paste0('rplot',jpeg_file_tm,".jpg")
      }else
        break
    }
    jpeg(paste0(folderPlot,"/",jpeg_file),width = 1200, height = 900)
    plot(gg)
    dev.off()
  }
  # returning and/or plotting
  if(return_plot){
    if(return_ann_trace) warning('No returning of ann_trace is possible if return_plot option is activated')
    invisible(gg)
  }else{
    plot(gg)
    if(return_ann_trace) invisible(ann_tr)
  }
}
