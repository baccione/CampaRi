<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--
############################################################################
# LICENSE INFO:                                                            #
############################################################################
#    This file is part of CAMPARI.                                         #
#                                                                          #
#    Version 3.0                                                           #
#                                                                          #
#    Copyright (C) 2017, The CAMPARI development team (current and former  #
#                        contributors)                                     #
#                        Andreas Vitalis, Adam Steffen, Rohit Pappu, Hoang #
#                        Tran, Albert Mao, Xiaoling Wang, Jose Pulido,     #
#                        Nicholas Lyle, Nicolas Bloechliger, Marco Bacci,  #
#                        Davide Garolini, Jiri Vymetal                     #
#                                                                          #
#    Website: http://sourceforge.net/projects/campari/                     #
#                                                                          #
#    CAMPARI is free software: you can redistribute it and/or modify       #
#    it under the terms of the GNU General Public License as published by  #
#    the Free Software Foundation, either version 3 of the License, or     #
#    (at your option) any later version.                                   #
#                                                                          #
#    CAMPARI is distributed in the hope that it will be useful,            #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of        #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         #
#    GNU General Public License for more details.                          #
#                                                                          #
#    You should have received a copy of the GNU General Public License     #
#    along with CAMPARI.  If not, see <http://www.gnu.org/licenses/>.      #
############################################################################
# AUTHORSHIP INFO:                                                         #
############################################################################
#                                                                          #
# MAIN AUTHOR:   Andreas Vitalis                                           #
# CONTRIBUTIONS: Adam Steffen, Albert Mao, Marco Bacci                     #
#                                                                          #
############################################################################
-->
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US" xml:lang="en">
<head>
    <!--
    Designed by CAMPARI Development Group
    Base template (without user's data) checked by http://validator.w3.org : "This page is valid XHTML 1.0 Transitional"
    -->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge"></meta>
    <title>CAMPARI Keywords</title>
    <link rel="stylesheet" href="style_red.css" type="text/css" media="screen"></link>
</head>
<body>
<div id="art-page-background-simple-gradient"></div>
<div id="art-main">
    <!-- Header -->
    <div class="art-Sheet2">
        
        <!-- Banner Art -->
        <div class="art-Header">
            <div class="art-Header-png"></div>
        </div>
                
        <!-- Top Navigation Bar -->
        <div class="art-nav">
            <div class="l"></div>
            <div class="r"></div>
            <ul class="art-menu">
                <li><a href="index.html"><span class="l"></span><span class="r"></span><span class="t">Home</span></a></li>
                <li><a href="documentation.html" class=" active"><span class="l"></span><span class="r"></span><span class="t">Documentation</span></a></li>
                <li><a href="references.html"><span class="l"></span><span class="r"></span><span class="t">References</span></a></li>
                <li><a href="contact.html"><span class="l"></span><span class="r"></span><span class="t">Support</span></a></li>
                <li><a href="download.html"><span class="l"></span><span class="r"></span><span class="t">Download</span></a></li>
            </ul>
        </div>
            
        <!-- Top Sub Navigation Bar -->
        <div class="nav-menu">
            <ul class="navlist">
                <li><a href="documentation.html">Overview</a></li>
                <li><a href="install.html">Install</a></li>
                <li><a href="tutorials.html">Tutorials</a></li>
                <li><a href="inputfiles.html">Inputfiles</a></li>
                <li><a href="keywords.html" class=" active">Keywords</a></li>
                <li><a href="outputfiles.html">Outputfiles</a></li>
                <li><a href="parameters.html">Parameters</a></li>
                <li><a href="development.html">Development</a></li>
                <li></li>
            </ul>
        </div>
        <!--
        <div class="subnav-menu">
            <ul class="subnavlist">
  <li><a id="TOP"></a><a href="keywords.html#parameter_files">Params</a></li>
  <li><a href="keywords.html#PRNG">RNG</a></li>
  <li><a href="keywords.html#Simulation_Setup:">Setup</a></li>
  <li><a href="keywords.html#box_settings">Box</a></li>
  <li><a href="keywords.html#integrator_controls">Integrator</a></li>
  <li><a href="keywords.html#movesetcontrols">Moveset(MC)</a></li>
  <li><a href="keywords.html#files_directories">Files</a></li>
  <li><a href="keywords.html#structure_manipulation">Structure Input</a></li>
  <li><a href="keywords.html#energy_terms">Energy</a></li>
  <li><a href="keywords.html#cutoff_settings">Cutoff</a></li>
  <li><a href="keywords.html#MPI_settings">MPI (RE)</a></li>
  <li><a href="keywords.html#output_analysis">Output</a></li>
            </ul>
        </div>
        -->
    </div>
        
    <!-- Main Page Contents -->
    <div class="art-Sheet">
        <div class="art-Sheet-bl"></div>
        <div class="art-Sheet-br"></div>
        <div class="art-Sheet-bc"></div>
        <div class="art-Sheet-cl"></div>
        <div class="art-Sheet-cr"></div>
        <div class="art-Sheet-cc"></div>
        <div class="art-Sheet-body">
            
            <div class="art-contentLayout">
                <!-- Page Contents -->
                <div class="art-content">
                <div class="art-Post">
                <div class="art-Post-body">
<div class="art-PostContent">
<br/>
<h2><a style="NoHi" id="TOP">CAMPARI Keywords</a></h2>
<hr/>
<h3>Full Keywords Index:<br/>
</h3>
<ol>
  <li><a href="keywords.html#parameter_files">Parameter File:</a></li>
  <li><a href="keywords.html#PRNG">Random Number Generator:</a></li>
  <li><a href="keywords.html#Simulation_Setup">Simulation Setup:</a></li>
  <li><a href="keywords.html#box_settings">Box Settings:</a></li>
  <li><a href="keywords.html#integrator_controls">Integrator Controls (MD/BD/LD/Minimization):</a></li>
  <li><a href="keywords.html#movesetcontrols">Move Set Controls (MC):</a></li>
  <li><a href="keywords.html#files_directories">Files and Directories:</a></li>
  <li><a href="keywords.html#structure_manipulation">Structure Input and Manipulation:</a></li>
  <li><a href="keywords.html#energy_terms">Energy Terms:</a></li>
  <li><a href="keywords.html#cutoff_settings">Cutoff Settings:</a></li>
  <li><a href="keywords.html#MPI_settings">Parallel Settings (MPI and OpenMP):</a></li>
  <li><a href="keywords.html#output_analysis">Output and Analysis:</a></li>
  <li><a href="keywords.html#netcdf_analysis">NetCDF Data Mining:</a></li>
</ol>
<br/>
<br/>
<h3><i>Preamble</i></h3>
<hr/>
The overall setup of simulations becomes more and more involved and complicated with increasing
numbers of options offered by simulation software, and CAMPARI is no exception here. Not all settings
are relevant in all circumstances (in fact, often very few are), and a complete understanding
of all keywords is clearly not required to use subsets of CAMPARI's functionality. Users should
keep the following points in mind:<br/>
<ul>
<li>Most keywords have default choices. In case of doubt, check <a href="../source/parsekey.f90">parsekey.f90</a> to locate
the variable associated with the selection, and then <a href="../source/initial.f90">initial.f90</a>,
<a href="../source/allocate.f90">allocate.f90</a>, and sometimes other files for default assignments.</li>
<li>Not all keywords can be connected and arranged such that they group nicely. The documentation here 
groups keywords into a small number of sections, some of which end up being very large. This has both 
advantages and disadvantages.</li>
<li>For navigation, it is highly recommended to a) search for terms within the page with the help of the browser
(all keywords are described within a single html-page), b) follow the links that are provided everywhere.</li>
<li>If an option is unclear, but easily testable, it is probably fastest to just try it out. If it is difficult to 
test, post a question on the SF forums.</li>
<li>The understanding of many implemented, standard methodologies requires the corresponding literature. This is why
a <a href="references.html">bibliography</a> is provided.</li> 
<li>The fastest way to learn how to run basic simulations or perform trajectory analyses is to consult the various
<a href="tutorials.html">tutorials</a>. Tutorials offer the chance to group information in a more natural workflow
compared to the documentation here. They cannot explain all options in detail, though, and it is crucial
to follow the links within the tutorial pages that point back to this and the other documentation pages.</li>
</ul>
A lot of very important and fundamental keywords are grouped in the section on 
<a href="keywords.html#Simulation_Setup:">simulation setup</a>. A few other keywords in other sections, which can be very important
and serve as hubs for finding associated keywords, but which are not necessarily quick to find are 
<a href="keywords.html#CARTINT">CARTINT</a> (choice of degrees of freedom),
<a href="keywords.html#SEQFILE">SEQFILE</a> (definition of system),
<a href="keywords.html#RANDOMIZE">RANDOMIZE</a> (initial structure generation),
<a href="keywords.html#INTERMODEL">INTERMODEL</a>, <a href="keywords.html#LREL_MC">LREL_MC</a>,
<a href="keywords.html#LREL_MD">LREL_MD</a> (all related to energetics), or
<a href="keywords.html#REMC">REMC</a> (replica exchange).
<br/>
<h4>Notes on Nomenclature and File Parsing:</h4>
All keywords used by CAMPARI are named FMCSC_* where the different possible
strings for "*" are explained below. This means that in your key-file the correct
keyword to use to specify the simulation temperature is <a href="keywords.html#TEMP">FMCSC_TEMP</a>
and not just "TEMP". There are only two exceptions to this, <i>viz.</i>
keywords <a href="keywords.html#PARAMETERS">PARAMETERS</a> and <a href="keywords.html#RANDOMSEED">RANDOMSEED</a>.
This has purely historical reasons (as does the <i>ad libitum</i> acronym "FMCSC").<br/>
The beginning of log output will print some information regarding the parsing of information in the key-file.
Superfluous lines should be masked as comments using the hash character ("#"). Lines that are neither empty
nor comments will be pointed out unless they correspond to the two exceptional keywords just mentioned or unless
they begin with the canonical prefix "FMCSC_". The keyword parser operates hierarchically meaning that
some legitimate keywords will not be processed because the required base functionality has not been enabled
(<i>e.g.</i>, thermostat settings are not processed unless a gradient-based method is in use). This is done mostly
to avoid needless warnings from popping up. All apparent keywords that have not been processed will be reported
by the parser. However, the hierarchical dependence is not enforced stringently, which means that a keyword
not reported in this list but appearing in the key-file does not automatically control a setting relevant
to the attempted calculation. It is important to realize that the list of unprocessed keywords can also include
misspelled ones. To make the detection of typos easier, it is recommended to comment or remove unused keywords
from the key-file.<br/>
Finally, most read operations of simulation settings are prone to data type mismatch errors. Supplying a character
value to a numerical setting will trigger a Fortran I/O error. The error message is usually informative yet the
relevant position in the key-file is not reported. I/O in general (also for input files) may be made less error-sensitive
in the future, but for now we apologize for this limitation.<br/>
<br/>
<br/>
<br/>
<h3><a style="NoHi" id="parameter_files">Parameter File Keywords:</a></h3>
<hr style="width: 100%; height: 2px;"></hr>
<h4><a class="NoHi" id="PARAMETERS"><b>PARAMETERS</b></a></h4>
This keyword allows the user to provide the location and name of the parameter file to be used for the
simulation. The different files offered by default (shipped with CAMPARI) are listed below:<br/>
<br/>
<span><b>Custom Parameter Sets</b>:</span>&nbsp;&nbsp;
<br/>
<br/>
<i>The parameter sets fmsmc*.prm are outdated and should be used with
utmost caution. They contain no bonded parameters except dummy
declarations and are therefore only suitable for torsional space
calculations.<br/>
In general, the Lennard-Jones parameters for ions in these files
require a cautionary note as they simply are those from Aqvist's
work. <b>They have not been specifically parameterized to work together
with the ABSINTH continuum solvation model</b> in case a full Hamiltonian is used (they
merely have been shown to reside on the "safe" side). This is a matter
of ongoing development. It may be be more appropriate to use parameters
for ions that feature harder cores and better congruence between &sigma;<sub>ii</sub>
parameters and actual contact distances.</i>
<br/>
<br/>
<a class="NoHi" id="fmsmc_prm"><u>fmsmc.prm:</u></a>
<br/>
<div style="margin-left: 40px;">
This are basic parameters fit for
simulations in the excluded volume ensemble. As Lennard-Jones
parameters, they employ Hopfinger radii with generic (and generally
small) interaction parameters. They contain a reduced charge
set derived from the OPLS brand of force fields but are thoroughly
unsuitable for simulations with "complete" Hamiltonians if just
for the fact that they lack support in many places.<br/>
</div>
<br/>
<a class="NoHi" id="fmsmc_exp_prm"><u>fmsmc_exp.prm:</u></a>
<br/>
<div style="margin-left: 40px;">
This file is identical to <a href="keywords.html#fmsmc_prm">fmsmc.prm</a> only
that pairwise LJ-terms (σ<sub>ij</sub>) for pairs involving
a polar atom and a polar hydrogen are specifically reduced. It also
lacks support for phosphorus.<br/>
</div>
<br/>
<a class="NoHi" id="fmsmc_exp3_prm"><u>fmsmc_exp3.prm:</u></a>
<br/>
<div style="margin-left: 40px;">
This file is identical to <a href="keywords.html#fmsmc_exp_prm">fmsmc_exp.prm</a> only
that LJ interaction parameters (ε<sub>ii</sub>) are raised
for polar heavy atoms (nitrogen and oxygen).
</div>
<br/>
<a class="NoHi" id="fmsmc_exp2_prm"><u>fmsmc_exp2.prm:</u></a>
<br/>
<div style="margin-left: 40px;">
This file is identical to <a href="keywords.html#fmsmc_exp3_prm">fmsmc_exp3.prm</a> only
that LJ size parameters (σ<sub>ii</sub>) for common atoms
atoms are bloated to approximately 107% which makes the parameter set
more OPLS-AA-like in terms of LJ parameters.<br/>
</div>
<br/>
<a class="NoHi" id="abs32_opls_prm"><u>abs3.2_opls.prm:</u></a>
<br/>
<div style="margin-left: 40px;">
This file combines ABSINTH LJ parameters
with the full OPLS-AA/L charges including
the <a href="references.html#ref1_7">Kaminski <i>et al.</i></a> revision. OPLS-AA/L's bonded parameters are
only retained inasmuch as they are
required to maintain quasi-rigid geometries (<i>i.e.,</i> bond length
and angle potentials, improper dihedral potentials,
and torsional potentials around bonds with hindered rotation). Comparison to the
<a href="keywords.html#OPLSAAL">reference parameter set</a> may be useful. In
addition, the free energies of solvation are
reduced by ~30 kcal/mol for ionic groups on biomolecules. This is the
file used for most published work employing
the ABSINTH implicit solvation model thus far.<br/>
</div>
<br/>
<a class="NoHi" id="abs31_opls_prm"><u>abs3.1_opls.prm:</u></a>
<br/>
<div style="margin-left: 40px;">
This file is identical to <a href="keywords.html#abs32_opls_prm">abs3.2_opls.prm</a>
only that the free energies of solvation are
not artificially lowered by ~30 kcal/mol for ionic groups on
biomolecules.<br/>
</div>
<br/>
<a class="NoHi" id="abs32_charmm_prm"><u>abs3.2_charmm.prm:</u></a>
<br/>
<div style="margin-left: 40px;">
This file combines ABSINTH LJ parameters
with the full CHARMM charges from version 22 (polypeptides)
and 27 (polynucleotides), respectively. CHARMM's bonded parameters are
only retained inasmuch as they are
required to maintain quasi-rigid geometries (<i>i.e.,</i> bond length
and angle potentials, improper dihedral potentials,
and torsional potentials around bonds with hindered rotation). Comparison to the
<a href="keywords.html#CHARMM">reference parameter set</a> may be useful. In
addition, the free energies of solvation are
reduced by ~30 kcal/mol for ionic groups on biomolecules. In
conjunction with the ABSINTH implicit solvent model, CHARMM parameters
probably offer the best combination of simplicity (small enough dipole
groups) and completeness (support for both
nucleotides and peptides as well as most terminal groups and some small
molecules).<br/>
</div>
<br/>
<a class="NoHi" id="abs31_charmm_prm"><u>abs3.1_charmm.prm:</u></a>
<br/>
<div style="margin-left: 40px;">
This file is identical to <a href="keywords.html#abs32_charmm_prm">abs3.2_charmm.prm</a>
only that the free energies of solvation are
not artificially lowered by ~30 kcal/mol for ionic groups on
biomolecules.<br/>
</div>
<br/>
<a class="NoHi" id="abs32_charmm36_prm"><u>abs3.2_charmm36.prm:</u></a>
<br/>
<div style="margin-left: 40px;">
This file is identical to <a href="keywords.html#abs32_charmm_prm">abs3.2_charmm.prm</a>
only that the parent force field is CHARMM36 and not CHARMM22/27
(see the <a href="keywords.html#CHARMM36">documentation for CHARMM36 below</a>).<br/>
</div>
<br/>
<a class="NoHi" id="abs31_charmm36_prm"><u>abs3.1_charmm36.prm:</u></a>
<br/>
<div style="margin-left: 40px;">
This file is identical to <a href="keywords.html#abs31_charmm_prm">abs3.1_charmm.prm</a>
only that the parent force field is CHARMM36 and not CHARMM22/27
(see the <a href="keywords.html#CHARMM36">documentation for CHARMM36 below</a>).<br/>
</div>
<br/>
<a class="NoHi" id="abs33_charmm36_prm"><u>abs3.3_charmm36.prm:</u></a>
<br/>
<div style="margin-left: 40px;">
This file is identical to <a href="keywords.html#abs31_charmm36_prm">abs3.1_charmm36.prm</a>
only that some Lennard-Jones and free energy of solvation parameters have been adjusted. These changes 
have thus far (2017) not been used in published works employing the ABSINTH paradigm.
As mentioned in the disclaimer above, the ion parameters in the "3.1" and "3.2" files
were somewhat of a weakness, and this is at least partially addressed here, both at the
level of reference free energies of solvation and at the level of Lennard-Jones parameters.
It may be helpful to visualize the differences between abs3.3_charmm36.prm and abs3.1_charmm36.prm
using a text editor. Nevertheless, similar to all "3.1" parameter files, buried ionic 
clusters will form readily when polymers carry charged moieties.<br/>
</div>
<br/>
<a class="NoHi" id="abs34_charmm36_prm"><u>abs3.4_charmm36.prm:</u></a>
<br/>
<div style="margin-left: 40px;">
This file is identical to <a href="keywords.html#abs33_charmm36_prm">abs3.3_charmm36.prm</a>
only that the free energies of solvation are artificially lowered by ~15 kcal/mol for ionic groups on
biomolecules. This offset is only half as large as that in <a href="keywords.html#abs32_charmm_prm">abs3.2_charmm.prm</a>,
which means that transient ionic interactions are more likely to occur. This lower offset
is possible in part because of the changes to Lennard-Jones parameters relative
to abs3.2_charmm36.prm.<br/>
</div>
<br/>
<a class="NoHi" id="abs32_a94_prm"><u>abs3.2_a94.prm:</u></a>
<br/>
<div style="margin-left: 40px;">
This file combines ABSINTH LJ parameters
with the full AMBER charge set from the '94-revision
(<a href="references.html#ref1_2">Cornell <i>et al.</i></a>). AMBER charges are generally not well-suited
to be used in conjunction with the ABSINTH paradigm since the latter is
most meaningful for small dipole groups with local neutrality. AMBER
charges are determined by a more or less
unconstrained QM-fit and spread polarization across the (arbitrary)
unit of each residue (see <a href="keywords.html#ELECMODEL">FMCSC_ELECMODEL</a>).
AMBER's
bonded parameters are only retained inasmuch as they are
required to maintain quasi-rigid geometries (<i>i.e.,</i> bond length
and angle potentials, improper dihedral potentials,
and torsional potentials around bonds with hindered rotation). Comparison to the
<a href="keywords.html#AMBER">reference parameter set</a> may be useful. In
addition, the free energies of solvation are
reduced by ~30 kcal/mol for ionic groups on biomolecules. Please refer
to the details provided for AMBER reference force fields below in
order to obtain answers concerning AMBER-specific implementation details
of force field parameters.<br/>
</div>
<br/>
<a class="NoHi" id="abs31_a94_prm"><u>abs3.1_a94.prm:</u></a>
<br/>
<div style="margin-left: 40px;">
This file is identical to <a href="keywords.html#abs32_a94_prm">abs3.2_a94.prm</a>
except that the free energies of solvation are
not artificially lowered by ~30 kcal/mol for ionic groups on
biomolecules.<br/>
</div>
<br/>
<a class="NoHi" id="abs_amber_other_prm"><u>abs3.2_a99.prm, abs3.1_a99.prm, abs3.2_a03.prm, abs3.1_a03.prm:</u></a>
<br/>
<div style="margin-left: 40px;">
These files are analogous to <a href="keywords.html#abs32_a94_prm">abs3.2_a94.prm</a>
and <a href="keywords.html#abs31_a94_prm">abs3.1_a94.prm</a> only that they incorporate AMBER
parameters of revisions '99 (<a href="references.html#ref1_1">Wang <i>et al.</i></a>, abs3.2_a99.prm,
abs3.1_a99.prm) and '03 (<a href="references.html#ref1_18">Duan <i>et al.</i></a>, abs3.2_a03.prm,
abs3.1_a03.prm), respectively.<br/>
</div>
<br/>
<a class="NoHi" id="abs32_GR53a6_prm"><u>abs3.2_GR53a6.prm:</u></a>
<br/>
<div style="margin-left: 40px;">
This file combines ABSINTH LJ parameters
with full GROMOS53a6 charges.
Note that GROMOS53 is a united atom model and that aliphatic hydrogens
(which do exist here) therefore carry no charge.
This appears inconsistent - at least compared to other force fields in
which aliphatic hydrogens almost
universally carry a small positive charge of less than 0.1<i>e</i> -
but speeds up simulations with
screened electrostatics interactions considerably. Bonded parameters
are only retained inasmuch as they are
required to maintain quasi-rigid geometries (<i>i.e.,</i> bond length
and angle potentials, improper dihedral potentials,
and torsional potentials around bonds with hindered rotation). Comparison to the
<a href="keywords.html#GROMOS">reference parameter set</a> may be useful. In
addition, the free energies of solvation are
reduced by ~30 kcal/mol for ionic groups on biomolecules.<br/>
</div>
<br/>
<a class="NoHi" id="abs31_GR53a6_prm"><u>abs3.1_GR53a6.prm:</u></a>
<br/>
<div style="margin-left: 40px;">
This file is identical to <a href="keywords.html#abs32_GR53a6_prm">abs3.2_GR53a6.prm</a>
except that the free energies of solvation are
not artificially lowered by ~30 kcal/mol for ionic groups on
biomolecules.<br/>
</div>
<br/>
<a class="NoHi" id="abs31_GROMOS_other_prm"><u>abs3.2_GR53a5.prm and abs3.1_GR53a5.prm:</u></a>
<br/>
<div style="margin-left: 40px;">
These files are analogous to <a href="keywords.html#abs32_GR53a6_prm">abs3.2_GR53a6.prm</a> and
<a href="keywords.html#abs31_GR53a6_prm">abs3.1_GR53a6.prm</a> only for
the a5-revision of the GROMOS53 charge set.<br/>
</div>
<br/>
Some recommended settings for using any of these custom parameter files
are listed below. Note
that these are also the settings required to achieve an exact match
with the ABSINTH reference.<br/>
<br/>
<tt>
<a href="keywords.html#UAMODEL">FMCSC_UAMODEL</a> 0<br/>
<a href="keywords.html#INTERMODEL">FMCSC_INTERMODEL</a> 1<br/>
<a href="keywords.html#ELECMODEL">FMCSC_ELECMODEL</a> 2<br/>
<a href="keywords.html#MODE_14">FMCSC_MODE_14</a> 1<br/>
<a href="keywords.html#FUDGE_EL_14">FMCSC_FUDGE_EL_14</a> 1.0<br/>
<a href="keywords.html#FUDGE_ST_14">FMCSC_FUDGE_ST_14</a> 1.0<br/>
<a href="keywords.html#EPSRULE">FMCSC_EPSRULE</a> 2<br/>
<a href="keywords.html#SIGRULE">FMCSC_SIGRULE</a> 1<br/>
<a href="keywords.html#SC_BONDED_B">FMCSC_SC_BONDED_B</a> 0.0<br/>
<a href="keywords.html#SC_BONDED_A">FMCSC_SC_BONDED_A</a> 0.0<br/>
<a href="keywords.html#SC_BONDED_T">FMCSC_SC_BONDED_T</a> 0.0<br/>
<a href="keywords.html#SC_BONDED_I">FMCSC_SC_BONDED_I</a> 0.0<br/>
<a href="keywords.html#SC_EXTRA">FMCSC_SC_EXTRA</a> 1.0<br/>
</tt>
<br/>
We do, however, recommend replacing <a href="keywords.html#SC_EXTRA">FMCSC_SC_EXTRA</a>
being
unity with <a href="keywords.html#SC_BONDED_T">FMCSC_SC_BONDED_T</a>
set to unity since the above files will typically
contain (unless otherwise noted) the required and "native" bonded potentials for
each parent force field.
This ensures better parameter coherence (the ones used <a
 href="keywords.html#SC_EXTRA">SC_EXTRA</a> are taken from <a href="references.html#ref1_7">OPLSAA/L</a>)
and - more importantly - control over all torsional potentials (and
bonded potentials in general) through the parameter file.
<b>If the system to be sampled contains proline residues, other flexible rings, or chemical crosslinks, it will
also be necessary to set <a href="keywords.html#SC_BONDED_A">FMCSC_SC_BONDED_A</a>, 
<a href="keywords.html#SC_BONDED_B">FMCSC_SC_BONDED_B</a>, and <a href="keywords.html#SC_BONDED_I">FMCSC_SC_BONDED_I</a>
to 1.0 to avoid obtaining nonsensical results</b>.
<br/>
<br/>
<br/>
<br/>
<span><b>Reference Parameter Sets</b>:</span>&nbsp;&nbsp;
<br/>
<br/>
<i>The parameter sets below attempt to be as complete as possible for
the biopolymer types supported by CAMPARI. In general, support for small
molecules (which often use derived parameters) will often be limited (but can easily be added
by the user). In addition, rare and generally poorly parameterized biopolymer
constructs (such as zwitterionic amino acids or free nucleosides) may have incomplete
parameter portings in particular of bonded parameters. If a perfect match of a certain parameter set paradigm cannot
be achieved (against the reference implementation), this is stated explicitly.</i>
<br/>
<br/>
<a class="NoHi" id="OPLSAAL"><u>oplsaal.prm (reference implementation: GROMACS 4.5.2)</u></a>
<br/>
<div style="margin-left: 40px;">This file provide full OPLS-AA/L
parameters, <i>i.e.,</i> it includes the <a href="references.html#ref1_7">Kaminski <i>et al.</i></a> revision
of peptide torsions and sulphur parameters. Note that GROMACS 4.5.2 was used as the reference
implementation (and not BOSS or MCPRO).<br/>
Required settings for emulating reference standard:<br/>
<br/>
<tt>
<a href="keywords.html#UAMODEL">FMCSC_UAMODEL</a> 0<br/>
<a href="keywords.html#INTERMODEL">FMCSC_INTERMODEL</a> 2<br/>
<a href="keywords.html#ELECMODEL">FMCSC_ELECMODEL</a> 1<br/>
<a href="keywords.html#MODE_14">FMCSC_MODE_14</a> 2<br/>
<a href="keywords.html#FUDGE_EL_14">FMCSC_FUDGE_EL_14</a> 0.5<br/>
<a href="keywords.html#FUDGE_ST_14">FMCSC_FUDGE_ST_14</a> 0.5<br/>
<a href="keywords.html#SC_IPP">FMCSC_SC_IPP</a> 1.0<br/>
<a href="keywords.html#SC_ATTLJ">FMCSC_SC_ATTLJ</a> 1.0<br/>
<a href="keywords.html#EPSRULE">FMCSC_EPSRULE</a> 2<br/>
<a href="keywords.html#SIGRULE">FMCSC_SIGRULE</a> 2<br/>
<a href="keywords.html#SC_POLAR">FMCSC_SC_POLAR</a> 1.0<br/>
<a href="keywords.html#SC_BONDED_B">FMCSC_SC_BONDED_B</a> 1.0<br/>
<a href="keywords.html#SC_BONDED_A">FMCSC_SC_BONDED_A</a> 1.0<br/>
<a href="keywords.html#SC_BONDED_T">FMCSC_SC_BONDED_T</a> 1.0<br/>
<a href="keywords.html#SC_BONDED_I">FMCSC_SC_BONDED_I</a> 1.0<br/>
<a href="keywords.html#SC_EXTRA">FMCSC_SC_EXTRA</a> 0.0<br/>
<a href="keywords.html#IMPROPER_CONV">FMCSC_IMPROPER_CONV</a> 2<br/>
</tt>
<br/>
</div>
<a class="NoHi" id="GROMOS"><u>GROM53a6.prm, GROM53a5.prm (reference implementation: GROMACS 4.0.5)</u></a>
<br/>
<div style="margin-left: 40px;">This file provide full
<a href="references.html#ref1_6">GROMOS53</a> parameters. Torsional
potentials for which
the same biotype is attached multiple times to an axis atom are only
approximately
supported by replacing the potential acting on just an arbitrary and
single one of those atoms in the GROMACS reference implementation with
proportionally reduced potentials acting on all of those atoms.
This should be chemically more correct but prevents exact matches of
torsional terms. The choice within GROMOS is motivated by computational
efficiency, but evaluation of torsional terms is not a time-critical 
execution component in almost all present-day simulations (and trivially parallelizable).
Moreover, cap- and terminal residues may have been adjusted to use more
consistent parameters (terminal and cap residues are generally not specifically
parameterized in GROMOS from what we can tell, in particular for polynucleotides).
GROMOS uses a rather specific interaction model and represents
aliphatic CH<sub>n</sub> moieties
in united-atom representation. Note that revisions a5 and a6 only
differ in a few partial
charge parameters.<br/>
Required settings for emulating reference standard:<br/>
<br/>
<tt>
<a href="keywords.html#UAMODEL">FMCSC_UAMODEL</a> 1<br/>
<a href="keywords.html#INTERMODEL">FMCSC_INTERMODEL</a> 3<br/>
<a href="keywords.html#ELECMODEL">FMCSC_ELECMODEL</a> 1<br/>
<a href="keywords.html#MODE_14">FMCSC_MODE_14</a> 2<br/>
<a href="keywords.html#FUDGE_EL_14">FMCSC_FUDGE_EL_14</a> 1.0<br/>
<a href="keywords.html#FUDGE_ST_14">FMCSC_FUDGE_ST_14</a> 1.0<br/>
<a href="keywords.html#SC_IPP">FMCSC_SC_IPP</a> 1.0<br/>
<a href="keywords.html#SC_ATTLJ">FMCSC_SC_ATTLJ</a> 1.0<br/>
<a href="keywords.html#EPSRULE">FMCSC_EPSRULE</a> 2<br/>
<a href="keywords.html#SIGRULE">FMCSC_SIGRULE</a> 2<br/>
<a href="keywords.html#SC_POLAR">FMCSC_SC_POLAR</a> 1.0<br/>
<a href="keywords.html#SC_BONDED_B">FMCSC_SC_BONDED_B</a> 1.0<br/>
<a href="keywords.html#SC_BONDED_A">FMCSC_SC_BONDED_A</a> 1.0<br/>
<a href="keywords.html#SC_BONDED_T">FMCSC_SC_BONDED_T</a> 1.0<br/>
<a href="keywords.html#SC_BONDED_I">FMCSC_SC_BONDED_I</a> 1.0<br/>
<a href="keywords.html#SC_EXTRA">FMCSC_SC_EXTRA</a> 0.0<br/>
</tt>
<br/>
</div>
<a class="NoHi" id="AMBER"><u>amber94.prm, amber99.prm, amber03.prm (reference implementation: AMBER port in GROMACS 4.5.2)</u></a>
<br/>
<div style="margin-left: 40px;">These files provide full AMBER parameters in
three different revisions which differ
mostly in their parameterization of torsional potentials for
polypeptides. Note that support for terminal
amino acid residues through the parameter file is marginal since AMBER's charge set is so
detailed that each atom in each
terminal residue would have to be an independent biotype. Normal
polypeptide caps are fully supported, however. To allow a more accurate emulation
of the AMBER standard for terminal polypeptide residues, the <a href="inputfiles.html#FMCSC_CPATCHFILE">
charge patch functionality</a> within CAMPARI can be used. We have tested this for
a few examples, and recovered 100% accurate matches to the AMBER standard that way. Keep in mind as well
that the parameterization of terminal polymer residues is often the "sloppiest" component in a 
biomolecular force field since their impact on overall conformational equilibria is deemed small. Note
that we did not use the actual AMBER software in the porting.<br/>
Required settings for emulating reference standard (skipping eventual charge patches):<br/>
<br/>
<tt>
<a href="keywords.html#UAMODEL">FMCSC_UAMODEL</a> 0<br/>
<a href="keywords.html#INTERMODEL">FMCSC_INTERMODEL</a> 2<br/>
<a href="keywords.html#ELECMODEL">FMCSC_ELECMODEL</a> 1<br/>
<a href="keywords.html#MODE_14">FMCSC_MODE_14</a> 2<br/>
<a href="keywords.html#FUDGE_EL_14">FMCSC_FUDGE_EL_14</a> 0.833<br/>
<a href="keywords.html#FUDGE_ST_14">FMCSC_FUDGE_ST_14</a> 0.5<br/>
<a href="keywords.html#SC_IPP">FMCSC_SC_IPP</a> 1.0<br/>
<a href="keywords.html#SC_ATTLJ">FMCSC_SC_ATTLJ</a> 1.0<br/>
<a href="keywords.html#EPSRULE">FMCSC_EPSRULE</a> 2<br/>
<a href="keywords.html#SIGRULE">FMCSC_SIGRULE</a> 1<br/>
<a href="keywords.html#SC_POLAR">FMCSC_SC_POLAR</a> 1.0<br/>
<a href="keywords.html#SC_BONDED_B">FMCSC_SC_BONDED_B</a> 1.0<br/>
<a href="keywords.html#SC_BONDED_A">FMCSC_SC_BONDED_A</a> 1.0<br/>
<a href="keywords.html#SC_BONDED_T">FMCSC_SC_BONDED_T</a> 1.0<br/>
<a href="keywords.html#SC_BONDED_I">FMCSC_SC_BONDED_I</a> 1.0<br/>
<a href="keywords.html#SC_EXTRA">FMCSC_SC_EXTRA</a> 0.0<br/>
<a href="keywords.html#IMPROPER_CONV">FMCSC_IMPROPER_CONV</a> 2<br/>
</tt>
<br/>
</div>
<a class="NoHi" id="CHARMM"><u>charmm.prm (reference implementations: CHARMM35b2 and CHARMM38b1)</u></a>
<br/>
<div style="margin-left: 40px;">
This file provides access to simulation employing the full CHARMM parameters
as provided in parameter set 27 for polypeptides and polynucleotides.
CMAP corrections for
polypeptides are supported and included. Note that &lt;ABSINTH_HOME&gt;
should be the exact same
directory specified in the localization of the Makefile (see <a
 href="install.html">installation instructions</a>). To simulate polynucleotides 
with 5'-phosphate groups using 100% authentic CHARMM parameters for the
terminal phosphate, the <a href="inputfiles.html#FMCSC_CPATCHFILE">
charge patch functionality</a> within CAMPARI has to be used. The same applies to 
the polarization on the hydrogen atoms on the NH<sub>2</sub> groups in
guanine and cytosine (this is a much smaller effect, though; also compare <a href="keywords.html#AMIDEPOL">FMCSC_AMIDEPOL</a>).
Similarly, the use of the amidated (NH2) C-terminus in polypeptides requires use of the
<a href="inputfiles.html#FMCSC_BIOTYPEPATCHFILE">biotype patch</a> and other patch functionalities.
CAMPARI's port of CHARMM parameters generally offers the most complete support for the systems supported natively
by CAMPARI, <i>e.g.</i>, for phosphorylated amino acid sidechains. <br/>
Required settings for emulating reference standard:<br/>
<br/>
<tt>
<a href="keywords.html#UAMODEL">FMCSC_UAMODEL</a> 0<br/>
<a href="keywords.html#INTERMODEL">FMCSC_INTERMODEL</a> 2<br/>
<a href="keywords.html#ELECMODEL">FMCSC_ELECMODEL</a> 1<br/>
<a href="keywords.html#MODE_14">FMCSC_MODE_14</a> 2<br/>
<a href="keywords.html#FUDGE_EL_14">FMCSC_FUDGE_EL_14</a> 1.0<br/>
<a href="keywords.html#FUDGE_ST_14">FMCSC_FUDGE_ST_14</a> 1.0<br/>
<a href="keywords.html#SC_IPP">FMCSC_SC_IPP</a> 1.0<br/>
<a href="keywords.html#SC_ATTLJ">FMCSC_SC_ATTLJ</a> 1.0<br/>
<a href="keywords.html#EPSRULE">FMCSC_EPSRULE</a> 2<br/>
<a href="keywords.html#AMIDEPOL">FMCSC_AMIDEPOL</a> 0.01 # or -0.01<br/>
<a href="keywords.html#SIGRULE">FMCSC_SIGRULE</a> 1<br/>
<a href="keywords.html#SC_POLAR">FMCSC_SC_POLAR</a> 1.0<br/>
<a href="keywords.html#SC_BONDED_B">FMCSC_SC_BONDED_B</a> 1.0<br/>
<a href="keywords.html#SC_BONDED_A">FMCSC_SC_BONDED_A</a> 1.0<br/>
<a href="keywords.html#SC_BONDED_T">FMCSC_SC_BONDED_T</a> 1.0<br/>
<a href="keywords.html#SC_BONDED_I">FMCSC_SC_BONDED_I</a> 1.0<br/>
<a href="keywords.html#SC_BONDED_M">FMCSC_SC_BONDED_M</a> 1.0<br/>
<a href="keywords.html#CMAPDIR">FMCSC_CMAPDIR</a>
&lt;ABSINTH_HOME&gt;/data<br/>
<a href="keywords.html#SC_EXTRA">FMCSC_SC_EXTRA</a> 0.0<br/>
</tt>
<br/>
</div>

<a class="NoHi" id="CHARMM36"><u>charmm36.prm (reference implementations: CHARMM38b1 and CHARMM39b1)</u></a>
<br/>
<div style="margin-left: 40px;">
This file incorporates the various revisions of the CHARMM force field contained in parameter set 36.
All other comments made for <a href="keywords.html#CHARMM">parameter set 27</a> apply here as well.<br/>
Required settings for emulating reference standard:<br/>
<br/>
<tt>
<a href="keywords.html#UAMODEL">FMCSC_UAMODEL</a> 0<br/>
<a href="keywords.html#INTERMODEL">FMCSC_INTERMODEL</a> 2<br/>
<a href="keywords.html#ELECMODEL">FMCSC_ELECMODEL</a> 1<br/>
<a href="keywords.html#MODE_14">FMCSC_MODE_14</a> 2<br/>
<a href="keywords.html#FUDGE_EL_14">FMCSC_FUDGE_EL_14</a> 1.0<br/>
<a href="keywords.html#FUDGE_ST_14">FMCSC_FUDGE_ST_14</a> 1.0<br/>
<a href="keywords.html#SC_IPP">FMCSC_SC_IPP</a> 1.0<br/>
<a href="keywords.html#SC_ATTLJ">FMCSC_SC_ATTLJ</a> 1.0<br/>
<a href="keywords.html#EPSRULE">FMCSC_EPSRULE</a> 2<br/>
<a href="keywords.html#AMIDEPOL">FMCSC_AMIDEPOL</a> 0.01 # or -0.01<br/>
<a href="keywords.html#SIGRULE">FMCSC_SIGRULE</a> 1<br/>
<a href="keywords.html#SC_POLAR">FMCSC_SC_POLAR</a> 1.0<br/>
<a href="keywords.html#SC_BONDED_B">FMCSC_SC_BONDED_B</a> 1.0<br/>
<a href="keywords.html#SC_BONDED_A">FMCSC_SC_BONDED_A</a> 1.0<br/>
<a href="keywords.html#SC_BONDED_T">FMCSC_SC_BONDED_T</a> 1.0<br/>
<a href="keywords.html#SC_BONDED_I">FMCSC_SC_BONDED_I</a> 1.0<br/>
<a href="keywords.html#SC_BONDED_M">FMCSC_SC_BONDED_M</a> 1.0<br/>
<a href="keywords.html#CMAPDIR">FMCSC_CMAPDIR</a>
&lt;ABSINTH_HOME&gt;/data<br/>
<a href="keywords.html#SC_EXTRA">FMCSC_SC_EXTRA</a> 0.0<br/>
</tt>
<br/>
</div>


In order to create a new parameter file, it is advisable to start
with "template.prm". For details on the paradigms underlying the
construction of a parameter file consult <a href="parameters.html#PARAMETERS">the detailed documentation on this topic</a>.<br/>
<br/>
<br/>
<br/>
<h3><a class="NoHi" id="PRNG">Random Number Generator Keywords:</a></h3>
<hr style="width: 100%; height: 2px;"></hr> (<a href="keywords.html#TOP">back to top</a>)<br/>
<h4><a class="NoHi" id="RANDOMSEED"><b>RANDOMSEED</b></a></h4>
This keyword allows the user to provide a specific seed for the
PRNG. This is usually relevant in two contexts:<br/>
<ol type="i">
  <li>Reproducibility: <br/>
Eliminate mismatches between
different versions of the program (for example) by doing the
stringent test that the results must be exactly the same if the PRNG is
seeded with the same seed. Such tests may occasionally be hampered by a lack of precision
in any input files and in particular by different compiler/architecture optimization levels.<br/>
  </li>
  <li>
Timing:<br/>
Eliminate identical calculations if jobs are submitted simultaneously. Normally the PRNG
uses a seed derived from from system time, which can be identical if jobs
are submitted exactly in parallel. Avoiding this behavior by specifying different values for RANDOMSEED
is only adequate if the jobs are indeed 
submitted as individual, serial jobs. Conversely, in intrinsically
<a href="keywords.html#MPI_settings">parallel applications (MPI)</a>,
CAMPARI uses the node number to vary the seed across different nodes <b>unless</b> RANDOMSEED is specified.
This means that a provided value for RANDOMSEED will homogenize the PRNG across all replicas
which is almost always undesirable.</li>
</ol>
(<a href="references.html#ref3_1">references</a>)<br/>
<br/>
<br/>
<br/>
<h3><a class="NoHi" id="Simulation_Setup">Simulation Setup:</a></h3>
<hr style="width: 100%; height: 2px;"></hr> (<a href="keywords.html#TOP">back to top</a>)<br/>
<h4><a class="NoHi" id="UAMODEL"><b>UAMODEL</b></a></h4>
This keyword is a simple but very important switch. It allows the user
to control whether non-polar hydrogens are going to be part of the system's
topology or not. In particular in earlier simulation work, it was a 
common and convenient trick to improve simulation efficiency by
uniting all atoms of a methyl or methylene group into a single, coarse-grained
"united atom". Different force fields used or use different varieties of this trick.
In the <a href="references.html#ref1_6">GROMOS line of force fields</a>, for instance, all aliphatic hydrogen atoms 
are merged into the carbon atoms they are bonded to. Conversely, the CHARMM19
protein force field in addition eliminates non-polar hydrogens bound to 
sp<sup>2</sup>-hybridized carbon atoms in aromatic rings.<br/>
Unlike other simulation software, CAMPARI maintains a complete internal 
"knowledge" of biomolecular topology of those systems it allows the user
to build from scratch. Therefore, choosing between all- or united-atom models
is not simply a matter of parameter files (although it is possible to create
inefficient united-atom variants of force fields by disabling all interaction
parameters pertaining to the required hydrogens). Instead, the software itself
requires knowledge of this choice.<br/>
Choices are:<br/>
<ol start='0'>
<li>Use an all-atom model for those molecules represented explicitly.</li>
<li>Use a united-atom model according to GROMOS convention, <i>i.e.,</i> all aliphatic hydrogen
atoms are merged into the carbon atoms they are linked to (this does include terminal aldehyde hydrogen atoms).</li>
<li>Use a united-atom model according to CHARMM19 convention, <i>i.e.,</i> all aliphatic and all aromatic hydrogens
bound to carbon atoms are merged into the latter.</li>
</ol>
Currently, the only natively supported united-atom force field in CAMPARI is
GROMOS53a5/6 (see <a href="keywords.html#GROMOS">above</a>). One technical
caveat is that using the latter two options may require setting <a href="keywords.html#UNSAFE">UNSAFE</a> to 1.
This is because the atom type parsing reads in atom valences which are altered and - more importantly -
may vary between atoms that for simplicity were assigned the same type.<br/>
Outside of simulations using the GROMOS force field, this keyword is most useful when using CAMPARI
to analyze trajectory data generated by other software using such a united-atom force field.
Such a run would not tolerate atom number mismatches between the internal representation
of the system and what is found in the binary trajectory files (mismatches are
acceptable only if the input format is pdb &rarr; see <a href="keywords.html#structure_manipulation">below</a>).
Note that this keyword has no impact on systems involving residues not supported natively
by CAMPARI (&rarr; <a href="inputfiles.html#FMCSC_SEQFILE">sequence input</a> and
<a href="keywords.html#PDB_TEMPLATE">PDB input</a>).<br/>
<h4><a class="NoHi" id="PDBANALYZE"><b>PDBANALYZE</b></a></h4>
This keyword is a simple but very important logical. It specifies
whether the proposed simulation is a trajectory analysis run: in these, a
<a href="keywords.html#PDBFILE">pdb-</a> (or <a href="keywords.html#XTCFILE">xtc-</a>, <a href="keywords.html#DCDFILE">dcd-</a>,
<a href="keywords.html#NETCDFFILE">NetCDF</a>)-trajectory is read from file and analyzed with CAMPARI's
internal analysis routines. The desired format is chosen with keyword
<a href="keywords.html#PDB_FORMAT">PDB_FORMAT</a>. All outputs and parameters are completely
analogous to normal calculations. Essentially, the
snapshot read-in replaces the sampling step. This means that low
analysis frequencies will be desirable, since usually the number of snapshots
will be relatively small compared to the number of simulation steps in a typical simulation. Note that
- in particular for large systems (&gt; 10<sup>4</sup> atoms) - the
analysis run may be slowed down by:
<ol>
  <li>Certain time-consuming analyses scale poorly with the number of
atoms (solution structure analyses, see for example <a
 href="keywords.html#PCCALC">PCCALC</a> or <a
 href="keywords.html#CLUSTERCALC">CLUSTERCALC</a>).</li>
  <li>At each step, the global system energy is calculated using -
depending on the setting for <a href="keywords.html#DYNAMICS">DYNAMICS</a>
-
either CAMPARI's energy (MC) or force (MD/LD) routines and making
little to no simplifying assumptions. To ensure decent speed, this may require setting the
system Hamiltonian to zero (see <a href="keywords.html#energy_terms">below</a>)
and/or using an efficient cutoff / neighbor-list routine (see <a
 href="keywords.html#CUTOFFMODE">CUTOFFMODE</a>).</li>
  <li>Very large files in particular in pdb-format may cause memory
shortages which slow down the machine entirely. In general binary 
trajectory files in conjunction with an optional <a href="keywords.html#PDB_TEMPLATE">template
file</a> are the preferred and much faster way of performing analysis runs.</li>
</ol>
Note that it is important in analysis runs to set <a
 href="keywords.html#NRSTEPS">NRSTEPS</a> and <a
 href="keywords.html#EQUIL">EQUIL</a> to the required values (the
number of steps generally becomes the number
of snapshots in the trajectory file) and that a fair amount of
CAMPARI's simulation options are (naturally) not
supported in such a run. Some sanity checks specific to pdb trajectories can be disabled
with the help of keyword <a href="keywords.html#UNSAFE">UNSAFE</a>. The analysis can also be restricted 
to a subset of simulation snapshots by using a <a href="keywords.html#FRAMESFILE">frames file</a>, which can
carry analysis weights per snapshot. This is commonly necessary when trying to reweight simulation 
data to different conditions or Hamiltonians. Frames files can also be used to extract, reorder,
or duplicate parts of trajectories. Both weighted analyses and analyses performed on arbitrary subsets of the input data carry some
intricacies with the built-in analysis routines, which are described <a href="keywords.html#FRAMESFILE">elsewhere</a>.
<br/>
When using an MPI executable of CAMPARI in parallel, it is also possible to perform
trajectory analysis across many processors.
This uses the <a href="keywords.html#REMC">replica exchange setup</a> and is described in detail elsewhere.
The four primary applications are simultaneous analyses of several trajectories, the 
<a href="keywords.html#TRACEFILE">unscrambling of replica exchange trajectories</a> that are normally output continuously for 
a given condition, the <i>post facto</i> computation of <a href="keywords.html#REOLCALC">energetic overlap distributions</a>,
and the evaluation of the <a href="keywords.html#MPIAVG">PIGS heuristic for analysis purposes</a>.
Specific analysis routines (such as <a href="keywords.html#DSSPCALC">DSSP analysis</a> may be 
restricted to specific types of residues, and this may limit the utility of these routines
for entities that are not natively supported by CAMPARI (see <a href="inputfiles.html#FMCSC_SEQFILE">sequence input</a>).
In general, analysis runs on systems featuring unsupported residues should be relatively straightforward. This
is true at least as long no energetic analyses are required (which naturally entails the complex
issue of parameterization).<br/>
Analysis runs can also utilize the <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization of CAMPARI</a>. 
As is described elsewhere, this decomposes the workload for many time-intensive tasks that CAMPARI can perform.
For <a href="keywords.html#output_analysis">analysis functionalities</a>, the load per step for an individual analysis is
often so low that is not effective to let multiple threads operate on it. This is why most simple analysis functions are 
not parallelized <i>per se</i> but simply performed simultaneously. This is obviously ineffective if only a single 
such analysis is needed. Currently, the only exceptions are certain analyses related to <a href="keywords.html#CCOLLECT">structural clustering</a>
and the calculation of <a href="keywords.html#EMCALC">spatial density maps</a>.
Important analyses that can be time-consuming but are not parallelized <i>per se</i> are those controlled by
<a href="keywords.html#CONTACTCALC">CONTACTCALC</a>, <a href="keywords.html#DSSPCALC">DSSPCALC</a>, 
<a href="keywords.html#RHCALC">RHCALC</a>, <a href="keywords.html#SAVCALC">SAVCALC</a>, and <a href="keywords.html#DIFFRCALC">DIFFRCALC</a>.
As a general comment, tt should be noted that CAMPARI will always spend some of its execution time dealing with coordinate
operations. Depending on <a href="keywords.html#energy_terms">the chosen settings</a>, there may also be a large
contribution from evaluating energies at every step. While the former is never parallel in analysis runs and
constitutes a hidden performance bottleneck (just as file I/O does), the latter takes full advantage of the parallelization offered
in regular simulations. These considerations should be kept in mind when deciding whether to use the OpenMP code in
an analysis setting. Generally, it will of course be more efficient to parallelize in snapshot space by letting
the MPI version operate on separate pieces of a longer trajectory. As is generally the case, the MPI and OpenMP frameworks
can also be used simultaneously in analysis runs with the standard hierarchy (each <a href="keywords.html#REPLICAS">MPI process</a>
maintains a separate copy of the system, and the processing of each copy can be sped up by using more than one
<a href="keywords.html#NRTHREADS">OpenMP thread</a> per MPI process).
<br/>
<h4><a class="NoHi" id="NRSTEPS"><b>NRSTEPS</b></a></h4>
This keyword sets the total number of simulation steps including
<a href="keywords.html#EQUIL">equilibration</a>. A step is either a single propagation
event by the <a href="keywords.html#DYNAMICS">chosen propagator</a> or the
advancement to the next trajectory snapshot in a <a href="keywords.html#PDBANALYZE">trajectory analysis run</a>.
Currently, the only keyword to manipulate the user choice for NRSTEPS is 
a <a href="keywords.html#FRAMESFILE">file with selected input frames</a> in an analysis run. This can have
consequences as other keywords, for example <a href="keywords.html#DISABLE_ANALYSIS">DISABLE_ANALYSIS</a> rely
on correct values for NRSTEPS. The default is 100000, and this keyword should always be specified.<br/>
<h4><a class="NoHi" id="EQUIL"><b>EQUIL</b></a></h4>
This keyword specifies the total number of equilibration steps. This
implies that no analysis is performed
as long as the current step number does not exceed this value. Note
that this also means that
no structural output (trajectory) is produced. Conversely, certain
necessary diagnostics are provided
irrespective of equilibration (see for example <a
 href="keywords.html#ENOUT">ENOUT</a> or <a href="keywords.html#ACCOUT">ACCOUT</a>).
The default differs: it is 10000 for a simulation run and 0 for an analysis run
(see <a href="keywords.html#PDBANALYZE">PDBANALYZE</a>).<br/>
<h4><a class="NoHi" id="TEMP"><b>TEMP</b></a></h4>
This keyword sets the absolute (target) temperature in K (default of 298K).<br/>
<!--<h4><a class="NoHi" id="PRESSURE"><b>PRESSURE</b></a></h4>
This keyword allows the user to specify the absolute (target) pressure
in bar (not yet in use).<br/>-->
<h4><a class="NoHi" id="ENSEMBLE"><b>ENSEMBLE</b></a></h4>
This crucial keyword determines which ensemble to simulate the system
in. The options available are limited in that they depend strongly on
the
type of sampler (<i>i.e.</i>, there is no NVE (microcanonical)
ensemble if sampling is done via Monte Carlo → <a
 href="keywords.html#DYNAMICS">DYNAMICS</a>).<br/>
<br/>
The options are as follows:<br/>
&nbsp;&nbsp; 1) NVT (Constant Particle Number, Constant Volume,
Constant
Temperature): <br/>
<div style="margin-left: 40px;">
Always available, this is the
canonical ensemble and currently the only option available
for pure Monte Carlo runs.<br/>
</div>
&nbsp;&nbsp; 2) NVE (Constant Particle Number, Constant Volume,
Constant
Energy): <br/>
<div style="margin-left: 40px;">
The microcanonical ensemble
(adiabatic conditions) is only supported (and possible) for
non-dissipative, <i>i.e.</i>, Newtonian dynamics (see option 2 in <a
 href="keywords.html#DYNAMICS">DYNAMICS</a>).<br/>
</div>
&nbsp;&nbsp; 5) μ<sub>i</sub>VT (Constant Chemical Potential(s),
Constant Volume, Constant
Temperature): <br/>
<div style="margin-left: 40px;">
This requests the grand canonical ensemble where the number of
particles in the system is allowed to fluctuate. Subscript <i>i</i>
indicates that not all particle types may be subject to number
fluctuation (typical for example in the simulation of macromolecules
and a (co-)solvent atmosphere for
which only the small molecule would be treated in "grand" fashion. This
implies that technically incorrect hybrid ensembles are populated
(sometimes referred to as "partially grand" ensembles). The rigorous
grand canonical ensemble would require all particle types to be
permitted to fluctuate in number. Such partially grand ensembles are
not to be confused with the "semigrand" ensemble (see below).
Technically, the GC ensemble is realized in CAMPARI by allowing
molecules to transfer between a real and a shadow existence, the latter
also serving as the reference state. The discreteness of transitions
between shadow and real existence implies that currently the grand ensemble
is only available in <a href="keywords.html#DYNAMICS">pure Monte Carlo simulations</a>.
Note that currently the reference
state is modeled in the infinite dilution limit (there are no
intermolecular interactions). This is consistent with the default
implementation choice (&rarr; <a href="keywords.html#GRANDMODE">GRANDMODE</a>), in
which the bath communicates with the system via an expected bulk concentration
and an excess chemical potential correcting for the interactions arising
from that finite bulk concentration.<br/>
</div>
&nbsp;&nbsp; 6) Δμ<sub>i</sub>N<sub>t</sub>VT (Constant Chemical
Potential Difference(s), Constant Total Particle Number, Constant
Volume, Constant
Temperature): <br/>
<div style="margin-left: 40px;">
This requests the semigrand ensemble as originally formulated by <a href="references.html#ref2_10">Kofke
and Glandt (1988)</a>, in which particle types are allowed to fluctuate in
number under the constraint that the total particle number (N<sub>t</sub>)
remains constant. Just like for the μ<sub>i</sub>VT-ensemble, CAMPARI
allows the definition of partial semigrand ensembles in which - for
example - a bath of water and methanol solvating a macromolecule is
subjected to moves attempting to transmute methanol into water or vice
versa. Note that the amount of real-world applications for such an
ensemble to be appropriate is very small. Technically, the constraints
to keep N<sub>t</sub> fixed may improve acceptance rates in dense fluid
mixtures. For both options (5 and 6), please refer to the documentation
for the particle fluctuation file, specified using <a
 href="inputfiles.html#PARTICLEFLUCFILE">PARTICLEFLUCFILE</a>, for
details. Note that the sanity of results obtained with any partial
grand or semigrand ensemble must be investigated with utmost care.<br/>
<br/>
</div>
&nbsp;To be added in the future:<br/>
&nbsp;&nbsp; 3) NPT (Constant Particle Number, Constant Pressure,
Constant
Temperature): <br/>
<div style="margin-left: 40px;">
May eventually be made available for MC and Newtonian MD runs<br/>
</div>
&nbsp;&nbsp; 4) NPE (Constant Particle Number, Constant Pressure,
Constant
Enthalpy): <br/>
<div style="margin-left: 40px;">
May eventually be made available for Newtonian MD runs<br/>
</div>
&nbsp;&nbsp;
<br/>
Note to developers: there is rudimentary support for NPT and
NPE ensembles in CAMPARI
right now but those branches are completely disabled.<br/>
<h4><a class="NoHi" id="GRANDREPORT"><b>GRANDREPORT</b></a></h4>
If an <a href="keywords.html#ENSEMBLE">ensemble</a> is chosen that
allows particle number fluctuations, this keyword acts as a simple
logical whether or not to write out a summary of the grand-canonical
setup,
<i>i.e.</i>, which particle types are allowed to fluctuate in numbers,
what the initial numbers (bulk concentrations) are, and what (excess) chemical
potentials are associated with those.<br/>
<h4><a class="NoHi" id="GRANDMODE"><b>GRANDMODE</b></a></h4>
If an <a href="keywords.html#ENSEMBLE">ensemble</a> is chosen that
allows particle number fluctuations, this keyword acts to choose between two 
different implementation modes. In the first (choice 1),
<a href="inputfiles.html#FMCSC_PARTICLEFLUCFILE">file input</a> is used to 
provide CAMPARI with the initial numbers and absolute chemical potentials
of fluctuating particle types. This is generally inconvenient for cases with 
realistic interaction potentials and/or multiple fluctuating particle
types that require coupled chemical potentials (such as individual ionic species).
The bulk concentrations are set implicitly by the chemical potentials. This formulation
involves the "thermal volume" of particles meaning that a monoatomic ideal gas
will require a mass-dependent chemical potential. In the second option (choice 2, which is the default),
the same <a href="inputfiles.html#FMCSC_PARTICLEFLUCFILE">file input</a> is used to
set the bulk concentration explicitly (based on the initial particle number provided),
and the chemical potentials listed are merely the excess terms. This formulation involves
no mass-dependent terms, is numerically more stable (accuracy of exponentials), and provides
an easy reference limit for dilute solutions (zero excess chemical potential).<br/>
To illustrate the difference in implementation, consider the additional contribution
to the acceptance probability (term c<sub>b</sub> in description of keyword
<a href="keywords.html#MC_ACCEPT">MC_ACCEPT</a>) of a <a href="keywords.html#PARTICLEFLUCFREQ">particle insertion attempt</a>:<br/>
Mode 1:<br/>
c<sub>b</sub> = e<sup>&beta;&mu;<sub>ideal</sub></sup> &#183; e<sup>&beta;&mu;<sub>excess</sub></sup> &#183; V&#183; (N+1)<sup>-1</sup>&#183; &zeta;<sup>-1</sup><br/>
Here, V is the system volume, N is the current number of particles of the type to be inserted,
&mu;<sub>ideal</sub> and &mu;<sub>excess</sub> are the components of the chemical potential,
and &zeta; is the aforementioned thermal volume.<br/>
Mode 2:<br/>
c<sub>b</sub> = e<sup>&beta;&mu;<sub>excess</sub></sup> &#183; &lt;N&gt; &#183; (N+1)<sup>-1</sup><br/>
This equation contains the expected bulk concentration as &lt;N&gt;.<br/>
While numerically the two cases can be made equivalent, the latter contains
a self-consistency check by being able to compare the measured &lt;N&gt; to the assumed
 &lt;N&gt; given the chosen &mu;<sub>excess</sub>. In the former, the assumed
 &lt;N&gt; is unknown, because the partitioning between &mu;<sub>ideal</sub> and &mu;<sub>excess</sub>
is not explicit. For a single-component system (or a system with multiple independent components),
the measured &lt;N&gt; can be used to derive the &mu;<sub>excess</sub> that the simulation essentially
corresponded to. With dependent components, however, this becomes very difficult to adjust.
For general calibration strategies of excess chemical potentials and background, see
<a href="references.html#ref2_9">references</a>.<br/>
<h4><a class="NoHi" id="DYNAMICS"><b>DYNAMICS</b></a></h4>
This is one of the core keywords and specifies how to propagate (sample) the system, <i>i.e.</i>, how to obtain
a new conformation of the system given the current one. The system configuration usually involves both momenta and coordinates unless
the sampler is momentum-free (<i>e.g.</i>, Monte Carlo). Most propagation schemes
are able to take advantage of the <a href="keywords.html#NRTHREADS">shared memory parallelization</a>, but it
is important to benchmark this routinely as the scalabilities differ. For example, the work load available 
for parallelization in an incremental energy evaluation in Monte Carlo is usually much smaller than that in a full force
evaluation in dynamics. Options are as follows:<br/>
&nbsp;&nbsp; 1) Pure Monte Carlo sampling (see keyword <a href="keywords.html#MC_ACCEPT">MC_ACCEPT</a> and section on <a
 href="keywords.html#movesetcontrols">Monte Carlo move sets</a>).<br/>
&nbsp;&nbsp; 2) Molecular Dynamics: <br/>
<div style="margin-left: 40px;">Integration of Newton's equations
of motion either in internal or Cartesian coordinate space (see <a href="keywords.html#CARTINT">CARTINT</a>). This is fully
supported. The internal coordinate space formulation is based upon a <a href="references.html#ref5_16">published algorithm</a>. More details are found in
the documentation to keywords <a href="keywords.html#TMD_INTEGRATOR">TMD_INTEGRATOR</a> and
<a href="keywords.html#TMD_UNKMODE">TMD_UNKMODE</a>.<br/>
<br/>
</div>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A simplified summary of the internal coordinate space variant is as follows: <br/>
<ol style="list-style-type: lower-roman; margin-left: 40px;">
  <li>Dynamics are performed on internal degrees of freedom
which are assumed to be independent (rigid body translation, rotation around the Cardinal x, y, and z axes
of the laboratory frame (static) centered at the center of mass of each molecule, torsional degrees of freedom).</li>
  <li>Dynamics for polymers vary along the chain (faster at the termini) as they should, but this does not happen in
any fashion proven to comply rigorously with a specific dynamics. By altering the 
<a href="keywords.html#ALIGN">chain alignment mode</a>, more exotic dynamics can be produced. This is because
the building directions of any polymer chains represent an arbitrary choice in the method.</li>
  <li>By assuming a diagonal mass (inertia) matrix (<i>viz.</i>, a block of the mass metric tensor), applicability of simple integrators is a given.
In the absence of interaction-based forces, the goal is to preserve rotational kinetic energy (but not angular momentum)
by considering the effective masses associated with various rotational degrees of freedom as time-dependent variables in a
discrete integration scheme. This treatment is intrinsically consistent, and agreement with data obtained from
Monte Carlo simulations has been shown (<a href="references.html#ref5_16">for select cases</a>).
CAMPARI provides a simple diagnostic of the impact of assuming a diagonal
mass matrix by printing kinetic energies in both internal and Cartesian coordinates to log-output.</li>
  <li>Because the algorithm does not produce dynamics that obey Gauss' principle of least constraint or conserve angular momentum,
integrator stability can be inferior to that for a case of identical constraints realized as holonomic
constraints in Cartesian molecular dynamics. This effect cannot always be quantified since the
holonomic constraints implied by the internal coordinate space treatment often become too highly coupled
for linear solvers to converge (&rarr; <a href="keywords.html#SHAKEMETHOD">SHAKEMETHOD</a>). Select cases with quickly varying masses
highlight the effect, and the most significant example are probably rigid-body simulations of water
(water has tiny rotational inertia and is a prototypical test case for rigid-body integrators). 
Quantification of relative integrator stabilities for such a case can be performed.</li>
<li>Subtle equipartition artifacts (<i>i.e.</i>, some individual or collective degrees of freedom heating
up at the expense of others because they are either more susceptible to integration error or weakly 
coupled to the rest of the system) can always occur. Effects differ between internal coordinate and Cartesian treatments.
This is because dihedral angles will generally have a rather different level of energetic coupling and 
integration stability than the positional coordinates of an atom embedded in a polyatomic molecule.</li>
</ol>
<div style="margin-left: 40px;">Conversely, the integration of Newton's equations of motion for the <a href="keywords.html#CARTINT">Cartesian coordinates</a> of all atoms
represents the more canonical approach to molecular dynamics. These
algorithms are conceptually much simpler, and users are referred to standard literature on the topic. This is primarily because the mass
matrix is diagonal leading to independent equations.
The simplicity holds primarily for unconstrained simulations in the <a href="keywords.html#ENSEMBLE">microcanonical ensemble</a>.
In practice, additional procedures are needed in almost all cases, for example the enforcement of holonomic constraints through appropriate <a
 href="keywords.html#SHAKEMETHOD">algorithms</a> such
as SHAKE or LINCS. Most three-point water models are explicitly calibrated as rigid models, and it is therefore
necessary to maintain water geometry as a set of holonomic constraints throughout
a Cartesian dynamics simulation. Similarly, the desired switch to the canonical ensemble requires the action of 
a <a href="keywords.html#TSTAT">thermostat</a>. CAMPARI always uses the simple leapfrog integrator in Cartesian
molecular dynamics, which has excellent energy conservation properties due to error cancellation. This does not mean
that it is free of discretization errors, which increase with increasing <a href="keywords.html#TIMESTEP">time step</a>.
The latter statement is of course true for any numerical integration of equations of motion.<br/>
</div>
&nbsp;&nbsp; 3) Langevin Dynamics: <br/>
<div style="margin-left: 40px;">Integrations of Langevin equation
of
motion. This is supported via the impulse integrator due to Izaguirre
and Skeel (<a href="references.html#ref5_7">reference</a>). With respect
to the torsional dynamics implementation, the same caveats apply as for
Newtonian dynamics. There is an additional limitation in that the only implementation supported
currently is an approximate scheme (corresponding to keywords
<a href="keywords.html#TMD_INTEGRATOR">TMD_INTEGRATOR</a> being 2 and
<a href="keywords.html#TMD_INT2UP">TMD_INT2UP</a> being 0). This is because the 
structure of the impulse integrator is more complex, thus allowing a straightforward
extension to our torsional dynamics only for the simplest case (research in progress). It 
also means that the <a href="keywords.html#NRTHREADS">shared memory parallelization</a> will not (yet) work
with this choice.<br/>
Note that all LD simulations work in the fluctuation-dissipation limit,
which means that all degrees of freedom are automatically coupled to a
heat bath, and which assumes an underlying continuum providing frequent collisions
as the source of the stochastic term as well as the frictional damping. In addition,
note that hydrodynamic interactions are neglected and that
currently there is only a single, uniform frictional parameter for all
degrees of freedom (see <a href="keywords.html#FRICTION">FRICTION</a>). The
latter is a major and non-obvious assumption in <a href="keywords.html#CARTINT">internal coordinate spaces</a>
featuring polymers with flexible dihedral angles. This is because it is
not clear what the frictional drag incurred by rotations around molecular bonds is and
what the results of ignoring communication between these drag effects are.<br/>
</div>
&nbsp;&nbsp; 5) Mixed Monte Carlo and Newtonian (Molecular) Dynamics: <br/>
<div style="margin-left: 40px;">This hybrid method mixes MC with MD sampling
and assumes consistency of ensembles at all times. Since MC sampling only
supports the canonical ensemble at the moment, this means that Newtonian MD has
to be performed with a <a href="keywords.html#TSTAT">thermostat</a> preserving the correct ensemble, <i>e.g.</i>,
the Andersen or Bussi <i>et al.</i> schemes. 
Then, the entire trajectory should be treatable as a Markov chain and
analysis is performed as if the sampling engine were one of the two.<br/>
A potential caveat lies in velocity autocorrelation. The method is
implemented such that segments of MC sampling alternate with MD segments. Upon switching from MC to
MD, new velocities are assigned from the proper Boltzmann distribution. This may introduce
some amount of noise. Aside from this particular concern, all independent concerns about both Monte Carlo and
dynamics-based methods apply. It is up to the user to ensure that either sampler yields the required
ensemble rigorously.<br/>
A particular concern lies with the selection of degrees of freedom. In general,
it will be highly desirable for the set of sampled degrees of freedom to be exactly identical
between the two samplers. This is not always possible, however, <i>e.g.</i>, when <a href="keywords.html#SUGARFREQ">sampling
sugar pucker angles in MC</a>, but not in dynamics. In these scenarios it will be desirable to
use short segments lengths in order to improve the chances of convergence (in the given example,
convergence is unlikely if long dynamics segments only "see" few frozen conformations of the sugar
pucker states in the system). This issue is particularly difficult in mixed Cartesian/internal
coordinate space simulations attainable by selecting a hybrid scheme here and 2 for
<a href="keywords.html#CARTINT">CARTINT</a>. Some improvement can be made by including 
<a href="keywords.html#SHAKESET">geometric constraints in Cartesian space</a>, but a rigorous match
will generally be out of reach.<br/>
Technically, the simulation simply alternates between MC-based and
dynamics-based segments whose minimum and maximum lengths are controllable by the user (&rarr; keywords
<a href="keywords.html#CYCLE_MC_FIRST">CYCLE_MC_FIRST</a>, <a href="keywords.html#CYCLE_MC_MIN">CYCLE_MC_MIN</a>,
<a href="keywords.html#CYCLE_MC_MAX">CYCLE_MC_MAX</a>,<a href="keywords.html#CYCLE_DYN_MIN">CYCLE_DYN_MIN</a>, and
<a href="keywords.html#CYCLE_DYN_MAX">CYCLE_DYN_MAX</a>).<br/>
</div>
&nbsp;&nbsp; 6) Minimization: &nbsp; <br/>
<div style="margin-left: 40px;">This uses the potential energy gradient to
 steer the system to a near minimum through a
variety of techniques (see <a href="keywords.html#MINI_MODE">MINI_MODE</a>).
Minimization is not a technique to sample phase
space in terms of a well-defined ensemble, and the closest approximation of its results is
probably that of a locally sampled constant-volume (NVT) condition at extremely low temperature.
In general, minimizers are apt at finding local, but not global minima.
Note that these algorithms are still numerically discrete schemes, <i>i.e.</i>,
they employ finite step sizes. This means that
irrespective of any theoretical guarantees or expectations an algorithm offers,
results may not always be as straightforward. In addition, minimizers
are poor tools if the basic step sizes should be heterogeneous for different
degrees of freedom, <i>e.g.</i>, for a dilute phase of Lennard-Jones atoms or clusters.<br/>
</div>
&nbsp;&nbsp; 7) Mixed Monte Carlo and Langevin Dynamics: <br/>
<div style="margin-left: 40px;">This is analogous to 5) only that Newtonian
dynamics are replaced with Langevin dynamics (see 3). (<a href="references.html#ref6_1">example reference</a>)<br/>
</div>
<br/>
&nbsp;
To be added in the future are:<br/>
&nbsp;&nbsp; 4) Brownian Dynamics<br/>
<br/>
Note that in all of the above methods relying on forces (options 2-7),
it is very likely that optimized loops will be used (depending on <a href="keywords.html#energy_terms">settings
for the Hamiltonian</a>). These currently have the property of using few stack-allocated
array variables that may become large if <a href="keywords.html#cutoff_settings">cutoff settings</a> are very generous 
or if no cutoffs are in use. This may lead to unannotated segmentation faults (depending
on compiler, architecture, and local settings). There are several workarounds
(on Unix-systems, the shell command "ulimit" can for example be used to increase
stack size for the local environment) some of which will be compiler-specific (for example
to force the compiler to always allocate local arrays from the heap). Stack access is faster
and therefore generally desirable in the speed-critical portions of the code.<br/>
<h4><a class="NoHi" id="MC_ACCEPT"><b>MC_ACCEPT</b></a></h4>
If the simulation uses (at least partially) <a href="keywords.html#DYNAMICS">Monte Carlo sampling</a>,
this very important keyword allows the user to choose between (currently) three different
types of acceptance rules for MC moves that are as follows:<br/>
<ol>
<li>The Metropolis criterion is used. A random number sampled uniformly over the interval is compared 
to the term c<sub>b</sub>&#183;e<sup>-&beta; &Delta;U</sup>. Here, &Delta;U is the difference
in (effective) energy of the new vs. the original conformation (U<sub>new</sub> - U<sub>old</sub>),
&beta; is the inverse temperature, and c<sub>b</sub> is a bias correction factor that is specific
to the move type. If the random number is less than the term above, the move is accepted. Note that
c<sub>b</sub> can encompass different types of bias. It is also important to keep in mind that some
advanced move types may imply incorporating biasing terms during the picking of a new conformation
(see <a href="keywords.html#TORCRMODE">TORCRMODE</a>), and no longer show up in c<sub>b</sub>. The
Metropolis criterion has the advantage that it is rejection-free in the limit of no energetic
or other biases. With a non-zero energy function in place, the distribution sampled from is the Boltzmann
distribution.</li>
<li>A Fermi criterion is used. A random number sampled uniformly over the interval is compared 
to the term (1 + c<sub>b</sub><sup>-1</sup>&#183;e<sup>&beta; &Delta;U</sup>)<sup>-1</sup>. 
If the random number is less than the term above, the move is accepted. The Fermi criterion's only
advantage over the Metropolis criterion is that it defines an actual probability on the interval
[0,1]. The downside is that the limiting acceptance rate is only 50%. However, the impact is much weaker
if &Delta;U is relatively large on average (in absolute magnitude). The sampled distribution
is again the Boltzmann distribution.</li>
<li>A Wang-Landau / Metropolis criterion is used. A random number sampled uniformly over the interval is compared 
to the term c<sub>b</sub>&#183;e<sup>&beta; &Delta;ln T</sup> or to the term c<sub>b</sub>&#183;e<sup>-&beta; &Delta;U - &Delta;ln T</sup> (see keyword <a href="keywords.html#WL_MODE">WL_MODE</a>). Here,
&Delta;ln T is the difference in the logarithms of the current and proposed estimates of the target distribution (<i>e.g.</i>, the density of states),
<i>i.e.</i>, &Delta;ln T = ln T<sub>new</sub> - ln T<sub>old</sub>.
The Wang-Landau algorithm is explained in detail <a href="keywords.html#WL_MODE">elsewhere</a>,
but it should be pointed out that the sampled distribution is no longer the Boltzmann distribution
(instead it is ill-defined, and the simulation results require <a href="keywords.html#FRAMESFILE">snapshot-based reweighting</a>), the simulation does not satisfy detailed balance (the estimate of the density of states
changes continuously), and convergence/errors are much more difficult to assess (since the method
is essentially an iteration and not an equilibrium sampling scheme). It is crucial to keep in mind that
the standard Metropolis criterion is used while the simulation has not exceeded the <a href="keywords.html#EQUIL">number of equilibration steps</a>.
This is mostly to avoid range problems when starting from random initial configurations.</li>
</ol>
Note that <a href="keywords.html#REFREQ">replica-exchange swap moves</a> are currently not affected by this choice (they always utilize the Metropolis (default) choice to determine move acceptance).<br/>
<h4><a class="NoHi" id="FRICTION"><b>FRICTION</b></a></h4>
This keyword allows the user to specify the uniform damping
coefficient acting on <b>all</b> degrees of freedom.
The value is interpreted to be in ps<sup>-1</sup>. Currently, this is
only relevant if <a href="keywords.html#DYNAMICS">DYNAMICS</a>
is set to either 3 or 7. In Langevin dynamics, the velocity damping
through friction is given by e<sup>-γ·δt</sup>.
Here, γ is the damping coefficient, and δt is the
integration time step (see <a href="keywords.html#TIMESTEP">TIMESTEP</a>).
Note that in Cartesian dynamics
(see <a href="keywords.html#CARTINT">CARTINT</a>)
each degree of freedom is an orthogonal direction of the Cartesian
movement of each atom. Typically,
Langevin dynamics integrators may make the friction on those degrees of
freedom dependent on atom mass but
CAMPARI does not support this at the moment since the hydrodynamic
properties of individual atoms are
poorly described in any case. Conversely, in torsional dynamics, the
rigid-body and torsional degrees of freedom of each
molecule are integrated and the friction is applied <i>uniformly</i>
to all of those. This means that hydrodynamic properties
are - again - ill-represented. Bias torques on account of variable effective masses
for most dihedral angle degrees of freedom will continue to be in effect
(see <a href="keywords.html#TMD_INTEGRATOR">elsewhere</a>).<br/>
When applying Stokes' law (which should be inapplicable when the diffusion
object is strongly aspherical and/or of similar size compared to the molecules
comprising the surrounding fluid) to the self-diffusion of water, the measured diffusion constant
of around 2.3&#183;10<sup>-9</sup> m<sup>2</sup>s<sup>-1</sup> is roughly
consistent through the Einstein-Stokes equation with the measured viscosity
of about 8.9&#183;10<sup>-4</sup> kgm<sup>-1</sup>s<sup>-1</sup>
(both at 25&deg;C). By dividing by the mass, a damping constant of about 90ps<sup>-1</sup>
can be obtained from the Stokes approximation. When performing stochastic dynamics
simulations of large, spherical rigid bodies, such a value may be appropriate.
For molecular simulations, however, it is not. First, in conjunction with typical
<a href="keywords.html#TIMESTEP">time steps</a>, the value is so large
that the impulse integrator in use (&rarr; <a href="keywords.html#DYNAMICS">DYNAMICS</a>) 
can no longer sample the correct ensemble (it becomes overdamped implying temperature artifacts).
Second, in a Cartesian treatment, unless one samples a monoatomic fluid of inert particles,
the correlations between particles are so high that a treatment as independently
diffusing spheres is not just inaccurate, but nonsensical in the absence of hydrodynamic
interactions. Third, in internal coordinate spaces, the individual
degrees of freedom hardly ever fit the Stokes approximation. Torsional and rigid-body 
rotational degrees of freedom would require a completely different model of friction.
Furthermore, unlike in a Cartesian treatment, the degrees of freedom are not all similar
to one another. The above means that the damping constant should be understood
as an empirical parameter. Better control over values for individual degrees of freedom
will be implemented in the future. It defaults to a value of 1.0 ps<sup>-1</sup> on
par with the coupling times of thermostats in molecular dynamics (&rarr; <a href="keywords.html#TSTAT_TAU">TSTAT_TAU</a>).<br/>
<h4><a class="NoHi" id="CYCLE_MC_FIRST"><b>CYCLE_MC_FIRST</b></a></h4>
If a hybrid MC/M(B,L)D method is used (see <a
 href="keywords.html#DYNAMICS">DYNAMICS</a>), this keyword
controls the length of the first segment (in number of steps) which is
always a MC segment.
This is to ensure that hybrid runs can safely be started from poorly
equilibrated (random) structures
where forces are large and integrators quickly become unstable.
<h4><a class="NoHi" id="CYCLE_MC_MIN"><b>CYCLE_MC_MIN</b></a></h4>
If a hybrid MC/M(B,L)D method is used (see <a
 href="keywords.html#DYNAMICS">DYNAMICS</a>), this keyword
controls the minimum length of MC segments (in number of steps) with
the exception of the first segment.
<h4><a class="NoHi" id="CYCLE_MC_MAX"><b>CYCLE_MC_MAX</b></a></h4>
If a hybrid MC/M(B,L)D method is used (see <a
 href="keywords.html#DYNAMICS">DYNAMICS</a>), this keyword
controls the maximum length of MC segments (in number of steps) with
the exception of the first segment.
<h4><a class="NoHi" id="CYCLE_DYN_MIN"><b>CYCLE_DYN_MIN</b></a></h4>
If a hybrid MC/M(B,L)D method is used (see <a
 href="keywords.html#DYNAMICS">DYNAMICS</a>), this keyword
controls the minimum length of dynamics-based segments (in number of
steps). This should probably be
significantly larger than the velocity autocorrelation time of the
system.
<h4><a class="NoHi" id="CYCLE_DYN_MAX"><b>CYCLE_DYN_MAX</b></a></h4>
If a hybrid MC/M(B,L)D method is used (see <a
 href="keywords.html#DYNAMICS">DYNAMICS</a>), this keyword
controls the maximum length of dynamics-based segments (in number of
steps).
<h4><a class="NoHi" id="PH"><b>PH</b></a></h4>
This keyword sets the assumed simulation pH which currently possesses
significance
for titration moves only → <a href="keywords.html#PHFREQ">PHFREQ</a>.
This keyword
may later be extended to represent the assumed (bath) pH in constant-pH
simulations.<br/>
<h4><a class="NoHi" id="IONICSTR"><b>IONICSTR</b></a></h4>
This keyword sets the assumed simulation ionic strength for simplified
pK<sub>a</sub> computations.
The units are molar (M). Ionic strength is used in a grossly simplified
Debye-H&uuml;ckel approach
to estimate cross-influences between multiple ionizable sidechains on a
polypeptide (
see <a href="keywords.html#PHFREQ">PHFREQ</a>). Note that this keyword
can <b><i>not</i></b> be used
to set an assumed ionic strength for the generalized reaction-field
method (see <a href="keywords.html#RFMODE">RFMODE</a>).<br/>
<h4><a class="NoHi" id="RESTART"><b>RESTART</b></a></h4>
This keyword is a simple logical indicating whether to restart a previously discontinued run.<br/>
It tells the program to attempt to restart a simulation
which was accidentally or intentionally terminated. The program writes
out ASCII-files containing relevant information in comparatively high precision
(see <a href="keywords.html#RSTOUT">RSTOUT</a>).
This file (one for each node in MPI calculations) is called
{basename}.rst (see <a href="outputfiles.html#basename_1.rst">elsewhere</a>).
If it is
successfully read, the simulation is extended from the simulation step
the file was last
written for. Non-synchronous MPI runs are synchronized to the step
number of the slowest node. Note that
instantaneous output of the crashed run should be saved separately
(<i>i.e.</i>, moved to another directory) since with
the exception of running <a href="keywords.html#XYZPDB">trajectory pdb/xtc/dcd-output</a> new files will
replace the old ones. All non-instantaneous
analysis of the crashed run is unfortunately lost. The simulation will
then
proceed starting effectively at that
step, so the same key-file (with the exception of the RESTART-keyword
itself of course) can be used. If it is past the
equilibration step, on-the-fly analysis will begin immediately. Final
output will reflect only the restarted portion
of the run. The program will acknowledge in the log-file that it's
restarting, and will post a warning message if the energies of the
structures reported in the restart-file and re-computed by
the program are inconsistent. Note that it is - rigorously speaking -
only safe to restart the exact same calculation, since the information
contained in the restart file will depend on the type of calculation performed. It will often be possible
to start MC runs (see <a href="keywords.html#DYNAMICS">DYNAMICS</a>) from a non-MC
restart file, however. For the opposite and all other cases, consider
using the auxiliary keyword <a href="keywords.html#RST_MC2MD">RST_MC2MD</a>.<br/>
It should be noted that these restarts are not fully deterministic meaning that they deviate
from the original run if it had continued for more steps (this is typically unknown of course).
The reasons for this are several. First, no information about the state of the random 
number generator is preserved. This affects <a href="keywords.html#DYNAMICS">Monte Carlo and Langevin dynamics sampling</a>
, <a href="keywords.html#TSTAT">stochastic thermostats</a>, and so on. Second,
the information in the restart files is not printed to full double precision (this has historical reasons).
This means that even a conceptually deterministic simulation will start to deviate after some number
of steps (depending on the system). Third, if the <a href="keywords.html#NRTHREADS">shared memory parallelization</a>
is used, the <a href="keywords.html#THREADS_DLB_FREQ">balancing of load</a> is initialized 
and reoptimized as it would be at the beginning of the simulations. This leads to a different
sequence and blocking of computations, which subtly affects sums, for example.
Fourth, as a related point, the order and grouping of compute tasks are architecture- 
and compiler-dependent. This means that code using different optimization levels or simply 
a different compiler is not the same at the machine level, and consequently the results are not
the same either. Much more dramatic deviations are obtained by enabling aggressive optimization
settings, for example those that reduce the precision of built-in mathematical functions.
While the first two points could be avoided easily, the latter two are essentially
insurmountable with present-day computers. One way to state this deficiency is to redefine
numerical reproducibility as the matching of a reference result with finite accuracy, <i>i.e.</i>,
for suitably rounded results to be the same. The required level of rounding depends on the "depth"
of the calculations, <i>i.e.</i>, on how often inaccurate results are reused. This technique
was used extensively in debugging the OpenMP parallel code across different architectures and compilers.
<br/>
<h4><a class="NoHi" id="RST_MC2MD"><b>RST_MC2MD</b></a></h4>
This is a rather specialized keyword meant for the specific case
of (re)starting a dynamics run from a restart-file generated by an MC
run. In this case, the restart file is shorter
and only contains atomic positions, the Z-matrix, and whatever else is
necessary. When set to 1, this keyword
instructs the restart-file reader to assume the MC format even though
the run is set to be a dynamics run (see <a
 href="keywords.html#DYNAMICS">DYNAMICS</a>). Initial velocities are
then generated from a Boltzmann distribution using the bath temperature
(see <a href="keywords.html#TEMP">TEMP</a>). Ff this keyword is not
set, an
attempt to read mismatched restart files will crash the program (most
likely in a segmentation fault). This
is due to the assumed rigid formatting. The inverse procedure (reading
a restart file generated by a dynamics run as
the starting point for an MC run) is currently not supported. Note that
the typical application for this is to use MC for
equilibration of a system and to continue the run using a dynamics
sampler. In single-CPU calculations, this simplifies the overall
procedure and avoids using
the generally low-precision pdb format as an intermediate step
(although this can be adjusted with keyword <a href="keywords.html#PDB_OUTPUTSTRING">PDB_OUTPUTSTRING</a>). For
some replica-exchange runs (see <a href="keywords.html#REMC">REMC</a>),
restart files are actually the
only option which allows starting the individual nodes from individual,
non-random
conformations stored in an input file. The primary application
for this keyword therefore probably lies in replica-exchange
molecular dynamics runs which use Replica-Exchange Monte Carlo runs for
equilibration purposes.<br/>
<h4><a class="NoHi" id="DYNREPORT"><b>DYNREPORT</b></a></h4>
This minor keyword is a simple logical which ensures that in
<a href="keywords.html#DYNAMICS">dynamics calculations</a>
with different <a href="keywords.html#TSTAT_FILE">temperature-coupling groups</a> a
summary is provided of the partitioning in that regard.<br/>
<h4><a class="NoHi" id="CHECKGRAD"><b>CHECKGRAD</b></a></h4>
This keyword is a simple logical which instructs CAMPARI to test the
gradients for the current calculation given the Hamiltonian, system, and starting
structure. It tests Cartesian gradients first, followed by the transformed
gradients acting on the internal degrees of freedom (if settings allow that: see <a
 href="keywords.html#CARTINT">CARTINT</a>).<br/>
It is mostly for developer's usage and creates at most two undocumented
output files: NUM_GRAD_TEST_XYZ.dat
and NUM_GRAD_TEST_INT.dat). The procedure works by numerically
computing gradients using
pure energy routines (finite differencing) and juxtaposing the
analytical solution.
It is slow and can sometimes be misleading or uninformative for the
following reasons:
<ol>
  <li>For just a single molecule, rigid-body gradients are always
net zero (outside of boundary contributions).</li>
  <li>The dynamics Hamiltonian must be identical to the MC
Hamiltonian (in particular see <a href="keywords.html#LREL_MC">LREL_MC</a>
and <a href="keywords.html#LREL_MD">LREL_MD</a>).</li>
  <li>For Cartesian gradients to be accurate, no strictly
torsional space Hamiltonian terms should be used (see for example <a
 href="keywords.html#SC_ZSEC">SC_ZSEC</a> and <a
 href="keywords.html#SC_TOR">SC_TOR</a>). For those, Cartesian
gradients are circumvented <i>unless</i> <a
 href="keywords.html#CARTINT">CARTINT</a> is 2.</li>
</ol>
Importantly, the test of numerical gradients does not make use of the 
<a href="keywords.html#NRTHREADS">shared memory parallelization</a> of CAMPARI.
The consequences are that the procedure cannot be sped up and that the actual
routines used to propagate the system during parallel execution are not tested.
The test of the actual routines is implemented in <a href="keywords.html#THREADS_TEST">THREADS_TEST</a>
albeit against the serial force routines. Thus, a two-stage
test is needed for comparing numerical gradients to those derived
from the parallel force routines.<br/> 
<h4><a class="NoHi" id="UNSAFE"><b>UNSAFE</b></a></h4>
This keyword is a simple logical (default off) which allows selected
fatal errors
to be transformed into warnings (for example the simulation of systems
which are
not net-neutral). It should be used with caution (obviously) and the
log-output
should always be studied meticulously. In addition, enabling unsafe execution
may skip some costly sanity checks, <i>e.g.</i>, when reading in 
trajectories in pdb format.<br/>
<h4><a class="NoHi" id="CRLK_MODE"><b>CRLK_MODE</b></a></h4>
CAMPARI currently provides limited support in dealing with chemical
crosslinks which either
create one (or multiple) intramolecular loops, or link multiple
molecules together.
For force-based sampling in Cartesian space only (see <a
 href="keywords.html#CARTINT">CARTINT</a> and
<a href="keywords.html#DYNAMICS">DYNAMICS</a>), this functionality
matters exclusively
for the following reasons:
<ol type="a">
  <li>A chemical crosslink can be thought of as a branch in the
main-chain. Such non-linear polymers violate CAMPARI's model of
identifying topologically connected sequence neighbors purely
based upon primary sequence. Therefore, non-bonded interactions have to
be corrected if the
two residues in question are crosslinked to each other (to comply with
the settings provided via
    <a href="keywords.html#INTERMODEL">INTERMODEL</a> and <a
 href="keywords.html#ELECMODEL">ELECMODEL</a>).
This is supported by CAMPARI independent
of crosslink type (even though there currently are only disulfide
linkages supported →
    <a href="inputfiles.html#FMCSC_SEQFILE">sequence input</a>).</li>
  <li>A single intermolecular crosslink essentially merges two
molecules into a single one. However,
CAMPARI continues to treat both chains as if they were independent
molecules. This has a variety of
reasons most of which pertain to the consistency of internal data
representation and to the support
of internal analysis routines. One area where this is tricky is for
simulations in periodic boundary
conditions (→ <a href="keywords.html#BOUNDARY">BOUNDARY</a>), as shift
vectors are generally
applied only to intermolecular contacts. For two crosslinked molecules,
this continues to be the case
thereby allowing - given a poor simulation system setup - the
theoretical possibility of one
of the two crosslinked molecules to interact with parts of different
images of the other molecule.
    <a href="outputfiles.html#Trajectory%20output">Trajectory output</a>
may also appear confusing for the same reason.</li>
  <li>New bonded interactions are created which have to be correctly
accounted for. In accordance with the previous
point this implies that distance vectors have to be image-corrected in
periodic boundary conditions even for those.
For the crosslink to be actually established it is necessary that the
parameter file offer support
for the required bond length, angle, and dihedral terms. This is of
course true for any topological interaction
in a Cartesian treatment. Request a <a href="keywords.html#BONDREPORT">report</a>
to obtain more information at
the beginning of the simulation.</li>
  <li>For random initial structures it will be necessary for the
crosslink to be satisfied to allow
stable integration of the equations of motion. This is elaborated upon <a
 href="keywords.html#RANDOMIZE">elsewhere</a>.</li>
  <li>If the ABSINTH implicit solvation model is used (→ <a
 href="keywords.html#SC_IMPSOLV">SC_IMPSOLV</a>), the crosslink usually
modifies two solvation groups (one on each "side") to yield a single
new unit. CAMPARI
will typically split this group such that the solvation groups may
remain associated with their "host residue".</li>
</ol>
This keyword becomes relevant only if sampling occurs in rigid body /
torsional space either through Monte Carlo-
or torsional dynamics-based sampling. There are two modes of operation
to be supported:<br/>
<ol>
  <li>The crosslink is treated as restraints and the sampler is unaware
of its explicit existence.</li>
  <li>The crosslink is treated as a set of (hard) constraints and the
sampler is adjusted to preserve these constraints.
This mode is currently under development and not yet supported.</li>
</ol>
This means that in order to use mode 1, bonded terms have to be defined
in the parameter file which keep the crosslink intact.
New internal degrees of freedom are implicitly defined: Usually, these
will comprise of a single bond length, two bond angles, and three
dihedral angles (using disulfide bonds as an example: the -S-S- bond,
the two -C<sub>β</sub>-S-S-
bond angles, the two χ<sub>2</sub>-torsions in both cysteine
sidechains, and the dihedral angle
defined by atoms -C<sub>β</sub>-S-S-C<sub>β</sub>-). The former are
three non-canonical degrees of freedom
in rigid body / torsional space and this mixing certainly is an
approximation defensible for technical reasons only.
Beyond that, the sampler is expected to continue to be able to explore
conformational space for the new phase space. In detail, this means
that sampling in torsional / rigid-body space using force-based
algorithms
(see <a href="keywords.html#CARTINT">CARTINT</a> and <a
 href="keywords.html#DYNAMICS">DYNAMICS</a>) will be vastly
favored over MC sampling (although a hybrid setting may be
advantageous). This is so because the MC move set is not
adjusted to reflect the restraints and will suffer from very poor
acceptance rates. For example, consider an intermolecular crosslink and
<a href="keywords.html#RIGIDFREQ">rigid body moves</a> trying to
displace one of the
two crosslinked moieties. Alternatively, consider the ineffectiveness
of <a href="keywords.html#PIVOTMODE">pivot-style</a>
moves for residues within the loop in the presence of an intramolecular
crosslink.<br/>
The latter is the primary reason for supporting mode 2 in the future.
Here, the move set will be explicitly adjusted to
only allow moves which automatically satisfy the crosslink exactly. For
torsional dynamics this option will be less useful
as CAMPARI does not possess the capability to enforce high-level loop
closure constraints in torsional space and consequently
all residues within the loop region would have to be completely
constrained for the crosslink to remain intact exactly.<br/>
<h4><a class="NoHi" id="BIOTYPEPATCHFILE"><b>BIOTYPEPATCHFILE</b></a></h4>
This simple keyword lets the user provide the location and name of an
<a href="inputfiles.html#FMCSC_BIOTYPEPATCHFILE">optional input file</a>
that can be used to (re)set the assigned biotypes for specific atoms or groups of 
related atoms in the system. The corresponding biotype number has to be available (listed)
within the <a href="keywords.html#PARAMETERS">parameter file in use</a>. 
Biotypes are the most fundamental assignment for atoms within in CAMPARI and can indirectly
set many other properties such as charge, mass, <i>etc.</i> This is explained in detail
<a href="parameters.html#S1_Biotypes">elsewhere</a>. However, there are parameters
not affected by biotype assignment, specifically the default geometries and parameters
derived from them. This means that it is generally impossible to, for example, mutate
a molecule into a different molecule using such patches. Applications of this type
may be more feasible for simulations in <a href="keywords.html#CARTINT">Cartesian space</a>.<br/>
The main domains of application for biotype patches are twofold. First, they
allow the fastest and most convenient route to include parameter support for atoms
in residues not supported natively by CAMPARI (&rarr; <a href="inputfiles.html#FMCSC_SEQFILE">sequence input</a>).
Second, they allow to diversify a parameter file regarding natively supported residues, <i>.e.g.</i>,
by maintaining multiple parameterizations for a small molecule or by including extra 
distinctions for atoms in terminal polymer residues. Biotype patches are applied first
and may be largely overridden by successive application of other patches, <i>e.g.</i>,
<a href="keywords.html#LJPATCHFILE">atom type patches</a>,
<a href="keywords.html#CPATCHFILE">charge patches</a>, <i>etc.</i><br/>
<h4><a class="NoHi" id="MPATCHFILE"><b>MPATCHFILE</b></a></h4>
This simple keyword offers the user to provide the location and name of an
<a href="inputfiles.html#FMCSC_MPATCHFILE">optional input file</a>
that can be used to alter the masses of specific atoms in the system (in g/mol).
Normally, masses are chosen for atoms based on the
assigned <a href="parameters.html#S2_LJ-types">atom types</a> in the parameter
file, and this behavior can be overridden by this keyword specifically
for atomic mass. Note that this different from changing the atom
type of the atom itself, for which a <a href="keywords.html#LJPATCHFILE">dedicated patch facility</a>
is in place. Some more details are given <a href="inputfiles.html#FMCSC_MPATCHFILE">elsewhere</a>.<br/>
<h4><a class="NoHi" id="RPATCHFILE"><b>RPATCHFILE</b></a></h4>
Similar to keyword <a href="keywords.html#MPATCHFILE">MPATCHFILE</a>, this
simple keyword offers the user to provide the location and name of an
<a href="inputfiles.html#FMCSC_RPATCHFILE">optional input file</a>
that can be used to alter specifically the radii of individual atoms in the system (in &#8491;).
By default, these radii are inferred either from the assigned <a href="parameters.html#S2_LJ-types">atom types</a>,
 <i>i.e.</i>, computed from the Lennard-Jones size parameters, or they are overridden at the
level of the parameter file by the "radius" specifications. Because the latter still operate
at the resolution of assigned atom types, this keyword offers an atom-specific override facility.
Note that there is a distinct hierarchy to this. Specifically, changing the radius
via a patch does not change the atom type for that atom. It does, however, alter
the default values of parameters that depend on radius, such as <a href="keywords.html#SAVPATCHFILE">maximum SAV fractions</a>
or <a href="keywords.html#ASRPATCHFILE">atomic volume reduction factors</a>, which are then again patchable themselves.
Furthermore, a radius patch overrides a radius inferred by applying a <a href="keywords.html#LJPATCHFILE">patch
to the Lennard-Jones parameters of a specific atom</a>.
Details on the input are given <a href="inputfiles.html#FMCSC_RPATCHFILE">elsewhere</a>.<br/>
<h4><a class="NoHi" id="WL_MODE"><b>WL_MODE</b></a></h4>
By specifying the <a href="keywords.html#MC_ACCEPT">Wang-Landau acceptance criterion</a> for 
a (partial) Monte Carlo run, the WL method is enabled. This keyword defines the reaction coordinate
of choice and the coupled pair to be iterated (see below).
Suppose we have an augmented Hamiltonian as follows:<br/><br/>
H = K + &lambda;E + X(Y)/&beta;<br/><br/>
Here, K and E are kinetic and potential energies, &beta; is the inverse temperature, and X(Y) is an
unknown function of a selected reaction coordinate. The factor &lambda; can be either 0 or 1.
Assuming that the Hamiltonian is separable, expected sampling weights from the Boltzmann
distribution for the augmented Hamiltonian are:<br/><br/>
w(Y<sub>1</sub>)/w(Y<sub>2</sub>) = (p<sub>&lambda;</sub>(Y<sub>1</sub>)/ p<sub>&lambda;</sub>(Y<sub>2</sub>)) exp[X(Y<sub>2</sub>)−X(Y<sub>1</sub>)]<br/><br/>
Here, p<sub>&lambda;</sub>(Y) is the expected probability (usually treated numerically as the integral over a finite interval, <i>i.e.</i>, by binning).
If &lambda; is 1, it corresponds to the equilibrium (Boltzmann) probability for the original Hamiltonian.
Conversely, if it is 0, p<sub>&lambda;</sub>(Y) corresponds to the density of states (distribution as T&rarr;&infin;). If Y=E,
p(E) can be written simply as p(E) = g(E) exp(-&lambda;E/&beta;), with g(E) being the density of (energy) states.
This simple form is not available for other reaction coordinates. The Wang-Landau method's key ingredient is choosing
X(Y) such that w(Y<sub>i</sub>)/w(Y<sub>j</sub>) = 1 &forall; i,j over an interval of interest. This statement is 
equivalent with the definition of a flat walk in the space of Y. A flat walk eliminates all barriers in the projected space of
Y and should therefore be efficient at exploring phase space (see associated keywords for details on this).
The main use of the flatness is as a diagnostic, however, and the Wang-Landau algorithm uses X(Y) and the apparent distribution in Y as a coupled pair
to iteratively build up X(Y). If the apparent distribution becomes flat, confidence rises that X(Y) corresponds to the target distribution
of interest. The target distribution is set by this keyword:
<ol>
<li>The target distribution is ln g(E) (arbitrary offset). This is achieved by letting &lambda; be zero and Y=E. This is also the implementation chosen
in the <a href="references.html#ref2_12">original publication</a>. Interest in the density of states comes from the fact that it
(theoretically) enables reweighting of the flat-walk ensemble to any condition of interest. This is the default.</li>
<li>The target distribution is ln p(Z) or ln p(Z<sub>a</sub>,Z<sub>b</sub>) (arbitrary offset),
where the Z are geometric reaction coordinates (&rarr; <a href="keywords.html#WL_RC">WL_RC</a>)
restricted to specific molecules (&rarr; <a href="keywords.html#WL_MOL">WL_MOL</a>). By letting &lambda; be unity, the 
target distribution is actually the potential of mean force (PMF) for that (pair of) reaction coordinate(s).
Unlike for umbrella sampling (see, <i>e.g.</i>, <a href="tutorial9.html">Tutorial 9</a>), it is obtained without further
post-processing. This variant was introduced <a href="references.html#ref2_13">here</a>. As stated, it is possible to estimate a two-dimensional
target distribution.</li>
<li>The target distribution is ln p(E) or ln p(E,Z) (arbitrary offset). This is achieved by letting &lambda; be unity and Y=E. In comparison to the first option,
this will oversample low likelihood states rather than low degeneracy states. It can be combined with a geometric reaction coordinate (Z) in a
two-dimensional approach.</li>
</ol>
The iteration proceeds by simply incrementing an estimate of X(Y) based on the apparent probability. The increment is lowered
successively toward convergence. This corresponds to a hierarchical approach in which coarse features of the target
distribution are established first before the fine details are added. The three main issues with the Wang-Landau method are as follows 
(and much literature has been dedicated to these, which is well beyond the scope of this documentation). First, 
all Wang-Landau results require snapshot-based reweighting techniques to recover quantities not identical with or trivially related
to the target distribution. Reweighting techniques have different error properties than standard sampling techniques due to
the appearance of exponential weights. Second, it is difficult and system-dependent to guide and assess the convergence of the method.
This is partially a result of fundamental problems (degeneracy in Y) and method-specific issues (see keywords
 <a href="keywords.html#WL_HUFREQ">WL_HUFREQ</a>, <a href="keywords.html#WL_FLATCHECK">WL_FLATCHECK</a>,
 <a href="keywords.html#WL_FREEZE">WL_FREEZE</a>, <i>etc</i>). Third, the method suffers from discretization errors in particular
at steep boundaries of the target distribution. This often necessitates a rather arbitrary restriction of the interval
to establish the flat walk on, and this limitation can easily corrode the confidence in the results (see keywords
 <a href="keywords.html#WL_BINSZ">WL_BINSZ</a>, <a href="keywords.html#WL_MAX">WL_MAX</a>,
 <a href="keywords.html#WL_EXTEND">WL_EXTEND</a>, <i>etc</i>).<br/>
A few technical comments are necessary. First, the Wang-Landau acceptance criterion
can be combined with a <a href="keywords.html#DYNAMICS">hybrid sampling technique</a>.
In such a case, the dynamics segments will propagate the system as usual, but will contribute
in no way to the Wang-Landau histograms. They merely serve to evolve the system
to find new states that may be hard to access given the Monte Carlo sampler. The MC segments
will utilize the Wang-Landau criterion and increment the histograms. As a result, it may be
possible that a dynamics segment starts in a high energy state. This may make the integrator
unstable initially, and cause unforeseen crashes. Second, Wang-Landau sampling is also 
supported in parallel runs. For pure Monte Carlo simulations, the
<a href="keywords.html#MPIAVG">MPI averaging technique</a> implies a parallel Wang-Landau implementation,
<i>i.e.</i>, an implementation in which the histograms are updated globally. Wang-Landau
sampling is also supported in conjunction with the <a href="keywords.html#REMC">replica-exchange method</a>,
but here each replica is confined to its own iterative Wang-Landau procedure (since the Hamiltonians
are most likely different).
 <br/>
<h4><a class="NoHi" id="WL_MOL"><b>WL_MOL</b></a></h4>
If a <a href="keywords.html#MC_ACCEPT">Wang-Landau acceptance criterion</a> is used for a (partial) Monte Carlo
run, and if a molecular reaction coordinate was chosen as the histogram to consider (&rarr;
<a href="keywords.html#WL_MODE">WL_MODE</a>), this keyword allows the user to select the 
molecule that the reaction coordinate is computed on. The numbering of molecules follows
the user-selected sequence in <a href="inputfiles.html#FMCSC_SEQFILE">sequence input</a>.
Note that it is up to the user to ensure that the chosen reaction coordinate is defined and 
has a meaningful range for the chosen molecule (see <a href="keywords.html#WL_MAX">WL_MAX</a>, <a href="keywords.html#WL_EXTEND">WL_EXTEND</a>,
and <a href="keywords.html#WL_BINSZ">WL_BINSZ</a>). If a two-dimensional variant with two
geometric reaction coordinates is chosen, it is theoretically possible to supply two different
molecules here. Note that the effective coupling is likely to be low in this scenario, which
may lead to poor convergence properties in the 2D space. In conjunction with <a href="keywords.html#WL_MODE">WL_MODE</a> being 3,
specification of a legal entry for WL_MOL will extend the WL estimation of ln p(E) to a two-dimensional
case with an additional, <a href="keywords.html#WL_RC">geometric reaction coordinate</a> (ln p(E,Z)).
Note that this keyword is the only way to control the dimensionality for <a href="keywords.html#WL_MODE">WL_MODE</a> being
either 2 or 3.<br/>
<h4><a class="NoHi" id="WL_RC"><b>WL_RC</b></a></h4>
If a <a href="keywords.html#MC_ACCEPT">Wang-Landau acceptance criterion</a> is used for a (partial) Monte Carlo
run, and if a molecular reaction coordinate was chosen as the histogram (or as one or both axes of the 2D histogram)
to consider (&rarr; <a href="keywords.html#WL_MODE">WL_MODE</a>), this keyword allows the user to select 
amongst few geometric reaction coordinates as follows:<br/>
<ol>
<li>The molecule's radius of gyration is used (default). The range of this quantity is difficult to predict and depends
on the constraints in the system. For example, in <a href="keywords.html#CARTINT">Cartesian space</a>, it will
be advisable to restrict the range of the histograms (&rarr; <a href="keywords.html#WL_MAX">WL_MAX</a>
and <a href="keywords.html#WL_EXTEND">WL_EXTEND</a>) to those values that do not coincide with
steric overlap (low end) or stretching of bonds (high end).</li>
<li>The molecule's mean &alpha;-content is used as defined for <a href="keywords.html#SC_ZSEC">the global seconday structure
biasing potential</a>. The quantity always has finite range, but for small systems and typical settings, it exhibits
sharp spikes connected by low likelihood regions that may challenge the discretization of the WL scheme.</li>
<li>The molecule's mean &beta;-content is used. See previous option for details and caveats.</li>
</ol>
Note that it is up to the user to ensure that the chosen reaction coordinate is defined and 
has a meaningful range for the chosen molecule (see <a href="keywords.html#WL_MAX">WL_MAX</a>
and <a href="keywords.html#WL_BINSZ">WL_BINSZ</a>). For two-dimensional cases with two geometric
reaction coordinates, the user is may specify up to two numbers. Note that the exploration space
grows exponentially with dimensionality at the benefit of resolving degeneracies projected onto the same
 range of values when considering just one of the two axes at a given time. The total number
of relevant bins is a key quantity to keep in mind when directing and assessing convergence.
In conjunction with <a href="keywords.html#WL_MODE">WL_MODE</a> being 3, specification of a legal entry for WL_RC
is not sufficient to extend the WL estimation of ln p(E) to a two-dimensional
case with an additional, geometric reaction coordinate (ln p(E,Z)). Use keyword <a href="keywords.html#WL_MOL">WL_MOL</a> 
for this purpose.<br/>
<h4><a class="NoHi" id="WL_HUFREQ"><b>WL_HUFREQ</b></a></h4>
This is one of the keywords that controls the convergence properties of a
<a href="keywords.html#MC_ACCEPT">Wang-Landau run</a>. The <a href="keywords.html#WL_MODE">target distribution in question</a>
is accumulated as a histogram (always logarithmic), and this keyword sets the frequency (step interval) for updating it with
the current value of the <a href="keywords.html#WL_F0">f parameter</a>, <i>i.e.</i>, the current
increment size (equivalent to multiplication by f in the linear space). The accumulation of the target distribution begins only after
the <a href="keywords.html#EQUIL">equilibration phase</a> has passed. Naturally, a 
small setting here will quickly increment the histogram, which may accelerate convergence
(in case the effective "mobility" of the system defined by system properties and sampling engine is good enough).
However, a small setting may also interfere with convergence because it emphasizes the noise in initial estimates
of the target distribution (in absolute magnitude), and this may make it harder to refine the guess
upon reductions of the f parameter (see <a href="keywords.html#WL_HVMODE">WL_HVMODE</a> and
<a href="keywords.html#WL_FREEZE">WL_FREEZE</a>). The default choice is 10 elementary steps.
Note that if the <a href="keywords.html#MPIAVG">parallel Wang-Landau implementation</a> is used, the step
number provided refers to the sampling amount for each individual node.<br/>
<h4><a class="NoHi" id="WL_HVMODE"><b>WL_HVMODE</b></a></h4>
This is one of the keywords that controls the convergence properties of a
<a href="keywords.html#MC_ACCEPT">Wang-Landau run</a>. It has been argued that the flatness of the accumulated histogram
for the <a href="keywords.html#WL_MODE">target distribution in question</a> (usually tested via some maximum relative 
deviation criterion) is not generally useful as a criterion 
for considering a switch to the next stage of refinement (by lowering the f parameter), and can be 
replaced with a recurrence (minimum visitation) criterion (discussed for example in <a href="references.html#ref2_14">Zhou and Bhatt</a>).
This keyword selects two different options for such a recurrence criterion. Option 2 requires each (relevant) bin
to be visited exactly once in every stage, whereas option 1 mandates that each bin be visited the nearest integer of 1/sqrt(f) times 
(at least once, though). In the parallel <a href="keywords.html#MPIAVG">parallel Wang-Landau implementation</a>, the condition
will always be checked against the combined data. If the condition is fulfilled, and if the number of post-<a href="keywords.html#EQUIL">equilibration</a> 
Wang-Landau steps exceeds the <a href="keywords.html#WL_FREEZE">buffer setting</a>, ln f will be reduced
(initial value set by keyword <a href="keywords.html#WL_F0">WL_F0</a>) by a factor 2. Note that the f parameter is implied to
operate on a logarithmic scale (same as target distribution) of counts to avoid numerical issues with large numbers.
The rule used here is equivalent to the square root update rule suggested in the
<a href="references.html#ref2_12">original publication</a>. <a href="references.html#ref2_15">Belardinelli and Pereyra</a>
suggest that the exponential update becomes inappropriate for small f and CAMPARI implements their suggestion to switch over
to f &prop; 1/N<sub>steps</sub>, where N<sub>steps</sub> is the current number of WL steps having being executed. In the 
parallel <a href="keywords.html#MPIAVG">parallel Wang-Landau implementation</a>, this implies the combined total
of WL steps from all replicas. This modified update rule is implemented irrespective of the fulfillment of the criterion defined by WL_HVMODE.<br/>
It is useful to keep in mind that option 1 will initially lead to fewer reductions of the f parameter, which may be beneficial for establishing correctness,
and at the same time may be harmful for the rate of convergence. An issue often affecting convergence adversely are very-low-likelihood bins.
In this context, it should be emphasized that the relevance of a bin toward defining flatness
is partially controlled by keyword <a href="keywords.html#WL_FREEZE">WL_FREEZE</a>, which consequently serves two purposes, and partially 
controlled by the general range settings (<a href="keywords.html#WL_MAX">WL_MAX</a>, <a href="keywords.html#WL_EXTEND">WL_EXTEND</a>,
and <a href="keywords.html#WL_BINSZ">WL_BINSZ</a>).<br/>
<h4><a class="NoHi" id="WL_FLATCHECK"><b>WL_FLATCHECK</b></a></h4>
If a <a href="keywords.html#MC_ACCEPT">Wang-Landau acceptance criterion</a> is used for a (partial) Monte Carlo
run, this keyword can be used to control the step
interval at which the evaluation of the <a href="keywords.html#WL_HVMODE">visitation criterion</a> for the <i>temporary</i> histogram
is performed. If the <a href="keywords.html#MPIAVG">parallel Wang-Landau implementation</a> is used, this coincides
with the requirement to (at least temporarily) combine the data from all replicas and therefore imposes
a communication requirement. Should a check return a positive result, the temporary histogram is added to the overall estimate, 
the temporary histogram is reset to zero, and the f parameter is altered as described <a href="keywords.html#WL_HVMODE">elsewhere</a>.
In the parallel version, additional operations are performed to broadcast the new total (combined) histogram identically to all replicas.
In case the criterion is not fulfilled, the temporary histogram(s) is (are) left unchanged.<br/>
The technical use of this keyword is twofold: First, to reduce communication requirements for the parallel implementation; second,
to artificially delay the progression of the iteration. The latter can sometimes be useful for complex systems with strong
degeneracy in the chosen <a href="keywords.html#WL_MODE">reaction coordinate</a> (also see <a href="keywords.html#WL_RC">WL_RC</a>).
Note that for the parallel code the step number provided refers to the sampling amount for each individual node.<br/>
<h4><a class="NoHi" id="WL_F0"><b>WL_F0</b></a></h4>
If a <a href="keywords.html#MC_ACCEPT">Wang-Landau acceptance criterion</a> is used for a (partial) Monte Carlo
run, this keyword defines the starting value for the f parameter (logarithmic). The f parameter is meant to decay from some positive number to 0,
which corresponds to multiplicative factors larger than 1 reducing to 1 in the linear space. The default is 1.0. The number of reductions
of the f parameter by the exponential rule (see <a href="keywords.html#WL_HVMODE">elsewhere</a>) is printed to log output. Depending
on the properties of the system and the resultant convergence rate, the rule may change as described for <a href="keywords.html#WL_HVMODE">WL_HVMODE</a>.<br/>
<h4><a class="NoHi" id="WL_MAX"><b>WL_MAX</b></a></h4>
If a <a href="keywords.html#MC_ACCEPT">Wang-Landau acceptance criterion</a> is used for a (partial) Monte Carlo
run, this keyword sets the (initial) upper bound (given as the bin center of the last bin) of the energy
or reaction coordinate histogram (&rarr; <a href="keywords.html#WL_MODE">WL_MODE</a> and <a href="keywords.html#WL_RC">WL_RC</a>).
At the beginning, 100 bins of equivalent <a href="keywords.html#WL_BINSZ">size</a> are created.
Depending on the choice for <a href="keywords.html#WL_EXTEND">WL_EXTEND</a>, the histogram
and its upper limit may be extended throughout the simulation. It is safe to extend
the histogram to values that are impossible to realize for the system in question, since
bins that are strictly empty do not meaningfully contribute to the algorithm
(see <a href="keywords.html#WL_FREEZE">WL_FREEZE</a>). CAMPARI accepts two separate entries for any
2D histogram. Note that the choice for this keyword may be overwritten if a dedicated input
file is used to set an initial guess for the target histogram (&rarr; <a href="keywords.html#WL_GINITFILE">WL_GINITFILE</a>).
The maximum value that will not trigger a range exception or an <a href="keywords.html#WL_EXTEND">automatic histogram extension</a>
is of course the value given here plus half the relevant <a href="keywords.html#WL_BINSZ">bin size</a>.<br/>
<h4><a class="NoHi" id="WL_BINSZ"><b>WL_BINSZ</b></a></h4>
If a <a href="keywords.html#MC_ACCEPT">Wang-Landau acceptance criterion</a> is used for a (partial) Monte Carlo
run, this keyword sets the fixed bin size for the energy 
or reaction coordinate histogram (&rarr; <a href="keywords.html#WL_MODE">WL_MODE</a> and <a href="keywords.html#WL_RC">WL_RC</a>).
At the beginning, 100 bins are created.
Depending on the choice for <a href="keywords.html#WL_EXTEND">WL_EXTEND</a>, the histogram
and its lower and upper limits may be extended throughout the simulation. However, the bin size
will remain fixed. CAMPARI accepts two separate entries for any 2D histogram.
Note that the histogram bin size and the initial number of bins may be overwritten if a
dedicated input file is used to set an initial guess for the target histogram
(&rarr; <a href="keywords.html#WL_GINITFILE">WL_GINITFILE</a>).<br/>
<h4><a class="NoHi" id="WL_EXTEND"><b>WL_EXTEND</b></a></h4>
If a <a href="keywords.html#MC_ACCEPT">Wang-Landau acceptance criterion</a> is used for a (partial) Monte Carlo
run, this keyword controls whether the energy or geometric reaction coordinate histogram (&rarr; <a href="keywords.html#WL_MODE">WL_MODE</a>)
is allowed to grow in range during the simulation. Choices are as follows:<br/>
<ol>
<li>The histogram is fixed. Note that any Wang-Landau simulation performed over a restricted interval
bares the danger of generating incorrect results even after reweighting. For common interaction potentials
and standard energy-based Wang-Landau sampling, this is particularly true for truncation of the energy
histogram on the lower end.</li>
<li>The histogram is allowed to grow only towards lower (more negative) values. This can be useful for
energy histograms, where the initial energy range is not known.</li>
<li>The histogram is allowed to grow in both directions. It is strongly recommended not to use this
feature for energy histograms with a realistic interaction potential (since the energy is unbound
on the positive side, and memory exceptions / segmentation faults are likely). This option is meant primarily
for histograms defined purely on geometric reaction coordinates (&rarr; <a href="keywords.html#WL_MODE">WL_MODE</a>).</li>
</ol>
Note that this keyword only controls changes to the physical dimensions of the histogram arrays
in memory that are originally set either by keywords <a href="keywords.html#WL_BINSZ">WL_BINSZ</a> and
<a href="keywords.html#WL_MAX">WL_MAX</a> (with 100 bins by default) or by
<a href="keywords.html#WL_GINITFILE">file input</a> (arbitrary number of bins). For issues pertaining
to the discarding of unpopulated, terminal bins for convergence, see <a href="keywords.html#WL_FREEZE">WL_FREEZE</a>.<br/>
<h4><a class="NoHi" id="WL_GINITFILE"><b>WL_GINITFILE</b></a></h4>
If a <a href="keywords.html#MC_ACCEPT">Wang-Landau acceptance criterion</a> is used for a (partial) Monte Carlo
run, this keyword allows the user to replace the default initial guess for the (logarithmic)
<a href="keywords.html#WL_MODE">target distribution</a> with a user-supplied one. The default guess
is flat. Supplying a nonflat guess can be useful in several scenarios: i) ongoing refinement of a WL run; ii) 
cases where a more useful "zero order guess" is available, <i>e.g.</i> an exponentially growing function for 
a condensed phase system with inverse power potentials; iii) convergence tests.  
The details regarding the format of this input file are provided <a href="inputfiles.html#FMCSC_WL_GINITFILE">elsewhere</a>.<br/>
<h4><a class="NoHi" id="WL_FREEZE"><b>WL_FREEZE</b></a></h4>
If a <a href="keywords.html#MC_ACCEPT">Wang-Landau acceptance criterion</a> is used for a (partial) Monte Carlo
run, this keyword controls whether the range of bins in the energy or reaction coordinate histogram
(&rarr; <a href="keywords.html#WL_MODE">WL_MODE</a>) that is considered for proceeding to the next
iteration stage (updating the value of the <a href="keywords.html#WL_F0">f-parameter</a>) is fixed after
the first such update or not. The update procedure is described for keywords <a href="keywords.html#WL_HUFREQ">WL_HUFREQ</a>,
<a href="keywords.html#WL_HVMODE">WL_HVMODE</a>, and <a href="keywords.html#WL_FLATCHECK">WL_FLATCHECK</a>.<br/>
Any positive integer specified here will prescribe a minimum number of preliminary
simulation steps beyond <a href="keywords.html#EQUIL">equilibration</a> that must be exceeded before an update
of the f-parameter is considered. After such an update, the range of bins considered for the histograms is the
continuous one (and it must be continuous on account of the update rule) currently populated. If during further simulation
steps additional bins were to be visited, those moves are instead considered as range exceptions and
are rejected (the summary statistics provided in log-output for range exceptions can therefore contain
results from two different contributions &rarr; <a href="keywords.html#WL_EXTEND">WL_EXTEND</a>).
Any negative number provided will specify by its absolute value the aforementioned minimum number
of preliminary steps in identical fashion. However, in this case, CAMPARI is instructed to allow further
bins to be added for consideration during later stages of the algorithm. Note that this violates
the refinement idea behind the Wang-Landau scheme, and can lead
to severe convergence problems due to the numerical mismatch created by the extra bin "missing out"
on f-increments during early stages of the algorithm. It is therefore strongly recommended to choose a relatively
large and positive number for this keyword (to ensure that appropriate coverage of the accessible range has been reached).<br/>
Note that if the <a href="keywords.html#MPIAVG">parallel Wang-Landau implementation</a> is used, the step
number provided refers to sampling amount for each individual node.<br/>
<h4><a class="NoHi" id="WL_DEBUG"><b>WL_DEBUG</b></a></h4>
If a <a href="keywords.html#MC_ACCEPT">Wang-Landau acceptance criterion</a> is used for a (partial) Monte Carlo
run, this simple logical allows the user to request debugging information regarding
the Wang-Landau iterative algorithm. If turned on, CAMPARI will report in log-output 
the progression through the various updating stages and may - depending on settings - also write 
<a href="outputfiles.html#WL_TMP">temporary output files</a> for the relevant histograms.<br/>
<br/>
<br/>
<br/>
<h3><a class="NoHi" id="box_settings">Box Settings:</a></h3>
<hr style="width: 100%; height: 2px;"></hr> (<a href="keywords.html#TOP">back to top</a>)<br/>
<h4><a class="NoHi" id="BOUNDARY"><b>BOUNDARY</b></a></h4>
Every simulation has to occur within an explicitly or implicitly
defined, finite volume. CAMPARI presently supports different ways of achieving such a finite volume listed
below. For constant volume ensembles (→ <a href="keywords.html#ENSEMBLE">ENSEMBLE</a>), the (formal) volume
remains exactly constant throughout the simulation. This does not imply that volume remains 
a meaningful paramerter under all circumstances, <i>e.g.</i>, if phase separation occurs.
For the type of boundary condition, there are currently three
supported options and one quasi-obsolete mode:<br/>
<ol>
  <li>Periodic boundary conditions (PBC):<br/>
    This is the most
commonly used boundary condition
in molecular simulations. Here, the generally <a href="keywords.html#SHAPE">polyhedral simulation cell</a> is
assumed to be replicated as a - theoretically infinite - periodic
system around the central one (which
constitutes the actual, physical simulation container). Partial periodicity 
is also possible with other walls implemented as restraints. This is theoretically applicable 
to many different containers including polyhedra but only supported for periodic cylinders at the moment
(<a href="keywords.html#SHAPE">SHAPE</a> is 3 and BOUNDARY is 1).
The implementation is such that all distance calculations along periodic dimensions are amended by determining the
smallest distance amongst those between a particle and any of the replicated images of
another particle. This so-called minimum image convention implies that for normal pairwise interaction
potentials (for example <a href="keywords.html#SC_IPP">SC_IPP</a>)
a particle only interacts with at most one "version" of another
particle, never two or more. The idea of PBC is borrowed
from crystals in which the assumption of periodicity is justified given
that the simulation
volume can be chosen such that it coincides with the crystal's unit
cell (or exact multiples thereof).<br/>
Conversely, in liquids there is no persistent long-range order
(homogeneous density, no pair correlations), and the approximation of a system of
thermodynamic
size by infinite replication of a nanoscopic system is at least
questionable. Given typical <a href="keywords.html#NBCUTOFF">cutoff</a> schemes, however, the
contribution of longer-range interaction is often exactly zero unless explicit techniques are used
enumerating the periodic sum (→ <a href="keywords.html#EWALD">Ewald summation</a>, which
is the only feature for which CAMPARI currently calculates interactions beyond the minimum
image convention).
This means that the actual impact of PBC is often just to mimic a
continuous environment for particles
close to the edge of the physical simulation volume. Note that no
real-space interaction cutoff should exceed half the shortest linear
dimension realizable in the simulation volume since otherwise
it becomes possible for multiple images of the same particle to be
within interaction distance.
In conjunction with the minimum image convention cited above, this
invariably leads to artefactual results (<a href="references.html#ref8_1">reference</a>).
Note that in CAMPARI the convention of using the nearest image 
operates at the molecule level, <i>i.e.</i>, the general rule is that
intramolecular distances always refer to atoms in the same image
of a molecule. CAMPARI will occasionally warn users about cases where
an image interaction would be within the cutoff distance, but these warnings
are not part of all routines (for efficiency reasons). Enabling
<a href="keywords.html#XYZ_FORCEBOX">box-consistent
trajectory output</a> may help in diagnosing such issues independently.<br/>
  </li>
  <li>Hard-wall boundary condition (HWBC):<br/>
    This option is obsolete and cannot be selected. It may be reactivated in the future to
enable simulations in containers with hard, particle momentum-conserving (<i>i.e.</i>, reflective) walls.</li>
  <li>Residue-based soft-wall boundary condition (RSWBC):<br/>
    In simulations employing a continuum description of solvent, the resultant
density is almost always low, in particular in the limit of simulating
just a single macromolecule.
In those cases, it may neither be meaningful nor beneficial to
introduce additional replicas of the
simulation cell. CAMPARI offers to define a system-volume via a
soft-wall for such a scenario. Here, the
simulated particles are prevented from leaving a simulation
container (most often a <a href="keywords.html#SHAPE">spherical droplet</a>) by an applied
boundary potential modeled as follows.<br/>Spherical case:<br/>
    <br/>
E<sub>BND</sub><sup>Sphere</sup> = Σ<sub>i</sub> k<sub>BND</sub>·H(r<sub>i</sub>-r<sub>D</sub>)·(r<sub>i</sub>-r<sub>D</sub>)<sup>2</sup><br/>
    <br/>
Here, r<sub>i</sub> is the distance from a suitable reference point on
residue i to the simulation sphere's origin, r<sub>D</sub> is the
sphere's <a href="keywords.html#SIZE">radius</a>, k<sub>BND</sub> is
the <a href="keywords.html#SOFTWALL">force constant</a>
and H(x) is the Heaviside step function.<br/>
Rectangular box case:<br/>
    <br/>
E<sub>BND</sub><sup>Box</sup> = Σ<sub>i</sub> Σ<sub>j=1..3</sub> k<sub>BND</sub>·H(|d<sub>i,j</sub>|-L<sub>j</sub>/2)·(|d<sub>i,j</sub>|-L<sub>j</sub>/2)<sup>2</sup><br/>
    <br/>
Here, d<sub>i,j</sub> is the j<sup>th</sup> element of the distance vector of the reference point on residue i
to the center point of the box (note that by convention the <a href="keywords.html#ORIGIN">lower left corner serves
as origin</a> of the box), and the L<sub>j</sub> are the <a href="keywords.html#SIZE">side lengths</a>.<br/>
Nonperiodic cylinder case:<br/>
    <br/>
E<sub>BND</sub><sup>Cylinder</sup> = Σ<sub>i</sub> k<sub>BND</sub>·[H(|d<sub>i,z</sub>|-h)·(|d<sub>i,z</sub>|-h)<sup>2</sup> + H(r<sub>i,xy</sub>-r<sub>C</sub>)·(r<sub>i,xy</sub>-r<sub>C</sub>)<sup>2</sup>]<br/>
<br/>
Here, d<sub>i,z</sub> is the z-element of the distance vector of the reference point on residue i to the middle of the cylinder
(cylinder axis always aligns with z-axis), r<sub>i,xy</sub> is the distance of the same point from the cylinder axis in the xy-plane, and 
h and r<sub>C</sub> are <a href="keywords.html#SIZE">height and radius</a> of the cylinder, respectively.<br/>
Partially periodic cylinder case:<br/>
    <br/>
E<sub>BND</sub><sup>Periodic Cylinder</sup> = Σ<sub>i</sub> k<sub>BND</sub>·[H(r<sub>i,xy</sub>-r<sub>C</sub>)·(r<sub>i,xy</sub>-r<sub>C</sub>)<sup>2</sup>]<br/>
<br/>
The nomenclature is the same as for the nonperiodic cylinder. The partially periodic cylinder has a periodic
boundary in the z-direction, and the corresponding term is thus missing from the boundary potential.<br/>
In general, hard-wall boundaries
may be approximated by letting k<sub>BND</sub> → ∞. This will deteriorate integrator
stability in <a href="keywords.html#DYNAMICS">gradient-based simulations</a>, however.
Choosing a RSWBC means that the boundary penalty
is imposed on the reference atom of each residue (for peptide residues
this is always Cα). This can lead to
potential boundary artifacts with parts of large residues sticking out
of the sphere and hence being
deprived of interactions with smaller residues. Additionally, it must
be pointed out
that soft-wall boundary conditions lead to somewhat ill-defined system
volumes since
the code assumes the fixed volume inside the boundary to be the system
volume whereas
realistically it should be slightly extended depending on temperature
and stiffness.
The latter is not easily computed, however, since 1) the purely kinetic
(entropic) pressure may
be altered by the presence of non-rigid molecules, and 2) the virial
pressure is generally
unaccounted for. Hence, an exact volume is only recovered in the limit
of an infinitely stiff
boundary (HWBC).</li>
  <li>Atom-based soft-wall boundary condition (ASWBC):<br/>
    This option is
analogous to the previous (RSWBC) option only that the boundary term is
computed for each atom in the system rather than for the reference point on each residue in the system (formulas are not repeated).
This will minimize artifacts of the aforementioned
type, but it is also the most
expensive droplet BC to compute. Because multiple atoms will contribute
to the boundary penalty for each residue,
it is generally recommended to use smaller force constants than for the
RSWBC. This boundary condition is also underlying the <a href="keywords.html#SC_OSMO">compartmentalization potential</a>,
which is a set of additional inner, planar boundaries.</li>
</ol>
<h4><a class="NoHi" id="SHAPE"><b>SHAPE</b></a></h4>
This keyword lets the user specify the shape of the simulation
container the system is enclosed in. The available choices for SHAPE depend on
the boundary condition selected (&rarr; <a href="keywords.html#BOUNDARY">BOUNDARY</a>).
At the moment, choices are as follows:
<ol>
  <li>Rectangular cuboid (= rectangular parallelepiped): This container is supported with both periodic boundary conditions (PBC)
and soft walls.</li>
  <li>Sphere: This container is only available with soft walls.</li>
  <li>Cylinder: This container is available with soft walls or with partially PBC along the cylinder 
axis, which always aligns with the z-dimension, and atom-based soft walls elsewhere (<a href="keywords.html#BOUNDARY">BOUNDARY</a> is 1).</li>
</ol>
All simulations in three-dimensional PBC have to use rectangular cuboids (extensions to
general triclinic boxes may be considered in the future).
Conversely, simulations in soft wall boundary conditions can use all available containers. Note that the
geometry of a finite (nonperiodic) cuboid or cylinder is fundamentally mismatched with the radial (centrosymmetric)
nature of most nonbonded interactions. Partial periodic boundary conditions are at the moment only supported
for the cylinder as described above.<br/>
<h4><a class="NoHi" id="ORIGIN"><b>ORIGIN</b></a></h4>
This keyword lets the user set the origin of the simulation system as a
vector of three elements (x, y, and z).
The reference point depends on the container's
<a href="keywords.html#SHAPE">shape</a> and is its origin for a sphere, 
its lower left corner for a cuboid, and the center of its central circular cross section for a cylinder.
Note that for simulations started from "scratch" (no structural input),
this keyword is mostly irrelevant.
There are two things to consider, though:<br/>
<ol type="a">
  <li>Structural output may be compromised if values are used that are
far away from zero. This is because binary trajectory
files and in particular the strictly formatted PDB-files have finite
representation widths and fixed units (Å or nm)
such that output may be severely compromised (for PDB files, format
adjustments to nonstandard formats are available, see
<a href="keywords.html#PDB_OUTPUTSTRING">PDB_OUTPUTSTRING</a> and
<a href="keywords.html#PDB_INPUTSTRING">PDB_INPUTSTRING</a>). It is therefore
recommended to adjust this keyword such that the minimum and maximum
values for Cartesian coordinates (largest dimension) are symmetric
around the origin of the coordinate system.</li>
  <li>If structural input it used, it is strongly recommended to match
the settings for ORIGIN to that implied in
whatever structural input is provided. In droplet BC, it may otherwise
occur that parts of the system overlap with the ill-placed
droplet boundary and that their internal arrangement is destroyed or
that the simulation explodes during the first few
steps of simulation.</li>
</ol>
Note that the input vector is simply specified as three blank-separated
floating point numbers.<br/>
<h4><a class="NoHi" id="SIZE"><b>SIZE</b></a></h4>
This keyword allows the user to define the size of the simulation
container. Depending on its <a href="keywords.html#SHAPE">shape</a>,
SIZE takes on alternative meanings. If the system volume
is a rectangular cuboid (<a href="keywords.html#SHAPE">SHAPE</a> is 1), a vector of three floating-point
numbers is read in that specifies the three side lengths of the cuboid in the x, y, and z-directions, respectively.
If the system volume
is spherical (<a href="keywords.html#SHAPE">SHAPE</a> is 2), just one real number is needed that specifies the
sphere's radius. Finally, if the system volume
is cylindrical (<a href="keywords.html#SHAPE">SHAPE</a> is 3), two floating point values
are read and assumed to be the radius and height of the cylinder, respectively. 
Note that highly asymmetric
boxes and very short, partially periodic cylinders can place very stringent settings on <a
 href="keywords.html#NBCUTOFF">cutoffs</a> since it is generally
the shortest dimension that matters.<br/>
<h4><a class="NoHi" id="SOFTWALL"><b>SOFTWALL</b></a></h4>
This keyword sets the harmonic force constant both for the
residue-based and the atom-based SWBCs (see <a
 href="keywords.html#BOUNDARY">BOUNDARY</a>). It is to be provided in
units of kcal·mol<sup>-1</sup>Å<sup>-2</sup>
and corresponds to parameter k<sub>BND</sub> in the equations above. It is currently
not possible to disable the evaluation of this potential by setting SOFTWALL to zero. Both very 
small and very big values can be detrimental to a simulation by producing an ill-defined
volume (small values) and creating large forces (big values), respectively.<br/>
SOFTWALL also serves as the (completely analogous) force constant for inner system boundaries
added by means of the <a href="keywords.html#SC_OSMO">compartmentalization potential</a>.
<br/>
<br/>
<br/>
<h3><a class="NoHi" id="integrator_controls">Integrator Controls (MD/BD/LD/Minimization):</a></h3>
<hr style="width: 100%; height: 2px;"></hr> (<a href="keywords.html#TOP">back to top</a>)<br/>
<h4><a class="NoHi" id="TIMESTEP"><b>TIMESTEP</b></a></h4>
If any <a href="keywords.html#DYNAMICS">dynamics</a>-based (including
hybrid methods of course) method is used, this keyword lets the
user set the integration time step for the integrator in units of ps.<br/>
<h4><a class="NoHi" id="CARTINT"><b>CARTINT</b></a></h4>
This keyword determines - at a very fundamental level - the choice of
degrees of freedom that CAMPARI shall sample.
The "native" CAMPARI degrees of freedom are the rigid-body coordinates
of all molecules and a subset of internal coordinates
(almost exclusively freely rotatable dihedral angles). This option is
the default and specified by choosing 1 for this keyword.
Alternatively, the Cartesian positions of all atoms in the system may
serve as the underlying degrees of freedom as is commonly
the case in molecular dynamics calculations (option 2).
There are several very important limitations and considerations that are mentioned
throughout the documentation and reiterated here.
<ol type="a">
  <li>CAMPARI does not support the direct sampling of Cartesian degrees
of freedom in Monte Carlo simulations. This applies
to the MC portion of <a href="keywords.html#DYNAMICS">hybrid
simulations</a> as well. While it is trivial to design
and implement simple move sets doing precisely that, their efficiency
is negligible due to the large
amount of motional correlation present between an atom and its
immediate molecular environment.</li>
  <li>Internal space simulations do not require the full amount of
bonded interaction parameters that are typically part of molecular
mechanics force fields, specifically no bond length terms, and
typically no or very few improper dihedral and bond angle terms (→ <a
 href="parameters.html#PARAMETERS">PARAMETERS</a>).</li>
  <li>For freely rotatable dihedral angles, there is a distinction between those deemed important
<i>vs.</i> those deemed unimportant. Details are listed in the documentation
for <a href="inputfiles.html#FMCSC_SEQFILE">providing sequence input</a>. These choices
generally pertain to methyl groups and/or to bonds describing electronically hindered rotations
with identical groups. The resultant sets of degrees of freedom are not always entirely consistent 
(<i>.e.g.</i>, between polypeptide sidechains and their respective small molecule model compounds). 
Related keywords are <a href="keywords.html#OTHERFREQ">OTHERFREQ</a> (MC) and 
<a href="keywords.html#TMD_UNKMODE">TMD_UNKMODE</a> (dynamics).</li>
  <li>While unsupported residues pose no problems in the setup of Cartesian coordinates,
internal coordinate space simulations need to infer which dihedral angles are rotatable
from the input topology. This happens automatically and is described <a href="keywords.html#PDB_TEMPLATE">elsewhere</a>.
For eligible dihedral angles not identified with standard polypeptide or polynucleotide backbone angles,
relevant keywords are again <a href="keywords.html#OTHERFREQ">OTHERFREQ</a> (MC) and 
<a href="keywords.html#TMD_UNKMODE">TMD_UNKMODE</a> (dynamics).</li>
  <li>The choice of degrees of freedom in internal coordinate space
simulations can be customized rather flexibly by introducing
additional constraints (see corresponding <a
 href="inputfiles.html#FRZFILE">input file</a>). For MC simulations,
 the <a href="keywords.html#PSWFILE">preferential sampling utility</a> offers an additional
level of control.</li>
  <li>Conversely, algorithms to enforce holonomic constraints in
Cartesian space simulations are often limited
to weakly coupled constraints (see <a href="keywords.html#SHAKEMETHOD">SHAKEMETHOD</a>
for details). This means that it is not (yet) possible to mimic
torsional space constraints in a Cartesian space run but that it <b>is</b>
possible to follow a typical MD protocol by simulating a flexible
macromolecule with some
bond length constraints in a bath of rigid water molecules.</li>
  <li>The existence of virtual sites (effectively atoms with no mass) poses 
stringent requirements to Cartesian dynamics, in that those sites have to 
be constrained exactly relative to real atoms. At each integration time step, the
forces acting on these sites are transferred to the surrounding atoms, and their positions 
are rebuilt <i>post facto</i> (see <a href="keywords.html#SHAKEMETHOD">elsewhere</a> for
more details). Virtual sites in internal coordinate space simulations can only
cause issues if a degree of freedom's effective mass depends solely on such sites.
Then, CAMPARI will automatically freeze the corresponding degree of freedom.</li>
</ol>
<br/>
<h4><a class="NoHi" id="TSTAT"><b>TSTAT</b></a></h4>
This keyword lets the user choose the thermostat to be used to generate
an NVT (or NVT-like) ensemble
in dynamics simulations using a Newtonian formalism (option 2 or 5 in <a
 href="keywords.html#DYNAMICS">DYNAMICS</a>). Currently, three options
are fully supported:<br/>
<ol>
  <li>Berendsen weak-coupling scheme (<a href="references.html#ref12_1">reference</a>):<br/>
This is a deterministic and global velocity rescaling scheme which
creates an exponential
relaxation toward the target temperature. The velocity rescaling factor
is computed for
each coupling group (see <a href="keywords.html#TSTAT_FILE">TSTAT_FILE</a>)
according to:<br/>
f<sub>v,i</sub><sup>2</sup> = 1.0 + (δ<sub>t</sub>/τ<sub>T</sub>)·[ (T<sub>target</sub>/T<sub>i</sub>)
- 1.0 ]<br/>
As is apparent, whenever the instantaneous group temperature (T<sub>i</sub>)
matches the ensemble target (T<sub>target</sub>),
velocities are not rescaled (f<sub>v,i</sub> is unity). Any deviations
from T<sub>target</sub> will lead to a systematic rescaling for all
velocities that are part of the coupling group toward the target with a
relative decay rate of τ<sub>T</sub> (→ <a
 href="keywords.html#TSTAT_TAU">TSTAT_TAU</a>). If τ<sub>T</sub>
approaches the
discrete time step (δ<sub>t</sub>), the relaxation becomes
instantaneous.
Note that the coupling of subparts of the system to essentially
different thermostats is a largely obsolete method
used in early days of simulations to prevent <a href="references.html#ref12_5">obscure freezing events</a>
sometimes encountered when the system is effectively partitioned into
subsystems
with very different levels of integrator stability, noise, and inherent
relaxation. Then such an approach may circumvent the most dramatic
pitfalls resulting
from the inherent incorrectness of the weak-coupling scheme (and
masking said incorrectness in the process). It is <b>crucially</b> important to
realize that the Berendsen thermostat does not generate a well-defined ensemble and
that the method only relaxes "safely" to the
microcanonical one for τ<sub>T</sub> approaching infinity. The quenched
fluctuations observed in the Berendsen scheme may severely distort results on
fluctuation-sensitive computations
such as free energy growth calculations (see <a
 href="keywords.html#GHOST">GHOST</a>). Since the Berendsen scheme is a global coupling
scheme, it is compatible with <a href="keywords.html#SHAKESET">holonomic constraints</a>
but prone to equipartition artifacts (see option 4 below) like the freezing of subparts of the system
mentioned above. Global thermostats are generally
good at preserving velocity cross-correlations, which is an important property for tightly
coupled systems, <i>e.g.</i> dense, polar liquids. They are also good at absorbing
integrator (discretization) error.</li>
  <li>Andersen scheme (<a href="references.html#ref12_2">reference</a>):<br/>
The Andersen thermostat is a stochastic thermostat which
introduces "collisions" re-randomizing the velocity associated with a
given degree of freedom to one coming from the ensemble at that given
temperature. This method is shown to sample the canonical ensemble and
one of the recommended options for any calculation sensitive to the
details of ensemble
fluctuations. Implementation-wise, it works by re-assigning the
velocity for each degree of freedom at each time step with a
probability equivalent to δ<sub>t</sub>/τ<sub>T</sub>. This effectively
gives rise to a "bath"-induced relaxation over a timescale τ<sub>T</sub>. Note that
implementations in other software packages may synchronize the application of
these velocity resets. This is not the case in CAMPARI
where each degree of freedom is treated independently. In <a href="keywords.html#CARTINT">Cartesian space</a>,
this means that each dimension for every atom is coupled individually, <i>i.e.</i>,
the velocity resets are uncoupled. As a consequence, the Andersen thermostat as implemented
currently is incompatible with <a href="keywords.html#SHAKESET">holonomic constraints</a>
(while the constraints are maintained, their imposition systematically bleeds
kinetic energy from the resets leading to an artificial cooling). 
Without constraints and much like in Langevin dynamics, a remaining concern here can be the artificial
loss of velocity correlations between multiple
particles. Unlike in Langevin dynamics, however, the stochastic process is uncoupled and instantaneous, which
has an additional downside. If there are noticeable discretization errors (there usually is), one cannot rely
on the Andersen thermostat to absorb them in the same way that a globally coupled thermostat does. 
This is (most likely) because errors accumulating locally must also be dissipated locally where in a global
scheme they are dissipated globally.</li>
  <li>Extended ensemble methods:<br/>
Methods such as those by <a href="references.html#ref12_8">Nosé</a>-<a href="references.html#ref12_9">Hoover</a>,
<a href="references.html#ref12_6">Martyna-Tobias-Klein</a>, or
<a href="references.html#ref12_7">Stern</a> are currently <b>not</b> supported,
but may be in the future. They often show poor relaxation behavior
due to coupled oscillations in particular in the NPT ensemble, which
they are most useful for.</li>
  <li>Bussi <i>et al.</i> scheme (<a href="references.html#ref12_3">reference</a>):<br/>
This thermostat can be thought of as a hybrid
approach of the Nosé-Hoover and Berendsen thermostats.
It preserves the exponential relaxation kinetics of the weak-coupling
scheme if the ensemble target is far away but introduces fluctuations
to the kinetic energy such that at equilibrium the global re-scaling
does not quench fluctuations. This thermostat is currently the one offering the
most general support for different classes of system and different
types of <a href="keywords.html#CARTINT">degrees of freedom</a> and thus the recommended option in most applications.
The implementation is that of evolving
the kinetic energy via an auxiliary stochastic dynamics much like the
Langevin piston for pressure coupling does. Here:<br/>
f<sub>v,i</sub><sup>2</sup> = e<sup>-δ<sub>t</sub>/τ<sub>T</sub></sup>
+ f<sub>T,i</sub>(1 - e<sup>-δ<sub>t</sub>/τ<sub>T</sub></sup>)
(R<sub>1</sub><sup>2</sup> + R<sub>Γ,N<sub>f,i</sub>-1</sub>) + 2e<sup>-0.5δ<sub>t</sub>/τ<sub>T</sub></sup>·R<sub>1</sub>[
f<sub>T,i</sub>(1 - e<sup>-δ<sub>t</sub>/τ<sub>T</sub></sup>) ]<sup>0.5</sup><br/>
With:<br/>
f<sub>T,i</sub> = N<sub>f,i</sub><sup>-1</sup>·(T<sub>target</sub>/T<sub>i</sub>)<br/>
Here, N<sub>f</sub> is the number of degrees of freedom in the
respective coupling group, R<sub>1</sub> is a normal random number with
mean of zero
and unity variance, and R<sub>Γ,N<sub>f,i</sub>-1</sub> is a random
number drawn from the gamma distribution with outside scale factor of
2.0 and shape of (N<sub>f,i</sub>-1)/2. Like any thermostat acting globally, there is a higher risk
for equipartition artifacts than for thermostats/methods that couple degrees of freedom individually.
Equipartition artifacts are generally more likely to occur in weakly coupled and inhomogeneous systems, <i>e.g.</i>,
a peptide in a bath of ions in an implicit solvent model.</li>
</ol>
The user is reminded again that this keyword is ignored for all
simulations not relying on explicit thermostats (like Monte Carlo or
stochastic dynamics runs
→ <a href="keywords.html#DYNAMICS">DYNAMICS</a>).<br/>
<h4><a class="NoHi" id="TSTAT_TAU"><b>TSTAT_TAU</b></a></h4>
If the simulations is performed in the <a href="keywords.html#ENSEMBLE">NVT
-ensemble</a> and if <a href="keywords.html#DYNAMICS">Newtonian
dynamics</a>
are used, this keyword allows the user to set the key parameter of the
employed thermostat, <i>i.e.</i> its coupling (decay) time, τ<sub>T</sub>,
in
units of ps (the default is 1.0ps). Note that it is really the ratio of the time step δ<sub>t</sub>
(see <a href="keywords.html#TIMESTEP">TIMESTEP</a>) and this number
that
matters, hence <a href="keywords.html#BOUNDARY">TSTAT_TAU</a> cannot
be less than the integration time step.<br/>
<h4><a class="NoHi" id="TSTAT_FILE"><b>TSTAT_FILE</b></a></h4>
If the simulations is performed in the <a href="keywords.html#ENSEMBLE">NVT
-ensemble</a> and if <a href="keywords.html#DYNAMICS">Newtonian
dynamics</a>
are used, this keyword sets name and location of an optional input file
for defining thermostat coupling groups.
These are meaningful only if the Berendsen weak-coupling or the
Bussi <i>et al.</i> scheme is used (options 1 or 4 for <a
 href="keywords.html#TSTAT">TSTAT</a>).
For details, the user is referred to the description of the <a
 href="inputfiles.html#FMCSC_TSTAT_FILE">input file</a> itself.<br/>
<!--<h4><a class="NoHi" id="PSTAT"><b>PSTAT</b></a></h4>
In analogy to <a href="keywords.html#TSTAT">TSTAT</a>, this keyword allows the user to sepcify the choice of manostat
to be used to maintain the pressure in simulations in an isobaric ensemble.<br/>-->
<h4><a class="NoHi" id="SYSFRZ"><b>SYSFRZ</b></a></h4>
This keyword controls the removal of net drift artifacts in
dynamics runs (which are primarily relevant for fully ballistic MD).
Predominantly in
periodic boundary conditions (see <a href="keywords.html#BOUNDARY">BOUNDARY</a>),
it
can happen that all kinetic energy is transferred into global
translations or rotations of the system.
This collective "degree of freedom" is typically friction-free and
therefore represents a stable trap for the
system's kinetic energy to accumulate in. Such behavior will give rise
to grossly misleading results
(the effective ensemble sampled has a much lower temperature). This can
be avoided by periodically removing such global motions. For
translational displacements, this is easy, but for rotational motion
problems
arise if subensembles have access to modes that are quasi friction-free
themselves. This is often the case in mixed rigid-body/torsional
dynamics and at the moment not dealt with properly.<br/>
Choices are as follows:<br/>
<ol>
  <li>No removal of global motions is performed (the safest setting for
most applications).</li>
  <li>CAMPARI will attempt to only remove translational motion of the
system.</li>
  <li>CAMPARI will attempt to remove both global translation and global
rotation (this option should be used with caution and is also automatically disabled if certain
types of <a href="keywords.html#FRZFILE">constraints</a> are in use).</li>
</ol>
Note that CAMPARI writes drift values (fractions of kinetic energy
consumed by global motions) to the log output in <a
 href="keywords.html#DYNAMICS">dynamics</a>
calculations. This output can be used to diagnose whether drift removal
is necessary and/or working. Importantly, these are the values <i>before</i> application
of the instantaneous correction, <i>i.e.</i>, they will not typically be completely
negligible (this depends on the <a href="keywords.html#DYNAMICS">dynamics equation in use</a>,
<a href="keywords.html#TSTAT">temperature coupling</a>, the directionality of forces, <i>etc.</i>).
Note that drift corrections are more difficult to interpret in the presence of any external
potentials, <i>i.e.</i>, those that depend on absolute spatial coordinates (currently these
are possible <a href="keywords.html#BOUNDARY">boundary potentials</a>, <a href="keywords.html#SC_EMICRO">spatial density restraints</a>,
and <a href="keywords.html#SC_OSMO">compartmentalization potentials</a>.<br/>
<h4><a class="NoHi" id="TMD_INTEGRATOR"><b>TMD_INTEGRATOR</b></a></h4>
If a simulation is performed in <a href="keywords.html#CARTINT">mixed torsional/rigid-body space</a>
that contains a <a href="keywords.html#DYNAMICS">Newtonian dynamics</a> portion, then
this keyword allows the user to choose between (currently) two basic integrator variants.
All integrators are derived from the following discrete scheme that relies on the 
<a href="keywords.html#DYNAMICS">aforementioned</a> assumptions, <i>i.e.</i>, a diagonal
mass matrix (equations of motion formally decoupled) and the accuracy/correctness of
the total kinetic energy expressed in terms of this diagonal mass matrix. Then, we can define 
pseudo-symplectic conditions as shown below for a (rotational) degree of freedom with index <i>k</i>:<br/>
<br/>
I<sub><i>k</i></sub>(t<sub>2</sub>)&omega;<sub><i>k</i></sub>(t<sub>2</sub>)<sup>2</sup> -
I<sub><i>k</i></sub>(t<sub>1</sub>)&omega;<sub><i>k</i></sub>(t<sub>1</sub>)<sup>2</sup> - &delta;t
[&omega;<sub><i>k</i></sub>(t<sub>1</sub>) + &omega;<sub><i>k</i></sub>(t<sub>2</sub>) ] F<sub><i>k</i></sub>(t<sub>1.5</sub>) = 0<br/>
<br/>
Here, &delta;t is the <a href="keywords.html#TIMESTEP">integration time step</a>,
I<sub><i>k</i></sub> denotes the diagonal element of the mass matrix for the <i>k</i>th degree of freedom (function of time),
&omega;<sub><i>k</i></sub> is the associated angular velocity, and F<sub><i>k</i></sub> denotes the deterministic force projected
onto this degree of freedom (torque). The projection yielding the torques and the mass matrix elements
 are computed with recursive schemes, <i>i.e.</i>, they operate in linear time with the number of atoms in the molecule (more or less irrespective of 
how many rotatable bonds there are). More information on this recursive scheme can be obtained indirectly
with the help of keyword <a href="keywords.html#TMDREPORT">TMDREPORT</a>. The above scheme defines a quadratic equation that has a maximum of two solutions
for &omega;<sub><i>k</i></sub>(t<sub>2</sub>) (formula omitted).
The correct one must be picked (which may be difficult), and an alternative must be defined
if no solutions are possible. For both purposes, we use a well-defined approximation to the full solution that yields:<br/>
<br/>
&omega;<sub><i>k</i></sub>(t<sub>2</sub>) &asymp;
[I<sub><i>k</i></sub>(t<sub>1</sub>)/I<sub><i>k</i></sub>(t<sub>2</sub>)]<sup>1/2</sup> &omega;<sub><i>k</i></sub>(t<sub>1</sub>)
 + &delta;t F<sub><i>k</i></sub>(t<sub>1.5</sub>)/I<sub><i>k</i></sub>(t<sub>2</sub>)  <br/>
<br/>
This solution is always available and can be used to pick the correct solution amongst two alternatives for
the full quadratic equation (simply as the closer one).
The setting for TMD_INTEGRATOR determines whether the correct solution to the quadratic equation should be used
whenever possible (option 1), or whether the approximation is used exclusively (option 2, which is the default
for historical reasons). As written, the equations still contain the problem that they require knowledge of
I<sub><i>k</i></sub>(t<sub>2</sub>), whereas only the half-step mass matrix elements (which are structural quantities) are
available in a typical leapfrog scheme. If the I<sub><i>k</i></sub> are slowly varying functions in time, a simple approximation
solving this problem is to allow a lag of half a time step:<br/>
<br/>
&omega;<sub><i>k</i></sub>(t<sub>2</sub>) &asymp;
[I<sub><i>k</i></sub>(t<sub>0.5</sub>)/I<sub><i>k</i></sub>(t<sub>1.5</sub>)]<sup>1/2</sup> &omega;<sub><i>k</i></sub>(t<sub>1</sub>)
 + &delta;t F<sub><i>k</i></sub>(t<sub>1.5</sub>)/I<sub><i>k</i></sub>(t<sub>1.5</sub>)  <br/>
<br/>
This is again written for the approximative version (setting 2). The resultant leapfrog integrator is 
extremely simple and efficient, and it is obtained by setting the related keyword
<a href="keywords.html#TMD_INT2UP">TMD_INT2UP</a> to 0. However, at each integration time step, we can also take a
half-step guess using a similar approximation to obtain a value for all the I<sub><i>k</i></sub>(t<sub>2</sub>).
This done by explicitly perturbing the coordinates and recomputing just the mass matrix elements (little additional cost for all but tiny 
or trivial systems).
With the values obtained, we can integrate the second equation above as written (this is obtained by setting
<a href="keywords.html#TMD_INT2UP">TMD_INT2UP</a> to 1). While theoretically more accurate, this variant
can be noisy due to the extrapolation of the masses. In practice, for systems with very small and quickly varying
I<sub><i>k</i></sub> (such as rigid water molecules), performance is similar for all four pairings
(TMD_INTEGRATOR 1 or 2, <a href="keywords.html#TMD_INT2UP">TMD_INT2UP</a>
0 or 1), and reveals that additional corrections are recommended if the rate of change of the I<sub><i>k</i></sub>  is high
(see <a href="keywords.html#TMD_INT2UP">below</a>). Conversely, if the rate of change is negligible,
all possible settings obtainable by combinations of the two keywords mentioned here relax to the exact same
integrator (standard leap-frog in rotational space). This covers the special case of linear (translational)
degrees of freedom, which have constant mass.<br/>
Note that this keyword is currently irrelevant for stochastic dynamics (always uses a derivation analogous 
to the last equation above), but that it is relevant for the <a href="keywords.html#MINI_MODE">stochastic minimizer</a>.
Another crucial keyword relevant to TMD integrators in general is <a href="keywords.html#ALIGN">ALIGN</a>. Specifically
for the Newtonian case, coupling parameters become relevant as well (<a href="keywords.html#TSTAT">TSTAT</a> and
<a href="keywords.html#TSTAT_TAU">TSTAT_TAU</a> in particular).<br/>
<h4><a class="NoHi" id="TMD_INT2UP"><b>TMD_INT2UP</b></a></h4>
If a simulation is performed in <a href="keywords.html#CARTINT">mixed torsional/rigid-body space</a>
that contains a <a href="keywords.html#DYNAMICS">Newtonian dynamics</a> portion, then
this keywords allows the user to control the number of incremental velocity update steps used 
to improve integrator stability for cases with quickly varying elements of the mass matrix (see <a href="keywords.html#TMD_INTEGRATOR">above</a>).
The cases of 0 and 1 have already been covered in the documentation on <a href="keywords.html#TMD_INTEGRATOR">TMD_INTEGRATOR</a>.
The remaining options assume that values for the diagonal elements of the mass matrix at times t<sub>1</sub>, t<sub>1.5</sub>, and t<sub>2</sub>
are available explicitly (as in: computed directly from coordinates) when trying to compute the
updated angular velocity for a degree of freedom at time t<sub>2</sub>. Rather than solving the
velocity update step in one step, the interval from t<sub>1</sub> to t<sub>2</sub> is instead
divided into TMD_INT2UP subintervals, and the velocity is updated incrementally for each subinterval.
If TMD_INT2UP is larger than 2, additional values are obtained by linearly interpolating between
explicit values at the three times. This is why it is recommended to set this keyword to multiples of 2, and this
is also why the added benefit becomes successively smaller. A recommended value is 4.
Note that this <i>only</i> matters for velocity updates, and that the torque is assumed constant over the
entire interval (F<sub><i>k</i></sub>(t<sub>1.5</sub>) <a href="keywords.html#TMD_INTEGRATOR">above</a>). As a result,
this option does not notably alter speed for a system of appreciable size and is not at all
equivalent to a change in <a href="keywords.html#TIMESTEP">integration time step</a>.<br/>
<h4><a class="NoHi" id="TMD_UNKMODE"><b>TMD_UNKMODE</b></a></h4>
If a simulation is performed in <a href="keywords.html#CARTINT">mixed torsional/rigid-body space</a>
with a <a href="keywords.html#DYNAMICS">gradient-based sampler</a> (including minimization), 
then this keyword controls default constraints operating on certain rotatable dihedral angles. A second
function of this keyword occurs in <a href="keywords.html#CCOLLECT">structural clustering</a> using 
a <a href="keywords.html#CDISTANCE">distance function</a> based on dihedral angles (see end of description).
As described for <a href="inputfiles.html#FMCSC_SEQFILE">sequence input</a>, there is
a selection of "native" CAMPARI torsional degrees of freedom that does not include
every rotatable dihedral angle in natively supported residues, and for obvious reasons
does not include any degrees of freedom within unsupported residues.
This keyword therefore controls how to deal with these two categories of additional
degrees of freedom. Options are as follows:<br/>
<ol start='0'>
<li>Only native CAMPARI degrees of freedom are sampled. This will leave any unsupported residues and molecules completely rigid.</li>
<li>In addition to native CAMPARI degrees of freedom, all <a href="keywords.html#PDB_TEMPLATE">identified degrees of freedom in unsupported residues and molecules</a> will be sampled.</li>
<li>In addition to native CAMPARI degrees of freedom, all torsional degrees of freedom in natively supported residues, which are frozen by default, are sampled. This will leave any unsupported residues and molecules completely rigid.</li>
<li>All aforementioned classes of degrees of freedom are sampled.</li>
</ol>
This keyword has a related set of keywords in Monte Carlo simulations (&rarr; <a href="keywords.html#OTHERFREQ">OTHERFREQ</a> <i>etc</i>).
Note that the keyword is only relevant if either additional set of degrees of freedom is nonempty, <i>.e.g.</i>,
simulations of a water/methanol mixture are not affected by different settings for TMD_UNKMODE.
At the residue level, additional control is offered by virtue of <a href="keywords.html#FRZFILE">user-requested constraints</a>.
The combined information on which degrees of freedom are free and which ones are frozen is obtained with keyword
<a href="keywords.html#TMDREPORT">TMDREPORT</a>.<br/>
In the context of <a href="keywords.html#CCOLLECT">structural clustering</a>, this keyword co-controls which 
dihedral angles are eligible as dimensions for a <a href="keywords.html#CDISTANCE">distance function</a>. This applies 
to cases where a custom request is made through the <a href="keywords.html#CFILE">appropriate input file</a>
and to cases where the full dimensionality is ment to be used. Further information is provided
<a href="inputfiles.html#FYCindexinput">elsewhere</a>.<br/>
<h4><a class="NoHi" id="TMDREPORT"><b>TMDREPORT</b></a></h4>
This simple logical keyword enables the printing out of information regarding internal degrees of freedom
(rigid body, torsional). This file is particularly useful for constructing input for a specific input mode
for <a href="inputfiles.html#FMCSC_FRZFILE">custom constraints</a>. For every molecule it lists the index of the
first atom in that molecule ("Ref."), the total number of atoms ("Atoms"), the total mass ("Mass") after applying all patches,
and, if a <a href="keywords.html#DYNAMICS">gradient-based sampler</a> in <a href="keywords.html#CARTINT">torsional space</a> is
in use, information on whether the (up to) 6 rigid body degrees of freedom are frozen or not ("Frozen"). The
order is translation in x, y, and z followed by rotation around x, y, and z axes.<br/>
The output on the dihedral angles in the molecule provides the following information. For each atom that,
in the Z matrix, corresponds to the definition of a relevant (rotatable) dihedral angle, the structure
of the rotation list setup is provided. Specifically, the number of rotating (swiveling) atoms ("Rotat.") is printed out
along with their total mass ("Mass"). It is specified how many of the rotating atoms are unique ("Unique") with
respect to that atom's rotation list a level above in the hierarchy that contains the rotation list for the present
atom entirely ("Parent"). The hierarchy is understood by considering the polymer as a branched chain with a number
of tips and a base of motion. This base of motion is defined by keyword <a href="keywords.html#ALIGN">ALIGN</a>.
Degrees of freedom at the tip have minimal rank (starting at 0) whereas those near the base have maximal rank in
the hierarchy ("Rank"). The hierarchy necessitates a particular sequence of processing the individual degrees of 
freedom ("Order"). The report also provides information on the chemical elements ("Ele.") of the 4 constituent atoms for 
the dihedral angle (the atom defining the dihedral angle comes last) and on whether the degree of freedom is frozen
in torsional space molecular dynamics ("Frozen"). The last bit of information is available only if a
<a href="keywords.html#DYNAMICS">gradient-based sampler</a> in <a href="keywords.html#CARTINT">torsional space</a> is
in use. The report is available irrespective of the type of calculation being performed. Note that keyword
<a href="keywords.html#ALIGN">ALIGN</a>, while conceptually controlling the same thing, is implemented
differently in <a href="keywords.html#movesetcontrols">Monte Carlo moves</a>.
This means that most of the columns are representative
for the Monte Carlo part only if <a href="keywords.html#ALIGN">ALIGN</a> is set to 1. In
<a href="keywords.html#DYNAMICS">hybrid samplers</a>, the dynamics portion takes precedence.<br/>
<h4><a class="NoHi" id="FRZFILE"><b>FRZFILE</b></a></h4>
This keyword specifies name and location (full or relative path) of the
input file for the selection of molecules or residues for which selected degrees
of freedom are to be excluded from sampling by explicit removal from Monte Carlo
sampling lists and/or by not integrating equations of motion for them. This
means that only such degrees of freedom can be constrained that are in fact
explicit degrees of freedom of the sampling scheme in use 
(see <a href="keywords.html#DYNAMICS">DYNAMICS</a> and <a href="keywords.html#CARTINT">CARTINT</a>).
If this keyword is not present, no constraints are going to be used beyond the
system-imposed ones, which may be sampler-dependent. Note that restricting the
<a href="keywords.html#movesetcontrols">Monte Carlo move set</a> defines effective constraints not covered here.
In Cartesian space, explicit constraints to the x, y, and z coordinates of selected atoms
are possible. However, indirect geometric constraints are also supported (differently and independently via
<a href="keywords.html#SHAKESET">SHAKESET</a>).<br/>
The input for explicit constraints is described in detail <a href="inputfiles.html#FMCSC_FRZFILE">elsewhere</a>.
Hard constraints may be necessary for specialized applications, for
example when one attempts to just re-equilibrate the sidechains in a folded protein while leaving
the fold intact. In general, it will be possible to use <b>re</b>straints (see for
example <a href="keywords.html#SC_TOR">SC_TOR</a> or <a
 href="keywords.html#SC_DREST">SC_DREST</a>) as alternatives. Those
allow the selected degrees of freedom to respond and fluctuate around a
stable equilibrium position.<br/>
Note that constraint requests are not entirely arbitrary, and that the level of control
being offered depends on the sampling engine. It is is not possible - for instance - to
constrain just one out of several χ-angles in a protein sidechain in
<a href="keywords.html#DYNAMICS">Monte Carlo simulations</a>. In general, custom constraints
in combination with a <a href="keywords.html#DYNAMICS">hybrid sampling approach</a> may prove 
challenging when trying to match the sampled sets of degrees of freedom between
Monte Carlo and dynamics segments.
Furthermore, introducing constraints may prohibit certain MC samplers from
being applied not just to the residues carrying the constraints but surrounding ones as well (such as
concerted rotation methods → <a href="keywords.html#CRFREQ">CRFREQ</a>) due to underlying
and conflicting assumptions. Lastly, CAMPARI will exit with an error
if user-selected constraints deplete the sampling list for a given MC move type entirely. Here, it is 
requested of the user to explicitly adjust the move set, since otherwise
these moves would have to be converted to another type that is not necessarily
desirable (note that this still happens if moves are requested that the system
simply does not support).<br/>
<h4><a class="NoHi" id="FRZREPORT"><b>FRZREPORT</b></a></h4>
If explicit coordinate constraints are used (→ <a href="keywords.html#FRZFILE">FRZFILE</a>),
this keyword acts as a simple logical whether or not to write out a
summary of the constraints in the system to log-output.<br/>
<h4><a class="NoHi" id="SKIPFRZ"><b>SKIPFRZ</b></a></h4>
If constraints are used (→ <a href="keywords.html#FRZFILE">FRZFILE</a>)
in torsional space simulations,
this keyword gives the user some control
over the calculation of effectively frozen interactions due to
constraints. In Monte Carlo simulations (see <a
 href="keywords.html#DYNAMICS">DYNAMICS</a>),
incremental energies are computed by only considering the parts of the
system
that move relative to one another. This automatically addresses
constraints. Conversely, in dynamics the total system
energy and forces are calculated at each step. If this keyword is set,
interactions between parts that have no chance
of moving relative to one another (relative orientation completely
constrained) will no longer be considered.
Note that the potentials rigorously have to be (at most) pairwise
decomposable for this option
to be available (e.g., the polar term in the ABSINTH implicit solvation
model is <i>not</i>
strictly pairwise decomposable; → <a href="keywords.html#SC_IMPSOLV">SC_IMPSOLV</a>
and <a href="keywords.html#SCRMODEL">SCRMODEL</a>). Usage of this keyword
can significantly
accelerate dynamics runs or minimization runs in heavily constrained
systems (such as ligand
optimizations within a rigid protein binding site). Note that any
reported energies do not contain the frozen contributions either if
this option is chosen.<br/>
<h4><a class="NoHi" id="SHAKESET"><b>SHAKESET</b></a></h4>
It is standard practice in molecular dynamics simulations in <a
 href="keywords.html#CARTINT">Cartesian space</a> to employ
holonomic constraints such that the system evolves according to Gauss's
principle of least constraint. The reader is
referred to the literature as to what exactly constitutes a
time-reversible, symplectic integrator if
holonomic constraints are enforced. In general, it will possible to
formulate an algorithm which at least is drift-free,
has some target precision for the constraints, and is approximately
symplectic when the microcanonical ensemble is in use.<br/>
The idea behind holonomic constraints in molecular dynamics is to
eliminate fast vibrational modes in the system to allow
for a larger integration time step to be used. This keyword allows the
user different choices for which holonomic constraints
to employ as follows:<br/>
<ol>
  <li>No holonomic constraints are used.</li>
  <li>All "native" bonds to terminal atoms with a mass of less than 3.5
a.m.u. are constrained in length. A terminal atom is
defined as any atom bound to exactly one other atom. "Native" means
that only bonds consistent with the assumed molecular topology
(code-internal) are considered. This selection will usually constrain
all bonds to hydrogen atoms.</li>
  <li>All "native" bonds of any type are constrained in length. This
does include bonds formed by virtue of <a
 href="keywords.html#CRLK_MODE">chemical crosslinks</a>.</li>
  <li>All "native" bonds of any type are constrained in length as in
mode 3. In addition, several bond angles are constrained
explicitly. For a molecule free of rings of size 6 or less all bond
angles are constrained (this also constrains improper
dihedral angles at trigonal centers). For molecules with rings of size
6 or less, ring-internal bond angles are generally
omitted. Note that more bond angles can be formulated at a tetrahedral
site than constraints are needed, and that - system-dependent - redundant constraints
may be created (which may be harmful). This option is only supported for the
standard <a href="keywords.html#SHAKEMETHOD">SHAKE constraint algorithm</a>
at the moment.</li>
  <li>This is nearly identical to option 4. However, bond angles are
constrained by additional distance constraints rather than explicitly.
This means this option is theoretically available for constraint
algorithms other than
    <a href="keywords.html#SHAKEMETHOD">SHAKE</a>.</li>
  <li>An <a href="inputfiles.html#FMCSC_SHAKEFILE">input file</a> is
read and used to derive the list of constraints. Note that it is possible to derive
intra- and intermolecular long-distance constraints that way (geometric information will be taken from
starting structure), but that those will very easily cause CAMPARI
to crash.</li>
</ol>
After assembling the initial list, CAMPARI will parse this list and
identify all sets of constraints that are coupled. Choices for how the
actual values for the constrained distances and angles are set are 
provided by keyword <a href="keywords.html#SHAKEFROM">SHAKEFROM</a>.
Two constraints are coupled if any atom is shared. Groups of coupled
constraints have to be solved simultaneously
using some <a href="keywords.html#SHAKEMETHOD">numerical scheme</a>
and analytical solutions are generally not available.
An individual uncoupled constraint can always be solved analytically
and poses no particular difficulties. A specific
case are the three coupled constraints in rigid water molecules, for
which the analytical SETTLE algorithm has been derived. In these
and similar cases, CAMPARI will substitute the numerical scheme with
the analytical version for reasons of efficiency and accuracy regardless
of specifications otherwise. However, in most cases, the constraint set
specified via this keyword will not make water molecules rigid <i>per se</i>,
and for this case a dedicated keywords exists (&rarr; <a href="keywords.html#SETTLEH2O">SETTLEH2O</a>).
Note that the use of virtual sites (sites with no mass) is only permissible
if they have rigid geometry, and if their positions can be constructed
from real atoms with smaller index values. Choices for this keyword, and the
auxiliary keywords <a href="keywords.html#SETTLEH2O">SETTLEH2O</a> and
<a href="keywords.html#SHAKEFILE">SHAKEFILE</a> will have to reflect
this requirement.<br/>
The cost, accuracy, and applicability of constraint algorithms all
scale poorly with the level of coupling. Options
4 and 5 from the list above will therefore be usable only in special
cases (→ <a href="keywords.html#SHAKEMETHOD">SHAKEMETHOD</a>) such as systems
without any rings or planar, trigonal centers. For specific
applications using angle constraints, we strongly recommend defining a minimum
set of distance-based constraints via option 6 above. This has the best chance
to succeed.<br/>
<h4><a class="NoHi" id="SHAKEFILE"><b>SHAKEFILE</b></a></h4>
If <a href="keywords.html#SHAKESET">SHAKESET</a> is set to 6, this keyword specifies
the name and location of the file defining user-selected
holonomic constraints to be enforced during the simulation. Its format
and requirements are documented <a href="inputfiles.html#FMCSC_SHAKEFILE">elsewhere</a>.<br/>
<h4><a class="NoHi" id="SETTLEH2O"><b>SETTLEH2O</b></a></h4>
This keyword allows the user to append/modify the constraint set selected
via <a href="keywords.html#SHAKESET">SHAKESET</a> to replace all preexisting
constraints acting on three-, four-, or five-site water molecules (SPC, TIP3P, TIP4P, TIP4P-Ew, or TIP5P)
with constraints that completely rigidify each water molecule. It acts as a simple logical
and is turned on by default since CAMPARI as of now does not support explicitly any
inherently flexible water models. This means that a setting of 2 or 3 
<a href="keywords.html#SHAKESET">SHAKESET</a> for a calculation in explicit water
will still constrain waters to be rigid, and therefore correspond to
a standard (and - for the supported water models - correct) simulation setup. Specifying this keyword and setting it to 
anything else but 1 will disable this override. Note that for water models possessing virtual sites (all
four- and five-site models), it is assumed that the extra sites have no mass (see 
<a href="keywords.html#SHAKEMETHOD">below</a>). If this is not the case, the use
of the analytical SETTLE algorithm for water is no longer possible, and the more complex set
of constraints may no longer be solved efficiently (or may no longer be solved at all).<br/>

<h4><a class="NoHi" id="SHAKEFROM"><b>SHAKEFROM</b></a></h4>
This keyword allows the user to control how the actual values for the <a href="keywords.html#SHAKESET">set of holonomic
constraints</a> are determined at the beginning of simulations in <a href="keywords.html#CARTINT">Cartesian space</a>.
There are currently the following options:
<ol>
<li>Irrespective of <a href="keywords.html#PDBFILE">structural input</a>, all distance constraints
of atoms bound covalently to one another are taken directly from the (hard-coded) CAMPARI
default geometries that use, wherever possible, databases of high-resolution crystallographic
structures of biomolecules (see for example the reference by <a href="references.html#ref17_1">Engh and Huber</a>).
For indirect angle constraints, <i>i.e.</i>, constrained distances of atoms separated by two covalent bonds,
the bond angle and two bond lengths in question are used to compute the effective length in similar 
fashion. For explicit angle constraints the reference value can be used directly.
Lastly, simulations of <a href="keywords.html#PDB_TEMPLATE">unsupported residues</a> require the structural
input to be used directly (see comments on option 3 below for implied caveats). This option is currently
the default.</li>
<li>Irrespective of <a href="keywords.html#PDBFILE">structural input</a>, CAMPARI will try to reconstruct
the required constraint lengths from the minimum positions of bonded potentials (see 
<a href="keywords.html#SC_BONDED_B">SC_BONDED_B</a> and <a href="keywords.html#SC_BONDED_A">SC_BONDED_A</a>)
that are provided by the <a href="keywords.html#PARAMETERS">force field in use</a>. As for option 1,
this extends to indirect and explicit angle constraints. If terms are missing in the force field,
covalent distances are taken from the default CAMPARI geometry as for option 1. This option is the
recommended one for "standard" molecular dynamics calculations. Note that  <a href="keywords.html#BPATCHFILE">patches to 
bonded parameters</a> are recognized and respected in this context.</li>
<li>CAMPARI takes all reference values for constrained degrees of freedom directly form the structure
the simulation is started in. This requires no adjustments but comes with caveats. 
Since input in pdb format is of limited precision, the various bond lengths and angles can only
be extracted to the same precision. This means that constraints that are chemically identical will be 
set to slightly different values (<i>e.g.</i>, the C-H bonds in a methyl group), which can cause
small artifacts. For bond lengths involving hydrogen, rebuilding is an alternative
to circumvent this problem (see <a href="keywords.html#PDB_HMODE">PDB_HMODE</a>). A second
problem arises due to the lack of reproducibility caused by the limited precision. Specifically,
simulations started from two different and minimized conformations of the system will end up using different
values for the constraints. A more extreme version of this problem is encountered when starting simulations from
snapshots of other simulations, in which the constrained degrees of freedom had been left free to move 
(this exceeds the mere precision effect). Due to these caveats, it is not recommended to use this option.
Note that CAMPARI will have to use values defined by <a href="keywords.html#PDBFILE">structural input</a>
for cases where no other information is available.</li>
</ol>
With file-based input to  <a href="keywords.html#SHAKESET">SHAKESET</a>, it is possible to constrain
distances between atoms that are not connected by just one or two covalent bonds. Since neither CAMPARI
nor force fields prescribe "correct" distances to such pairs, a constraint of this type is always
dependent on <a href="keywords.html#PDBFILE">structural input</a> (if input is absent, the initial
geometry generated by CAMPARI according to settings for <a href="keywords.html#RANDOMIZE">RANDOMIZE</a>
is used, which is rarely useful).<br/> 
When <a href="keywords.html#RESTART">restarting simulations</a>, this keyword should generally be left unchanged.
In case of option 3 being in use, it is recommended to either never supply an <a href="keywords.html#PDBFILE">input pdb file</a>
or to always use the same one supplied as a <a href="keywords.html#PDB_TEMPLATE">template</a>.
For a simulation started normally, options 1 and 2 above entail the possibility that constrained degrees of 
freedom are adjusted before the simulation begins. This adjustment is reflected in the reference
structure files written at the beginning of each run (<a href="outputfiles.html#basename_START.pdb">{basename}_START.pdb</a>
and <a href="outputfiles.html#basename_START.int">{basename}_START.int</a>).<br/>
<h4><a class="NoHi" id="SHAKEMETHOD"><b>SHAKEMETHOD</b></a></h4>
This keyword allows the user to choose which of the currently
implemented algorithms CAMPARI should use to enforce
the chosen <a href="keywords.html#SHAKESET">set of holonomic
constraints</a> during a molecular dynamics simulation in
<a href="keywords.html#CARTINT">Cartesian space</a>. Options are as
follows:<br/>
<ol>
  <li>The standard, iterative SHAKE procedure is used. Coupled
constraints are solved iteratively by assuming independence
and linearity (Newton's method). SHAKE may converge in very few steps to good
accuracy if the coupling is weak (coupling matrix is sparse). This is
the only method that currently supports
explicit constraints on bond angles (see <a
 href="keywords.html#SHAKESET">SHAKESET</a> and <a href="keywords.html#SHAKEATOL">SHAKEATOL</a>).
It is also the only method that allows parallelization of an individual 
constraint group across multiple threads if the
<a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization of CAMPARI</a> is in use,
and if the constraint group is otherwise expected to become a bottleneck.
Due to the use of Newton's method, SHAKE is not guaranteed to converge if the underlying
"landscape" is non-linear due to
the introduction of coupling between constraints. Then convergence is
only guaranteed within a small enough environment
around the actual solution. Therefore, SHAKE places an upper limit on
the time step that can be used even though
it is meant to allow increases of precisely that time step. Nonetheless,
in canonical applications (bond length constraints
only), SHAKE will be a reasonably efficient solution, <i>i.e.</i>, the 
 <a href="keywords.html#SHAKETOL">desired tolerance</a> can usually be 
reached within few steps. The main weakness
of SHAKE and related algorithms is their
inherent inability to enforce planarity at a given site. This is
because at a planar site all bond vectors which form the basis set for
the application of iterative corrections are part of the same plane, <i>i.e.</i>,
it is impossible
to correct an out-of-plane motion using those vectors. Depending on the
exact set of constraints used, SHAKE
will require many steps, not converge at all or converge with limited
accuracy, and occasionally crash if
bond length and angle constraints at a site deem it to be perfectly
planar.</li>
  <li>A mix of the SHAKE and P-SHAKE (see below) algorithms is used in
which P-SHAKE is applied only to those constraint
groups which are internally entirely rigid. Because P-SHAKE, at least as implemented, fails
as a general purpose constraint algorithm, this option is practically obsolete.
It can be enabled for testing purposes with the help of keyword
<a href="keywords.html#FMCSC_UNSAFE">UNSAFE</a>.</li>
  <li>The so-called P-SHAKE (preconditioned SHAKE) procedure is used.
In P-SHAKE, SHAKE is augmented by introducing a pre-conditioning step
which changes the convergence rate from linear to quadratic. The
preconditioning step is a matrix
multiplication essentially forming linear combinations from the bond
vectors in the constraint vectors. Corrections
employed along those new directions minimize the linear error by
decoupling the constraints (within the bounds
of a linear theory → hence the quadratic and not instantaneous
convergence). Unfortunately, this method currently
is implemented either inefficiently or incorrectly and does not usually
offer a discernible improvement. However, it
is also fundamentally flawed as large constraint groups are handled
inefficiently due to the requirement of a full matrix
multiplication that is needed to increment the coordinates at each
iteration step. This operation in P-SHAKE has a cost
of 3·n<sub>p</sub>·n<sub>c</sub> and of only 6·n<sub>c</sub>
in standard SHAKE.
In addition, the matrix used to precondition the procedure, has to be
recalculated frequently if a molecule undergoes
significant conformational changes (currently hard-coded to 100 integration steps).
P-SHAKE is therefore suitable only
for enforcing holonomic constraints in small rigid
or quasi-rigid molecules that can be solved by SHAKE as well.
Just like SHAKE, it fails badly for planar sites (see above).
As a consequence of the above, P-SHAKE can be enabled for testing purposes only with the help of keyword
<a href="keywords.html#FMCSC_UNSAFE">UNSAFE</a> (otherwise CAMPARI terminates). When using P-SHAKE, CAMPARI
may crash without any indicative messages due to failures in the LAPACK 
routines used by the algorithm (see <a href="install.html">installation</a>).</li>
  <li>The LINCS method is used. LINCS is a linear constraint solver
that uses a projection approach. In the end,
a matrix equation needs to be solved which requires the inversion of a
matrix related to the coupling matrix of
the constraints in the group. This is the critical step and grossly
ineffective as a general procedure. For sparse
matrices, however, the inversion can be performed approximately by a
series expansion. It is the order of this
expansion and its applicability that will determine the success and
accuracy of LINCS. LINCS is generally inapplicable
to anything involving bond angle constraints, in particular in all-atom
representation. It will work well
for loosely coupled groups of constraints. Since the accuracy depends
on the unknown convergence properties of an infinite
sum, the accuracy of LINCS cannot be tuned directly to yield a specific
tolerance for satisfying the constraints. Instead, a combination of the<a href="keywords.html#LINCSITER">expansion order</a>
and a <a href="keywords.html#LINCSITER">number of corrective iterations</a> controls the achieved discrepancy.
To make LINCS more comparable to SHAKE in results, CAMPARI will dynamically adjust the former
to achieve the <a href="keywords.html#SHAKETOL">target tolerance</a>. Note
that LINCS currently cannot split the workload for an individual constraint group
across multiple threads if the <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization of CAMPARI</a>
is in use. This can be a performance limitation.</li>
</ol>
Unfortunately, the constraint algorithm often becomes the weakest link in the integration scheme if the
dynamics itself is unstable (for example due to too large an integration
<a href="keywords.html#TIMESTEP">time step</a>). Therefore, not all reported
failures of the SHAKE or LINCS procedures are due to those procedures. Conversely, if highly coupled
constraints are selected via <a href="keywords.html#SHAKESET">SHAKESET</a>, CAMPARI
may produce many warnings pertaining to failed constraint solving attempts that 
are in fact due to the limitations of those algorithms. In such cases, CAMPARI attempts
to subtly change the targets for the constraint values to potentially steer the system
toward conditions where solutions are obtained more easily. This - as may be expected - 
will not usually solve the problem (only delay critical errors), in particular for very large
constraint groups. Ultimately, it will be more useful to consider internal
coordinate space simulations if high-level constraints are desired (&rarr; <a href="keywords.html#CARTINT">CARTINT</a>).<br/>
There is an additional issue that arises when virtual sites (technically atoms with no mass) are 
used, for example in rigid water models like TIP4P. Such sites have to be circumvented by the integration
scheme (displacement is dependent on inverse mass), and therefore they have to be exactly constrained with respect
to the positions of atoms with finite mass. These constraints cannot be solved within the standard
framework (also dependent on inverse mass). Instead, the least constraint solution is obtained by simply
rebuilding the positions of these sites with fixed internal geometry. For this to yield a correct integrator, however,
the forces acting on the sites need to be remapped to the atoms they are connected to. This is 
done by decomposing the Cartesian force acting on the site into internal forces, for which compensating
terms are added to all the atoms comprising the respective internal degree of freedom. This cancels exactly
the net force on the site, and makes integration symplectic. Virtual sites cannot occur in constraint groups
that are handled by a method other than standard SHAKE or SETTLE.<br/>
Note that if the <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization of CAMPARI</a> is 
in use, there are most two levels of parallelization, across constraint groups and within a given
constraint group. The second level is only available with standard SHAKE at the moment.
The first level is balanced dynamically (see <a href="keywords.html#THREADS_DLB_FREQ">THREADS_DLB_FREQ</a> and
related keywords for general information on load balancing in CAMPARI).
<h4><a class="NoHi" id="SHAKETOL"><b>SHAKETOL</b></a></h4>
If SHAKE or P-SHAKE are in use (→ <a href="keywords.html#SHAKEMETHOD">SHAKEMETHOD</a>),
this keyword allows the user
to set the target tolerance for satisfying distance constraints. The
tolerance is relative to the target value of the
constraint. As soon as the maximum deviation is less than this value,
the iteration stops unless it is terminated
earlier for other reasons (→ <a href="keywords.html#SHAKEMAXITER">SHAKEMAXITER</a>).<br/>
If LINCS is in use, this keyword still has meaning even though the
tolerance cannot be set explicitly. Should CAMPARI
find that LINCS with the given settings satisfies the constraints
significantly worse than defined by this keyword,
it will adjust one of the open parameters of the method (→ <a
 href="keywords.html#LINCSORDER">LINCSORDER</a>) in an attempt
to remedy this situation. Similarly, should the opposite occur (LINCS
satisfies constraints significantly more accurately
than the desired tolerance), the parameter will be adjusted in the
opposite direction. All this happens within
sane bounds (2-16).<br/>
<h4><a class="NoHi" id="SHAKEATOL"><b>SHAKEATOL</b></a></h4>
If SHAKE (→ <a href="keywords.html#SHAKEMETHOD">SHAKEMETHOD</a>) is in
use with explicit bond angle constraints
(→ <a href="keywords.html#SHAKESET">SHAKESET</a>), this keyword allows
the user
to set the target tolerance for satisfying angular constraints. The
tolerance is absolute and applies to the
unitless cosine of the respective angle. As soon as both maximum
deviations drop below the threshold tolerances
(see also <a href="keywords.html#SHAKETOL">SHAKETOL</a>) the iteration
stops unless it is terminated earlier for other reasons
(→ <a href="keywords.html#SHAKEMAXITER">SHAKEMAXITER</a>).<br/>
<h4><a class="NoHi" id="SHAKEMAXITER"><b>SHAKEMAXITER</b></a></h4>
If SHAKE or P-SHAKE are in use (→ <a href="keywords.html#SHAKEMETHOD">SHAKEMETHOD</a>),
this keyword allows the user
to alter the maximum number of iterations permissible to the algorithm.
Since poor convergence properties are generally
indicative of a more fundamental problem, increasing the value for
SHAKEMAXITER will rarely be useful. After
exceeding this many steps, the algorithm will simply continue with its
current solution meaning that - for a good case -
constraints will be violated slightly more than specified by <a
 href="keywords.html#SHAKETOL">SHAKETOL</a> and eventually
<a href="keywords.html#SHAKEATOL">SHAKEATOL</a>. Note that CAMPARI will
then adjust the constraint targets in an attempt to rescue a simulation
otherwise doomed. This may not always work and also lead to unwanted
drift. Appropriate warnings
are provided.<br/>
<h4><a class="NoHi" id="LINCSORDER"><b>LINCSORDER</b></a></h4>
If LINCS is in use (→ <a href="keywords.html#SHAKEMETHOD">SHAKEMETHOD</a>),
this keyword allows the user
to define the initial expansion order for the approximate matrix
inversion technique. As mentioned above, the
convergence properties of this approximation are not really known and
prevent LINCS from satisfying an exact tolerance
explicitly. In particular, for a fixed number of <a href="keywords.html#LINCSITER">corrective iterations</a>,
convergence does not improve strongly for comparatively large changes in expansion order.
Thus, CAMPARI adjusts the expansion order dynamically if it find that constraints are satisfied
significantly better or worse than the desired tolerance provided through
<a href="keywords.html#SHAKETOL">SHAKETOL</a>. The allowed range is from 2 to 16,
and relative tolerances below 10<sup>-4</sup> will generally require
a setting of 2 or larger for keyword <a href="keywords.html#LINCSITER">LINCSITER</a>. 
Very small tolerances are feasible and meaningful in CAMPARI since the representation
is entirely in 64-bit floating point precision. Warnings are produced if the tolerance 
is missed, and the average expansion order across all LINCS constraint groups
is reported at the end. If this value is large (in particular, if it is close to 16),
it is strongly recommended to increase <a href="keywords.html#LINCSITER">LINCSITER</a>.<br/>
<h4><a class="NoHi" id="LINCSITER"><b>LINCSITER</b></a></h4>
If LINCS is in use (→ <a href="keywords.html#SHAKEMETHOD">SHAKEMETHOD</a>),
this keyword allows the user to define the number of iterations for correcting
rotational lengthening. Typically, LINCS assumes only one such correction, but
the matrix expansion cannot become arbitrarily precise with a single iteration.
Thus, this keyword, which defaults to 2 in CAMPARI, can be used to alter
the minimum tolerance achievable by LINCS. Since CAMPARI operates entirely in
64-bit floating point precision, <a href="keywords.html#SHAKETOL">meaningful tolerances</a> can be chosen
that are comfortably solvable by SHAKE in few iterations yet for which
LINCSITER being 1 is insufficient.<br/>
CAMPARI will not vary the number of iterations throughout the run, but it 
will vary the <a href="keywords.html#LINCSORDER">expansion order</a> per
constraint group to achieve the <a href="keywords.html#SHAKETOL">desired tolerance</a>.
It thus may be computationally less efficient to set LINCSORDER to 1
(depending on tolerance, system, <a href="keywords.html#TIMESTEP">integration time step</a>, <i>etc.</i>)
as it requires a larger <a href="keywords.html#LINCSORDER">expansion order</a>.<br/>
<h4><a class="NoHi" id="MINI_MODE"><b>MINI_MODE</b></a></h4>
If a <a href="keywords.html#DYNAMICS">minimization</a> run is
performed, this keyword lets the user
select the method of choice. CAMPARI currently supports three canonical
and one nonstandard minimizer. All minimizers can operate either 
in mixed rigid-body/torsional space, <i>i.e.</i>,
the "native" CAMPARI degrees of freedom or in Cartesian space;
&rarr; <a href="keywords.html#CARTINT">CARTINT</a>. However,
there are algorithmic restrictions that the canonical minimizers (options 1-3 below)
only support trivial constraints (see <a href="keywords.html#FRZFILE">FMCSC_FRZFILE</a>),
which is an issue in Cartesian space (rigid water models, <i>etc</i>).<br/>
Let us define <b>γ</b> as a vector of base increment sizes
suitable for each of the degrees of freedom (partitioned into three
classes: rigid-body translation, rigid-body rotation, and dihedral
angles; keywords <a href="keywords.html#MINI_XYZ_STEPSIZE">MINI_XYZ_STEPSIZE</a>,
<a href="keywords.html#MINI_ROT_STEPSIZE">MINI_ROT_STEPSIZE</a>, and <a
 href="keywords.html#MINI_INT_STEPSIZE">MINI_INT_STEPSIZE</a> are
used to specify each element γ<sub>i</sub>). Also, let f<sub>m</sub> be
an outside scaling factor in units of mol/kcal set by keyword
<a href="keywords.html#MINI_STEPSIZE">MINI_STEPSIZE</a>. Lastly, we
introduce a unitless dynamic step length factor λ.
If we now denote the heterogeneous vector of phase space coordinates as
<b>x</b>, and the Hamiltonian is written as U(<b>x</b>),
then we can write how the system is evolved through either one of four
different protocols as follows:<br/>
<ol>
  <li>Steepest-descent:<br/>
    <b>x</b><sub>i+1</sub> = <b>x</b><sub>i</sub> - λ·f<sub>m</sub><b>γ</b>•∇U(<b>x</b><sub>i</sub>)<br/>
Here, "•" denotes the Hadamard (Schur) product, <i>i.e.</i>, simply
the element-by-element multiplication.
Should the new conformation have overstepped in the direction of
steepest descent, λ is iteratively reduced by a constant factor until a
valid
step is found (lower energy). In case of successful steps, λ is
iteratively increased to
improve the efficiency of the procedure if the underlying landscape is
relatively smooth and flat. Successful steps are used as well to
construct an appropriate guess for the initial step size should a
complete reset be necessary.
This mimics a line search.</li>
  <li>Conjugate-gradient:<br/>
    <b>x</b><sub>i+1</sub> = <b>x</b><sub>i</sub> - λ·f<sub>m</sub>
[ <b>γ</b>•∇U(<b>x</b><sub>i</sub>) + f<sub>CG,i</sub><b>d</b><sub>i-1</sub>
]<br/>
f<sub>CG,i</sub> = [ ∇U(<b>x</b><sub>i</sub>)·∇U(<b>x</b><sub>i</sub>)
] / [ ∇U(<b>x</b><sub>i-1</sub>)·∇U(<b>x</b><sub>i-1</sub>) ]<br/>
    <b>d</b><sub>i-1</sub> = <b>γ</b>•∇U(<b>x</b><sub>i-1</sub>) + f<sub>CG,i-1</sub><b>d</b><sub>i-2</sub><br/>
This conjugate-gradient method follows the Polak-Ribiere scheme and
augments the steepest-descent prediction by an additional
term that is estimated according to the suggestion by Fletcher and
Reeves. Much like in steepest-descent, should the new conformation
have overstepped, λ is iteratively reduced by a constant factor until a
valid
step is found (lower energy). In case of successful steps, λ is
iteratively increased analogously
to what is described above.</li>
  <li>Memory-efficient Broyden-Fletcher-Goldfarb-Shanno method (L-BFGS)
according to Nocedal (<a href="references.html#ref7_1">reference</a>):<br/>
    <b>x</b><sub>i+1</sub> = <b>x</b><sub>i</sub> - λ·
[ <b>H</b><sup>-1</sup>·(<b>γ</b>•∇U(<b>x</b><sub>i</sub>)) ]<br/>
This quasi-Newton approach technically employs the inverse of the
Hessian which is typically unknown.
However, the L-BFGS method constructs a numerical
estimate directly for the matrix product <b>H</b><sup>-1</sup>·(<b>γ</b>•∇U(<b>x</b><sub>i</sub>))
from
the recent history of the minimization process. This widely used
recursive two-loop scheme has the advantage of i)
only requiring very few floating point operations, and ii) not
requiring
a running guess for the complete Hessian (inverse or not) due to the
recursive formulation. Note that the inverse Hessian
in our implementation is constructed from
    <b>γ</b>•∇U(<b>x</b><sub>i</sub>), <i>i.e.</i> has units of
mol/kcal throughout, irrespective of which degree of freedom
is considered. This means that the factor f<sub>m</sub> does not show
up in the L-BFGS equation except for the first
step (initially or after a reset) when the steepest-descent
approximation is used (see mode 1).
The usage of (estimated) second derivative information should generally
help inform the minimizer of more useful directions to pursue but step
size limitations and inadequate guesses of the Hessian may render this
potential benefit ineffectual. The reader is referred to the literature
for further details.<br/>
  </li>
  <li><a id="stochastic_minimization"></a>Thermal noise
quasi-stochastic (akin to simulated, thermal annealing):<br/>
This minimizer couples the system to a variable temperature bath. By changing
the coupling parameters, the degrees of freedom are successively brought to
a state consistent with a very low temperature ensemble. A similar quench in
conditions is used in simulated annealing, a general solution strategy
for optimization problems.<br/>
Initially, the system uses a heat bath as defined
by the settings for <a href="keywords.html#TSTAT">TSTAT</a> and <a
 href="keywords.html#TEMP">TEMP</a>.
The system is then evolved using NVT <a href="keywords.html#DYNAMICS">molecular
dynamics</a> in either <a href="keywords.html#CARTINT">mixed rigid-body/torsional space or Cartesian</a>
space. Depending on initial conditions, this may heat up the system to
a variable extent, and the maximum temperature is recorded.
After a <a href="keywords.html#MINI_SC_HEAT">prescribed fraction</a>
of the <a href="keywords.html#NRSTEPS">total simulation steps</a>, 
the target temperature is successively lowered to the value specified 
by keyword <a href="keywords.html#MINI_SC_TBATH">MINI_SC_TBATH</a>. 
This interpolation uses a Gaussian function on the normalized time axis such
that all interpolation curves can be rescaled in temperature to exactly coincide.
Simultaneously, the algorithm measures the rate in change of temperature from
the recorded maximum toward <a href="keywords.html#MINI_SC_TBATH">MINI_SC_TBATH</a>.
If the actual rate appears too slow or too fast, the time constant, 
τ<sub>T</sub>, of the thermostat in use (→ <a
 href="keywords.html#TSTAT_TAU">TSTAT_TAU</a>)
is successively altered so as to achieve a cooling down of the system
to a negligible temperature within the remaining number of available
iterations. These alterations happen within bounds of 10 times the
<a href="keywords.html#TIMESTEP">integration time step</a> on the low 
end and the original setting for <a href="keywords.html#TSTAT_TAU">TSTAT_TAU</a> on the high end.<br/>
This minimization approach employs two convergence criteria as soon as
the number of steps
specified via <a href="keywords.html#MINI_SC_HEAT">MINI_SC_HEAT</a>
has passed.
During the cooling schedule, the procedure will stop either because the
RMS-gradient fell below the threshold (→ <a
 href="keywords.html#MINI_GRMS">MINI_GRMS</a>) or
because the target temperature (<a href="keywords.html#MINI_SC_TBATH">MINI_SC_TBATH</a>)
was
reached which - <i>per se</i> - does not provide information
on the local gradient. Of course, it may be possible to minimize such a
structure
further using a canonical approach. Both temperature and RMS-gradient
are written to log-output to allow for easy inspection whether the parameters are set reasonably
well. As an additional note it must be pointed out that
- much like in standard molecular dynamics - runs starting from very
unfavorable structures will cause large accelerations which may lead to
a catastrophic blow-up of the system. This behavior can be avoided by performing a number of
steepest descent minimization moves upfront.
This number is set by keyword <a href="#MINI_SC_SDSTEPS">MINI_SC_SDSTEPS</a>.</li>
</ol>
<br/>
In general a minimization run will terminate after either the
maximum number of iterations has passed (see <a
 href="keywords.html#NRSTEPS">NRSTEPS</a>) or after convergence is
achieved (see <a href="keywords.html#MINI_GRMS">MINI_GRMS</a>). Note
that bad combinations of the various step sizes and the convergence
criterion can easily lead to non-terminating
runs even if convergence is achieved <i>de facto</i>.<br/>
In general, minimizations are unlikely to be interesting for on-the-fly analysis. This is because
the conformations encountered do not correspond to a meaningful ensemble: neither
in terms of coverage nor in terms of relative weights. Nevertheless, all 
analysis routines are supported and will work assuming that a single step
corresponds to a single successful perturbation doing minimization (due to overstepping,
the number of energy/gradient evaluations in minimization is usually larger
than the actual number of steps: keyword <a href="keywords.html#NRSTEPS">NRSTEPS</a> sets
the maximum for the former).<br/>
<h4><a class="NoHi" id="MINI_STEPSIZE"><b>MINI_STEPSIZE</b></a></h4>
If a canonical <a href="keywords.html#DYNAMICS">minimization</a> run
is performed, this keyword acts as a scale factor applied to all
conformational increments applied during minimization. It therefore
sets the global step size and corresponds to factor f<sub>m</sub> in
the equations <a href="keywords.html#MINI_MODE">above</a>.
It - for technical reasons - has units of mol/kcal to eliminate the
energy units of
the normalized gradients. There are no canonical rules one can
formulate but values significantly less than unity
will typically be most appropriate to avoid that the algorithm
frequently oversteps in a subset
of the degrees of freedom and then has to iteratively reduce the step
size. However, step size management
is dynamic (consult factor λ introduced in the equations for
minimization modes 1-2(3)
<a href="keywords.html#MINI_MODE">above</a>). This means that the
impact this keyword has may
be less than what one would generally expect.<br/>
<h4><a class="NoHi" id="MINI_GRMS"><b>MINI_GRMS</b></a></h4>
If a <a href="keywords.html#DYNAMICS">minimization</a> run is
performed, this keyword allows the user to set the convergence
criterion in units of kcal/mol. Since minimization runs can occur
in <a href="keywords.html#CARTINT">torsional and rigid-body space</a>,
the "raw" gradient over all degrees of freedom is
unsuitable. CAMPARI utilizes a simple workaround
by normalizing all gradients by a basic step size for the respective
types of degrees of freedom
(see keywords <a href="keywords.html#MINI_XYZ_STEPSIZE">MINI_XYZ_STEPSIZE</a>,
<a href="keywords.html#MINI_ROT_STEPSIZE">MINI_ROT_STEPSIZE</a>,
and <a href="keywords.html#MINI_INT_STEPSIZE">MINI_INT_STEPSIZE</a>).
The resultant, normalized gradient is used to
obtain its root mean square (→ GRMS) which is compared to the
convergence criterion provided here. Since the normalized gradients
assume a default step size, this parameter becomes dependent on them.
For unit values for all three base step sizes, values around 10<sup>-2</sup> are
recommended. Conversely, in Cartesian space, only <a href="keywords.html#MINI_XYZ_STEPSIZE">MINI_XYZ_STEPSIZE</a>
is relevant for the gradient criterion.<br/>
<h4><a class="NoHi" id="MINI_XYZ_STEPSIZE"><b>MINI_XYZ_STEPSIZE</b></a></h4>
If a <a href="keywords.html#DYNAMICS">minimization</a> run is
performed, this keyword determines a basic step size to be considered
for all rigid-body translations of molecules and for all Cartesian displacements of 
atoms. This value is to be provided in units
of Å. Note that this keyword determines
the effective initial translation step size in conjunction with <a
 href="keywords.html#MINI_STEPSIZE">MINI_STEPSIZE</a> and that it is
mostly needed to be able to handle the different units occurring when
minimizing in <a href="keywords.html#CARTINT">mixed rigid-body and torsional space</a>.
All translational gradients are normalized by this number such that
numerical estimates of the Hessian (→ <a href="keywords.html#MINI_MOD">BFGS</a>)
or even a meaningful root mean square can be written
(→ <a href="keywords.html#MINI_GRMS">MINI_GRMS</a>). Note that for simulations
in (effective) Cartesian space, it would be possible to combine this parameter
with <a href="keywords.html#MINI_STEPSIZE">MINI_STEPSIZE</a> to a single
step size parameter.<br/>
<h4><a class="NoHi" id="MINI_ROT_STEPSIZE"><b>MINI_ROT_STEPSIZE</b></a></h4>
If a <a href="keywords.html#DYNAMICS">minimization</a> run
in <a href="keywords.html#CARTINT">mixed rigid-body and torsional space</a> is
performed, this keyword determines a basic step size to be considered
for all rigid-body rotations. This value is to be provided in units of
degrees (compare <a href="keywords.html#MINI_XYZ_STEPSIZE">MINI_XYZ_STEPSIZE</a>).<br/>
<h4><a class="NoHi" id="MINI_INT_STEPSIZE"><b>MINI_INT_STEPSIZE</b></a></h4>
If a <a href="keywords.html#DYNAMICS">minimization</a> run
in <a href="keywords.html#CARTINT">mixed rigid-body and torsional space</a> is
performed, this keyword determines a basic step size to be considered
for all dihedral angles. This value is to be provided in units of
degrees (compare <a href="keywords.html#MINI_XYZ_STEPSIZE">MINI_XYZ_STEPSIZE</a>).<br/>
<h4><a class="NoHi" id="MINI_UPTOL"><b>MINI_UPTOL</b></a></h4>
If a <a href="keywords.html#DYNAMICS">minimization</a> run is
performed, and if the <a href="keywords.html#MINI_MODE">BFGS</a>
method is used, this keyword lets the user choose a tolerance criterion
in kcal/mol for accepting
uphill steps. At most ten or <a href="keywords.html#MINI_MEMORY">MINI_MEMORY</a>
(whichever one is smaller) such steps will be tolerated
until a reset of the estimate of the Hessian occurs. This reset will
reorient the (multidimensional) direction back onto a steepest descent
path and the procedure can start anew. This feature is included since
the curvature-based estimate
of the direction in the BFGS method does not always guarantee a
downhill direction (<i>i.e.</i>, the energy resultant upon
a perturbation in such a direction is larger than the current one for
all steps within a finite interval (including arbitrarily small
ones → this is a different problem from "overstepping" for which
step size reductions are employed).<br/>
<h4><a class="NoHi" id="MINI_MEMORY"><b>MINI_MEMORY</b></a></h4>
If a <a href="keywords.html#DYNAMICS">minimization</a> run is
performed, and if the <a href="keywords.html#MINI_MODE">BFGS</a>
method is used, this keyword lets the user choose the memory length for
the running estimate of the Hessian. Since the system will
evolve throughout the minimization, the estimate of the Hessian is of
course a moving target and it will only be useful to include
points from the immediate vicinity in its numerical, gradient-based
estimate. This keyword simply gives the (integer) number of
immediately preceding steps to consider. Note that very long values
will typically be irrelevant since the BFGS procedure will - in rough
landscapes - frequently propose an ill-fated (uphill) direction (see <a
 href="keywords.html#MINI_UPTOL">MINI_UPTOL</a> for
comparison). Such moves will eventually lead to a reset of the estimate
of the Hessian which includes "forgetting" all the memory.
Hence, the effective usable memory length will be limited by the system
as well. Note that the resets are necessary for the BFGS method to
find any minima.<br/>
<h4><a class="NoHi" id="MINI_SC_SDSTEPS"></a><b>MINI_SC_SDSTEPS</b></h4>
If a <a href="#stochastic_minimization">stochastic minimization</a>
run is performed, this keyword allows the user to request the program to
first run the specified number of steps as canonical steepest-descent (SD)
minimization. These SD moves will follow the same parameter settings as described above and are
completely independent of the stochastic steps. Note that these
steps are always skipped if the settings request the use of 
<a href="keywords.html#SHAKESET">holonomic constraints</a> when minimizing in 
<a href="keywords.html#CARTINT">Cartesian space</a>.<br/>
<h4><a class="NoHi" id="MINI_SC_HEAT"></a><b>MINI_SC_HEAT</b></h4>
If a <a href="keywords.html#stochastic_minimization">stochastic
minimization</a> run is performed, this keyword specifies the fraction
of the total number of steps (<a href="#NRSTEPS">NRSTEPS</a>) that are going to be
used to perform NVT dynamics at the user-supplied 
initial <a href="keywords.html#TEMP">temperature</a> and <a href="keywords.html#TSTAT">thermostat</a>
settings. Generally, for an efficient annealing protocol, it is probably 
advisable to combine a large value for this keyword with a high enough temperature and/or a comparatively large
value for the <a href="keywords.html#TSTAT_TAU">thermostat's time constant</a>, τ<sub>T</sub>,
such that NVE dynamics are mimicked over short periods of time (this will lead
to heating in itself). Conversely, for straight minimization, it will be more
appropriate to supply small values in conjunction with tight thermostat settings
and low initial temperature.<br/>
<h4><a class="NoHi" id="MINI_SC_TBATH"></a><b>MINI_SC_TBATH</b></h4>
If a <a href="keywords.html#stochastic_minimization">stochastic
minimization</a> run is performed, this keyword lets the user specify
the target temperature of the bath the system will be coupled to at the very 
end of the run. From the simulation step defined by <a href="keywords.html#MINI_SC_HEAT">MINI_SC_HEAT</a> onward,
the target temperature is interpolated between <a href="keywords.html#TEMP">TEMP</a> and
<a href="keywords.html#MINI_SC_HEAT">MINI_SC_HEAT</a> using a Gaussian function operating
on a normalized time axis. For the protocol to work as intended, it
will not be useful to specify anything but values close to (but not exactly) zero here.<br/>
<br/>
<br/>
<br/>
<h3><a class="NoHi" id="movesetcontrols">Move Set Controls (MC):</a></h3>
<hr style="width: 100%; height: 2px;"></hr> (<a href="keywords.html#TOP">back to top</a>)<br/>
<h4><i>Preamble (this is not a keyword)</i></h4>
A Monte Carlo simulation is a series of biased or unbiased random
perturbation attempts to the system, in which
some moves will be accepted (the Markov chain transitions to a new
microstate) and the others rejected (the Markov chain remains in place)
dependent on some criterion. This <a href="keywords.html#MC_ACCEPT">acceptance criterion</a>
is designed to sample a specific distribution, and the most common example is the
Metropolis criterion designed to produce Boltzmann-distributed ensembles.<br/>
The type of random perturbation attempts possible constitute the
move set, and the resultant microstate transitions are usually
very different from those observed in molecular dynamics (MD). In dynamics, all
unconstrained degrees of freedom evolve simultaneously (high correlation), but in small increments (low
effective step size). In Monte Carlo, one or few degrees of freedom evolve at a given time, but
in step sizes of varying amplitudes. It is not required that individual degrees 
of freedom are all sampled with equal weight (nor would it be clear how to establish this).
The effective sampling weight is determined by three components:<br/>
<ol>
<li>The overall picking frequencies for move types (<i>e.g.</i>, <a href="keywords.html#OTHERFREQ">OTHERFREQ</a>)
are implemented by CAMPARI through a binary decision tree
invoked at each step of the MC simulation. This means that the decisions taken at the root will influence the
actual number of attempted moves of types chosen further up the tree, and that it may be complicated to calculate the
expected numbers of attempts for those moves. This is why formulas are provided. Some totals (attempted and accepted
moves) are reported in the log output at the end.</li>
<li>The organizational unit for a move is often a residue, but not all residue may possess equal numbers of degrees of freedom.
For instance, <a href="keywords.html#CHIFREQ">sidechain moves</a> have a variable number of degrees of freedom they sample
(→ <a href="keywords.html#NRCHI">NRCHI</a>), but the actual numbers per degrees of freedom will not be uniformly distributed since different
residues may have different numbers of χ-angles.</li>
<li>Sampling weights can be adjusted explicitly with the help of the <a href="keywords.html#PSWFILE">preferential sampling utility</a>.</li>
</ol>
If one takes into account that selected degrees freedom may be eligible for different move types (while others are not),
it should be abundantly clear that the details of a Monte Carlo move set are ultimately <i>adhoc</i> or empirical quantities
(see <a href="tutorial4.html">Tutorial 4</a> for additional, theoretical considerations on move sets).<br/>
Because elementary Monte Carlo only change a few degrees of freedom at a time, the algorithms
should be (and usually are) smart enough to only consider an incremental energy change associated with a move. The energy complexity of moves
differs by type (see <a href="references.html#ref4_2">reference</a> for details). The technical complexity with regards
to applying the random perturbation also differs by type and sometimes behaves antagonistically to energy complexity. 
Taken together, these characteristics mean that it is challenging to parallelize a Monte Carlo sampler efficiently.
CAMPARI generally tries to parallelize both coordinate operations and incremental energy calculations and strives to achieve
load balance by explicitly estimating and then splitting the overall load for each significant task.
This involves specialized routines for special move types. Because of the heterogeneity
of MC move sets (and the controls offered over them), it is recommended to always perform a quick scaling check
when using CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a>.<br/>
<br/>
<br/>
<hr/>
<h4><a class="NoHi" id="PARTICLEFLUCFREQ"><b>PARTICLEFLUCFREQ</b></a></h4>
This keyword is relevant only when <a href="keywords.html#ENSEMBLE">ENSEMBLE</a>
is set to either 5 or 6, <i>i.e.</i>, those
ensembles which allow numbers of particles to fluctuate. In this case,
the keyword defines the fraction
of all moves that attempt to sample the particle number dimension of
the thermodynamic state of the system. For the semi-grand ensemble,
this corresponds to attempting to transmute one particle type into
another while preserving the position of the target
particle. For the grand ensemble, it will with 50% probability try to
insert a particle of permissible type in a random location in the
simulation container and with 50% probability attempt to delete a
permissible particle. These moves are applied at the molecule level and
most
closely related to rigid-body moves in terms of complexity (→ <a href="keywords.html#RIGIDFREQ">RIGIDFREQ</a>).<br/>
Technically, the GC ensemble is supported in CAMPARI by maintaining a
set of ghost particles for each fluctuating type which
work as "stand-ins". This framework entails certain limitations which
are detailed <a href="inputfiles.html#FMCSC_PARTICLEFLUCFILE">elsewhere</a>.<br/>
Expected numbers of such moves overall are calculated trivially as:<br/>
<a href="keywords.html#NRSTEPS">NRSTEPS</a> · PARTICLEFLUCFREQ<br/>
Note that the default picking probabilities are such that every molecule type allowed
to fluctuate in numbers receives equal weight. In case of particle permutation moves,
which are implemented as joint insertion/deletion, there is no way to adjust these.
This is because the implementation mandates the molecule types to be different, which would
require additional corrections in the <a href="keywords.html#MC_ACCEPT">acceptance probability</a>,
which would cancel out the preferential sampling weights. For independent insertion and
deletion available in the <a href="keywords.html#ENSEMBLE">grand ensemble</a>, the
<a href="keywords.html#PSWFILE">preferential sampling utility</a> allows the user to at least
adjust the picking probabilities on a per-type basis. This can be relevant for example
in electrolyte mixtures with disparate target concentrations (and correspondingly disparate
bath particle numbers), for which it would make sense to preferentially insert and delete
those particle types with overall larger numbers. Such an adjustment would also bring
the sampling weights in line with the default picking probabilities for
<a href="keywords.html#RIGIDFREQ">rigid-body moves</a>, which are flat on a per-molecule basis.<br/>
<h4><a class="NoHi" id="RIGIDFREQ"><b>RIGIDFREQ</b></a></h4>
This keyword specifies what fraction of all remaining moves (<i>i.e.</i>,
1.0 - <a href="keywords.html#PARTICLEFLUCFREQ">PARTICLEFLUCFREQ</a>)
is to perturb rigid-body degrees of freedom. This encompasses
translations and rotations of individual molecules as well as of groups
of molecules (the latter are only available in case rotation and translation are coupled → <a
 href="keywords.html#COUPLERIGID">COUPLERIGID</a>). The default picking probabilities
are even for all molecules regardless of type, size, or other properties.
They can be adjusted via the <a href="inputfiles.html#FMCSC_PSWFILE">preferential sampling utility</a>,
and this may be relevant in dense or semi-dilute systems with different molecule
types of vastly different size (<i>e.g.</i>, proteins and inorganic ions). In such
a case, the acceptance rates for the macromolecules will be noticeably smaller, and this
could be compensated for by sampling them preferentially.<br/>
<h4><a class="NoHi" id="COUPLERIGID"><b>COUPLERIGID</b></a></h4>
This keyword is a simple logical deciding whether or not to couple
translational and rotational rigid-body moves
for <i>single</i> molecules. Like any type of move coupling, this
means that up to six independent perturbations of
individual degrees of freedom are employed (translation in x,y,z,
rotation around three axes) <b>before</b> energies and the acceptance
criterion are evaluated. Note that molecules with no rotational degrees
of freedom will have their moves counted
as pure translation moves in the log-output.<br/>
<h4><a class="NoHi" id="ROTFREQ"><b>ROTFREQ</b></a></h4>
This keyword can be used to set the sub-frequency for purely rotational
moves if uncoupled moves are used (→ <a
 href="keywords.html#COUPLERIGID">COUPLERIGID</a> is false).
It will then determine the fraction of those rotational moves.
Total number:<br/>
<a href="keywords.html#NRSTEPS">NRSTEPS</a> · (1.0-<a
 href="keywords.html#PARTICLEFLUCFREQ">PARTICLEFLUCFREQ</a>) · <a href="keywords.html#RIGIDFREQ">RIGIDFREQ</a>
 · ROTFREQ.<br/>
And the total number of purely translational moves will be:<br/>
<a href="keywords.html#NRSTEPS">NRSTEPS</a> · (1.0-<a
 href="keywords.html#PARTICLEFLUCFREQ">PARTICLEFLUCFREQ</a>) · <a href="keywords.html#RIGIDFREQ">RIGIDFREQ</a>
 · (1.0-ROTFREQ)<br/>
Note that the above formulas do not account for the choice between
randomizing and stepwise perturbations (→
<a href="keywords.html#RIGIDRDFREQ">RIGIDRDFREQ</a>), which would
introduce an additional factor into the above product.
<h4><a class="NoHi" id="RIGIDRDFREQ"><b>RIGIDRDFREQ</b></a></h4>
This keyword sets a terminal choice in the selection tree that is
common to many of the moves
in CAMPARI (see similar keywords <a href="keywords.html#PIVOTRDFREQ">PIVOTRDFREQ</a>,
<a href="keywords.html#NUCRDFREQ">NUCRDFREQ</a>,
and so on). Amongst the available rigid-body moves (it applies to three
separate branches: coupled single-molecule moves,
coupled multiple-molecule moves, and decoupled single-molecule moves),
the keyword chooses the fraction to completely
randomize the underlying degrees of freedom. For example, the complete
randomization of translational degrees of freedom
would displace the molecule's reference center to an arbitrary point in
the simulation container. The remaining fraction
will correspond to stepwise perturbations in which a usually small
random increment is added to the degrees of freedom in question.
For example, such a move would displace a molecules reference center by
a random vector small in absolute magnitude.<br/>
As an example consider single-molecule translation moves. The total
number of expected randomizing translation moves
would be (assuming <a href="keywords.html#COUPLERIGID">COUPLERIGID</a>
is false):<br/>
<a href="keywords.html#NRSTEPS">NRSTEPS</a> · (1.0-<a
 href="keywords.html#PARTICLEFLUCFREQ">PARTICLEFLUCFREQ</a>) · <a href="keywords.html#RIGIDFREQ">RIGIDFREQ</a> · (1.0-<a
 href="keywords.html#ROTFREQ">ROTFREQ</a>) · RIGIDRDFREQ<br/>
And the number of stepwise translation moves would be:<br/>
<a href="keywords.html#NRSTEPS">NRSTEPS</a> · (1.0-<a
 href="keywords.html#PARTICLEFLUCFREQ">PARTICLEFLUCFREQ</a>) · <a href="keywords.html#RIGIDFREQ">RIGIDFREQ</a> · (1.0-<a
 href="keywords.html#ROTFREQ">ROTFREQ</a>) · (1.0-RIGIDRDFREQ)<br/>
The same modifications apply to any other branch of rigid-body move as
explained above. As an additional complication,
the decision about randomization vs. stepwise perturbations is <b>de</b>coupled
itself in coupled rigid-body moves.
Also note that the log output does not distinguish between the stepwise
and randomizing varieties for any move type.<br/>
Randomizing rigid-body translations have one peculiarity. Unless a spatial dimension
is periodic (see <a href="keywords.html#BOUNDARY">BOUNDARY</a>), the absolute coordinates
in this dimension have no strict bounds, which means that a fully random prior would have to extend to infinity.
If the <a href="keywords.html#SOFTWALL">restraining force</a> of the present
interacting boundaries is not infinitely strong, it therefore gives rise to 
a consistent bias if particles are regularly placed randomly in a volume confined
exactly to the formal definition of <a href="keywords.html#SIZE">system size</a>
(the regions extending beyond this formal size become undersampled).
This bias decreases with increasing restraining force. It is also less noticeable
whenever the boundary potential does not act on just a single atom in the molecule.
If acts on just a single atom for monoatomic "molecules" with an atom-based boundary condition
and for single-residue molecules with a residue-based boundary condition (see <a href="keywords.html#BOUNDARY">BOUNDARY</a>).
In other cases, the bias is less apparent because the translation is applied to the molecule's
geometric center, which in general is more likely to reside in the formal volume than
the outermost atoms/residues. The same reason causes <a href="keywords.html#CLURBFREQ">cluster rigid-body moves</a>
to be affected less as well, To avoid this type of bias,
keyword  <a href="keywords.html#RIGIDRDBUF">RIGIDRDBUF</a> can be used.<br/>
<h4><a class="NoHi" id="ROTSTEPSZ"><b>ROTSTEPSZ</b></a></h4>
For any stepwise perturbation of rotational rigid-body degrees of
freedom, this keywords sets the maximum step size in degrees.
It is implemented such that the actual step size is drawn with uniform
probability from an interval from 0.0° to
ROTSTEPSZ°.<br/>
<h4><a class="NoHi" id="TRANSSTEPSZ"><b>TRANSSTEPSZ</b></a></h4>
For any stepwise perturbation of translational rigid-body degrees of
freedom, this keywords sets the maximum step size in Å.
Analogous to <a href="keywords.html#ROTSTEPSZ">ROTSTEPSZ</a>, it is
implemented such that the actual step size is drawn with
uniform probability from an interval from 0.0 to TRANSSTEPSZ Å.
<h4><a class="NoHi" id="RIGIDRDBUF"><b>RIGIDRDBUF</b></a></h4>
For any <a href="keywords.html#RIGIDRDFREQ">full randomization attempt</a>
in a rigid translation move in the presence of an explicit boundary potential acting on at least one of the coordinates, this keyword sets 
a scale ratio of sampling dimension and the <a href="keywords.html#SIZE">size of the simulation container</a>.
Specifically, this means that the point to be placed, which is the geometric
center of a molecule or a group of molecules, samples from a uniform distribution
inside a container with dimensions that are RIGIDRDBUF times larger than the
formal size specified. For a rectangular box these are the side lengths, for a sphere
it is a radius, and for a cylinder it is the height and the radius. In all cases,
the scale factor applies only to those dimensions, which are 
<a href="keywords.html#BOUNDARY">not periodic</a>, <i>i.e.</i>, which are "closed"
by an explicit boundary potential of <a href="keywords.html#SOFTWALL">controllable strength</a>. The factor
is applied uniformly to all of these eligible dimensions. The default value is 1.0,
and only values greater than or equal to 1.0 are allowed. The computational efficiency 
of these move types decreases with increasing RIGIDRDBUF because an increasing number
of moves will be rejected on account of the boundary potential. 
However, a value of 1.0 introduces systematic biases. Essentially, the full randomization
move is nonergodic and will lead to a systematic underestimation of 
occupancy probabilities for positions with finite values of the boundary potential.
This effect is strongest for the displacement of single-atom molecules
by single-molecule rigid translation moves. Appropriate values for RIGIDRDBUF are those
that effectively mask the bias. These appropriate values depend on
<a href="keywords.html#SOFTWALL">boundary force</a>, <a href="keywords.html#TEMP">temperature</a>,
<a href="keywords.html#SIZE">formal size</a>,
and system composition (see <a href="keywords.html#RIGIDRDFREQ">above</a> for details regarding
the last point).<br/> 
<h4><a class="NoHi" id="CLURBFREQ"><b>CLURBFREQ</b></a></h4>
This keywords sets the fraction of all available coupled rigid-body
moves to simultaneously perturb the rigid-body degrees of freedom of
more
than one molecule in concerted fashion. In other words,
these moves allow the concerted translation (by the same vector) and
rotation (around the "cluster" center-of-mass) of
several molecules in one shot.<br/>
The expected number of multi-molecule moves would be (assuming <a
 href="keywords.html#COUPLERIGID">COUPLERIGID</a> is true):<br/>
<a href="keywords.html#NRSTEPS">NRSTEPS</a> · (1.0-<a
 href="keywords.html#PARTICLEFLUCFREQ">PARTICLEFLUCFREQ</a>) · <a href="keywords.html#RIGIDFREQ">RIGIDFREQ</a> · CLURBFREQ<br/>
And that of coupled single-molecule moves would be:<br/>
<a href="keywords.html#NRSTEPS">NRSTEPS</a> · (1.0-<a
 href="keywords.html#PARTICLEFLUCFREQ">PARTICLEFLUCFREQ</a>) · <a href="keywords.html#RIGIDFREQ">RIGIDFREQ</a> ·
(1.0-CLURBFREQ)<br/>
Currently, the picking of the molecules in a "cluster" is completely
random.
Note that cluster moves in can easily become tricky: In periodic
boundary conditions, the nearest
image and hence the internal structure of the cluster may actually
change upon rotation of a cluster, whereas in
droplet boundary conditions rotations and translations of clusters
formed by distal molecules may incur significant boundary
penalties and hence be inefficient overall. Like all other
rigid-body moves, cluster moves can be stepwise or
completely randomizing (still in concerted fashion). This is all
regulated
by the previously introduced keywords <a
 href="keywords.html#RIGIDRDFREQ">RIGIDRDFREQ</a>,
<a href="keywords.html#ROTSTEPSZ">ROTSTEPSZ</a> and <a
 href="keywords.html#TRANSSTEPSZ">TRANSSTEPSZ</a>. The picking frequencies
are regulated at the molecule level. With the <a href="inputfiles.html#FMCSC_PSWFILE">preferential sampling utility</a>,
it is possible to alter the picking weights on a per-molecule basis. Note that
this should yield either zero or reasonably large weights for all molecules, because
the weights combine in a product sense during the picking process. This also
means that it is tedious to compute the expected sampling
probabilities for all possible "clusters" of molecules of sizes 2 to the
<a href="keywords.html#CLURBMAX">maximum value</a>. These moves are likely
to be replaced by a more efficient variant in the future. In part because of this,
they are (currently) unavailable when using
CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a>.<br/>
<h4><a class="NoHi" id="CLURBMAX"><b>CLURBMAX</b></a></h4>
This keyword sets the maximum "cluster" size for concerted
multi-molecule rigid-body moves (see <a href="keywords.html#CLURBFREQ">CLURBFREQ</a>).
The assignment is
completely random at any given step such that detailed balance is
maintained. Note that the number of possible "clusters" grows as
binomial coefficients with
increasing size of the cluster until CLURBMAX reaches half the number
of molecules in the system. It is important to point out that picking values
close to the number of molecules can cause search problems that CAMPARI
actively avoids. Specifically, if the total sampling weight of available
molecules remaining is less than 10%, a new molecule has not been
found to add to the "cluster" in 100 tries, and the current size is at least 2,
then the value picked initially for CLURBMAX
is decreased to the current size. This is to avoid the code spending
an excessive amount of time in an inefficient search procedure. The control
on total sampling weight is particularly relevant for cases where the picking
weights have been altered on account of the <a href="inputfiles.html#FMCSC_PSWFILE">preferential sampling utility</a>.<br/>
<!--<h4><a class="NoHi" id="CLURBRDFREQ"><b>CLURBRDFREQ</b></a></h4>
This is NOT the fraction of full randomization attempts amongst
all cluster RB moves. Instead, it is a currently meaningless keyword
allowing to choose the subset of cluster moves with
random cluster assignment. The latter is the only option supported at
the moment, however, and therefore this keyword will always be
adjusted to 1.0. <br/>
-->
<h4><a class="NoHi" id="ALIGN"><b>ALIGN</b></a></h4>
This keyword is an integer indicating how to handle the fact that lever
arm
effects can be asymmetric in multimolecular simulations. A brief
explanation is in order.
Consider a macromolecule with multiple dihedral angles along the
backbone. Then, a perturbation
of an individual of those dihedral angles may be implemented in two
basic implementations corresponding to two building directions of the
(unbranched) main chain. Either one of the ends will swivel around
(lever-arm) while the other remains fixed in place. In a simulation
with just a single molecule, the new conformations for either type will
be identical except for an implied rotation of the reference frame. In
a simulation with multiple molecules, however,
the two conformations will be explicitly different since the other
molecules define the now
static reference frame. In general, moves with longer lever-arms will
have lower acceptance
rates and are slower to evaluate and should generally be avoided. For
MC, this affects
polypeptide pivot moves (coupled and uncoupled (see <a
 href="keywords.html#COUPLE">COUPLE</a>)), ω-moves (see <a
 href="keywords.html#OMEGAFREQ">OMEGAFREQ</a>), <a href="references.html#ref14_1">Favrin <i>et al.</i></a> inexact CR
moves (see <a href="keywords.html#CRMODE">CRMODE</a>), pivot-type
nucleic acid moves (see <a href="keywords.html#NRNUC">NRNUC</a>),
sugar pucker moves (see <a href="keywords.html#SUGARFREQ">SUGARFREQ</a>),
and polypeptide cyclic residue
pucker moves (see <a href="keywords.html#PKRFREQ">PKRFREQ</a>). It affects
single torsion pivot moves (see <a href="keywords.html#OTHERFREQ">OTHERFREQ</a>)
in a slightly different manner, and this is described there. It is
also relevant for torsional dynamics
for which it in similar vein determines the assumed building direction
for the chains.
Options are as follows:<br/>
<ol>
  <li>Always leave N-terminus unperturbed (C-terminus swings
around).</li>
  <li>Always leave C-terminus unperturbed (N-terminus swings
around). This is only recommended in special applications since the
C-terminal alignment requires the whole molecule
to be rotated around, which makes this mode more expensive but
analogously asymmetric when compared to mode 1.</li>
  <li>Always leave the longer end unperturbed (shorter lever-arm is
chosen).
This is the default (and a good) choice as it should be the most
efficient one
for simulations with multiple chains of significant length. It is also
the recommended setting for torsional dynamics
in which the kinetics at one of the termini will otherwise be
artificially slowed (note that the criterion determining lever arm
length uses number of atoms rotated rather than number of residues
in dynamics).</li>
  <li>A stochastic modification of mode 3 only available in MC: The
probability with
which the longer end swivels around is equal to:<br/>
p<sub>lt</sub> = (L<sub>st</sub> + 1) / (L<sub>st</sub> + L<sub>lt</sub>
+ 2)<br/>
And conversely:<br/>
p<sub>st</sub> = (L<sub>lt</sub> + 1) / (L<sub>st</sub> + L<sub>lt</sub>
+ 2)<br/>
Here, L<sub>st</sub> is the smaller number of residues beyond the pivot
point towards the nearer terminus
and L<sub>lt</sub> is the larger number of residues beyond the pivot
point towards the more distant terminus such
that L<sub>st</sub>+L<sub>lt</sub>+1 yields the total number of
residues in the molecule.
For example, a molecule with six residues would yield probabilities for
doing C-terminal
alignment (the N-terminus swings around) of 6/7 for residue 1, 5/7 for
residue for residue 2, and so on
down to 1/7 for residue 6.<br/>
This choice represents the most flexible move set and should normally be
preferred
in MC when sampling problems are encountered.</li>
</ol>
Note that the "N"-terminus in polynucleotides is the 5'-end and the "C"-terminus the 3'-end. 
In general, when set to 2 or 3, this keyword may (currently) have slightly different effects in 
torsional dynamics vs. MC calculations. This is because the former considers each polymer
as a generic branched chain, which means that, e.g., in lysine peptide the sidechain
becomes the "terminus" owing to its greater length. As a general rule, terminal dihedral angles
rotating only one or more hydrogen atoms are not considered for alignment regardless
of setting. Additional, terminal dihedral angles may also be excluded in MC.
It is relatively straightforward to extract the convention in use by 
running a short test simulation without rigid-body movement and comparing
initial and final structures.
It should be mentioned that the N-terminal alignment corresponds exactly to the 
way molecules are built (hierarchically) in CAMPARI from their Z-matrix entries,
and that this is a purely technical choice that should not have an impact on 
the thermodynamics of a system.<br/>
<h4><a class="NoHi" id="COUPLE"><b>COUPLE</b></a></h4>
If this keyword is set to 1 (logical true), all polypeptide pivot moves
are coupled to sidechain moves on the same residue (→ <a
 href="keywords.html#PIVOTMODE">PIVOTMODE</a>).
This means that new conformations for the φ- and ψ-angles as well as
for some of the sidechain χ-angles (if any) are proposed before the energy and
acceptance criterion
are evaluated. Like any other unbiased move perturbing multiple degrees
of freedom,
this procedure drastically increases the chance of generating an
unacceptable conformation
(assuming a typical excluded-volume interaction potential is used).
Consequently, acceptance rates will
be very low and it is generally not recommended to use this option.
Note that it is still possible to use independent sidechain moves but
that it is <b>im</b>possible to do
independent pivot moves for residues with sidechains. In other words,
all frequency settings are used as normal but all standard polypeptide
pivot moves (the default
move type of the decision tree) are coupled to a mandatory sidechain
move (of a (sub)set of sidechain angles in that residue). Keywords <a
 href="keywords.html#PIVOTRDFREQ">PIVOTRDFREQ</a>, <a
 href="keywords.html#PIVOTSTEPSZ">PIVOTSTEPSZ</a>, <a
 href="keywords.html#CHIRDFREQ">CHIRDFREQ</a>, <a
 href="keywords.html#CHISTEPSZ">CHISTEPSZ</a>, and <a
 href="keywords.html#NRCHI">NRCHI</a> and all observed in the respective 
parts of the underlying base move types.<br/>
The expected number of those coupled moves would be:<br/>
<a href="keywords.html#NRSTEPS">NRSTEPS</a> · (1.0-<a
 href="keywords.html#PARTICLEFLUCFREQ">PARTICLEFLUCFREQ</a>)
· (1.0-<a href="keywords.html#RIGIDFREQ">RIGIDFREQ</a>) · (1.0-<a
 href="keywords.html#CHIFREQ">CHIFREQ</a>)
· (1.0-<a href="keywords.html#CRFREQ">CRFREQ</a>) · (1.0-<a
 href="keywords.html#OMEGAFREQ">OMEGAFREQ</a>)
· (1.0-<a href="keywords.html#NUCFREQ">NUCFREQ</a>) · (1.0-<a
 href="keywords.html#PKRFREQ">PKRFREQ</a>) · (1.0-<a
 href="keywords.html#OTHERFREQ">OTHERFREQ</a>)<br/>
Note that the same formula applies to uncoupled polypeptide pivot moves.<br/>
<h4><a class="NoHi" id="PIVOTMODE"><b>PIVOTMODE</b></a></h4>
Polypeptide pivot moves are historically the oldest move type in
CAMPARI. Therefore, they are placed at the outermost branch of the move
selection tree and possess no frequency
selection keyword. In general, pivot moves simultaneously sample the φ-
and ψ-angles
of a single polypeptide residue unless the residue is ring-constrained
(such as proline or
hydroxyproline) in which case only the unconstrained degree of freedom
(ψ for proline)
is sampled. See <a href="keywords.html#PKRFREQ">PKRFREQ</a> for
"pivot" moves which sample the φ-angles
of proline and analogous residues. The default picking probabilities
for polypeptide moves are even for all residues with peptide &phi;/&psi;-angles.
They can be adjusted with the help of the <a href="inputfiles.html#FMCSC_PSWFILE">preferential sampling utility</a>.
An example where this can be useful is in reducing the picking weight of 
proline and similar residues, for which the number of degrees of freedom is smaller.<br/>
Mostly for historical reasons, this keyword allows the selection of
different modes for
pivot moves as follows:<br/>
<ol>
  <li>Blind backbone sampling, <i>i.e.</i>, all angles have equal
likelihood (unbiased and the default)</li>
  <li>Using grids (requires <a href="keywords.html#GRIDDIR">GRIDDIR</a>),
<i>i.e.</i>, angle pairs are sampled come from within an approximate envelope derived from the space available 
to the corresponding dipeptide if one assumes typical excluded volume interactions (biased).</li>
</ol>
The second option is an attempt to improve conformational space
sampling but introduces bias. It is not fully supported at the moment and may be removed entirely in
the future.<br/>
<h4><a class="NoHi" id="PIVOTRDFREQ"><b>PIVOTRDFREQ</b></a></h4>
Much like for other move types, CAMPARI allows the user to mix two
types of polypeptide pivot moves: the first randomizing the φ- and
ψ-angles of the residue
in question (for proline only the ψ-angle, for coupled moves also the
sidechain
χ-angles → <a href="keywords.html#COUPLE">COUPLE</a>), the second
perturbing
them by a small increment whose size is set by the auxiliary keyword
<a href="keywords.html#PIVOTSTEPSZ">PIVOTSTEPZ</a>.
Note that randomizing moves may be extremely ineffective for the
sampling
of dense phases (collapsed states of macromolecules) and that the only
accepted
moves will be those realizing small displacements by chance.<br/>
To calculate the expected number of randomizing and stepwise
polypeptide pivot moves,
the user may employ the formula listed under <a
 href="keywords.html#COUPLE">COUPLE</a>
and multiply it with PIVOTRDFREQ and 1.0-PIVOTRDFREQ, respectively.<br/>
<h4><a class="NoHi" id="PIVOTSTEPSZ"><b>PIVOTSTEPSZ</b></a></h4>
This keyword sets the step size in degrees for local perturbation
attempts
to the φ- and ψ-angles of polypeptide residues (see <a
 href="keywords.html#PIVOTRDFREQ">PIVOTRDFREQ</a>). Note that this step
size
encompasses the entire symmetric interval around the original position,
<i>i.e.</i>
a value of 10° will attempt uniformly distributed random displacements
within the interval of -5° to 5°.<br/>
<h4><a class="NoHi" id="GRDWINDOW"><b>GRDWINDOW</b></a></h4>
This keyword sets a parameter determined by external input files which
are used to assist conformation space sampling in biased fashion when
<a href="keywords.html#PIVOTMODE">PIVOTMODE</a> is set to 2. Then,
GRDWINDOW
needs to specify half the bin size for the steric grids (see <a
 href="keywords.html#GRIDDIR">GRIDDIR</a>). The files are supplied in
the data-directory
and the default value to be used here would be 5.0°. Note that
grid-assisted
sampling is not a fully supported option in CAMPARI and may be removed
entirely in the future.<br/>
<h4><a class="NoHi" id="OMEGAFREQ"><b>OMEGAFREQ</b></a></h4>
In polypeptides, the dihedral angle along the actual peptide bond (ω)
is different
from the φ- and ψ-bonds since the carbon and nitrogen atoms have
partial sp<sup>2</sup>-character. This inhibits free rotation around the bond due
to
electronic effects and means that only a very narrow range of
conformations is typically
available to the ω-angle. The two dominant states are the planar <i>cis</i>-
and
<i>trans</i>-conformations with the latter being almost exclusively
seen
for non-proline residues and both contributing for proline. In
molecular mechanics
force fields, these effects are typically represented via strong
torsional potentials
(see <a href="keywords.html#SC_BONDED_T">SC_BONDED_T</a> and <a
 href="keywords.html#SC_EXTRA">SC_EXTRA</a>).
From a sampling point of view,
this means that it would be unwise to couple the sampling of such a
stiff degree of freedom
to any other degree of freedom. ω-moves therefore perturb nothing but
the ω-angle
of an individual polypeptide residue. They technically are equivalent
to pivot moves
in that the "free" end will swivel around lowering the acceptance rates
additionally if
the perturbations are large (→ <a href="keywords.html#ALIGN">ALIGN</a>).<br/>
To calculate the number of expected ω-moves use:<br/>
<a href="keywords.html#NRSTEPS">NRSTEPS</a> · (1.0-<a
 href="keywords.html#PARTICLEFLUCFREQ">PARTICLEFLUCFREQ</a>)
· (1.0-<a href="keywords.html#RIGIDFREQ">RIGIDFREQ</a>) · (1.0-<a
 href="keywords.html#CHIFREQ">CHIFREQ</a>)
· (1.0-<a href="keywords.html#CRFREQ">CRFREQ</a>) · OMEGAFREQ<br/>
Note that the moves are additionally split up into those attempting to
completely
randomize the ω-angle and those that attempt stepwise perturbations (→
<a href="keywords.html#OMEGARDFREQ">OMEGARDFREQ</a>). It should be
emphasized that the randomizing move will typically be the only way of
converting between <i>cis</i>- and <i>trans</i>-conformations due to
the height of the barrier separating the two. The default picking probabilities
are identical for all residues with &omega;-type bonds. 
They can be adjusted with the help of the <a href="inputfiles.html#FMCSC_PSWFILE">preferential sampling utility</a>,
and such adjustment could be useful in mixed systems with small molecule amides and polypeptides,
where it may be beneficial to preferentially sample the polypeptide &omega;-bonds.<br/>
<h4><a class="NoHi" id="OMEGARDFREQ"><b>OMEGARDFREQ</b></a></h4>
This keyword is completely analogous to <a
 href="keywords.html#PIVOTRDFREQ">PIVOTRDFREQ</a> but applies to
ω-moves instead of φ/ψ-moves.<br/>
<h4><a class="NoHi" id="OMEGASTEPSZ"><b>OMEGASTEPSZ</b></a></h4>
This keyword is completely analogous to <a
 href="keywords.html#PIVOTSTEPSZ">PIVOTSTEPSZ</a> but
applies to ω-moves instead of φ/ψ-moves.<br/>
<h4><a class="NoHi" id="PKRFREQ"><b>PKRFREQ</b></a></h4>
Of the fraction of all pivot-type polypeptide backbone moves,
what is the fraction of backbone moves to selectively alter the
dihedral angles around the N-C<sub>α</sub> bond in proline
or similar residues?
These rotations are hindered by the presence of the ring and hence they
cannot be sampled independently.
Moves of this type therefore alter the pucker state of the amino acid
sidechain belonging to the chosen residue and
the backbone conformation of the polypeptide (pivot-type move)
simultaneously. These moves are analogous
to sugar pucker moves for polynucleotides (see <a
 href="keywords.html#SUGARFREQ">SUGARFREQ</a>).<br/>
The expected number of polypeptide pucker moves would be:<br/>
<a href="keywords.html#NRSTEPS">NRSTEPS</a> · (1.0-<a
 href="keywords.html#PARTICLEFLUCFREQ">PARTICLEFLUCFREQ</a>)
· (1.0-<a href="keywords.html#RIGIDFREQ">RIGIDFREQ</a>) · (1.0-<a
 href="keywords.html#CHIFREQ">CHIFREQ</a>)
· (1.0-<a href="keywords.html#CRFREQ">CRFREQ</a>) · (1.0-<a
 href="keywords.html#OMEGAFREQ">OMEGAFREQ</a>)
· (1.0-<a href="keywords.html#NUCFREQ">NUCFREQ</a>) · PKRFREQ<br/>
Note that these moves are split up into two variants - a non-ergodic
one which inverts the pucker state, and one which introduces new
degrees of freedom, bond angles, but allows sampling of most of the
relevant phase space
(bond length changes remain quenched). This is determined by <a
 href="keywords.html#PKRRDFREQ">PKRRDFREQ</a>.
When analyzing high-resolution structural databases, it can be seen
that proline residues occupy two dominant pucker
states separated by a barrier. The non-ergodic move can jump across
this barrier but is unable to explore the basin around its
current position. The latter requires bond angle changes as otherwise
the problem is overconstrained. This introduction
of new degrees of freedom is generally undesirable (see discussion
under <a href="keywords.html#ANGCRFREQ">ANGCRFREQ</a>)
but in this particular case of small impact since none of the bond
angles along the main chain are allowed to change.
This keeps the effects of bond angle changes local while allowing
exploration of the continuous manifold of conformations
of the five-membered ring.<br/>
The exact set of degrees of freedom used to sample the ergodic move
type is explained in detail <a href="outputfiles.html#FYC.dat">elsewhere</a>,
and an implementation reference is given in the <a href="references.html#ref13_1">literature</a>.
The default picking probabilities for this move type are flat for all polypeptide residues
possessing ring pucker degrees of freedom.
The probabilities can be adjusted by the <a href="inputfiles.html#FMCSC_PSWFILE">preferential sampling utility</a>,
and this could be used to fine-tune sampling weights in polymers. For example, puckering equilibria for
central residues in polyproline are expected to be both more relevant and more difficult to sample
than those for terminal residues and may benefit from being sampled preferentially.
Finally, like <a href="keywords.html#SUGARFREQ">sugar pucker moves</a>, these moves are
using no parallelization to the closure problem for the ring when CAMPARI's
<a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
which is a limitation.<br/>
<h4><a class="NoHi" id="PKRRDFREQ"><b>PKRRDFREQ</b></a></h4>
As pointed out above, finding arbitrary conformations of a
five-membered ring while keeping all bond lengths and angles constant
is an overconstrained problem (→ <a href="keywords.html#PKRFREQ">PKRFREQ</a>).
Therefore,
CAMPARI releases the constraint on bond angle rigidity for those
systems which include proline and similar
polypeptide residues. This necessitates the use of bond angle
potentials (see <a href="keywords.html#SC_BONDED_A">SC_BONDED_A</a>)
to keep local geometries reasonable. To sample different ring
conformers effectively, CAMPARI uses a strategy of combining
a non-ergodic reflection of the pucker step (non-local) with stepwise
but unbiased excursions away from the current state.
This keywords regulates the fraction of pucker moves to be of the
former type (reflection). The formulas listed
under <a href="keywords.html#PKRFREQ">PKRFREQ</a> multiplied with
PKRRDFREQ and (1.0-PKRRDFREQ), respectively, would
give the expected numbers for either type.
Note that it typically is not a good idea to set this to either zero or
unity. A value of unity would create an effective
two-state model (with fixed bond angles), while a value of zero would
make it very difficult for the gross pucker state to
switch due to the barrier separating the two (this last statement
assumes typical interaction potentials).<br/>
<h4><a class="NoHi" id="PUCKERSTEP_DI"><b>PUCKERSTEP_DI</b></a></h4>
This keyword applies to the second type of pucker sampling (see <a
 href="keywords.html#PKRRDFREQ">PKRRDFREQ</a>) and controls
the maximum step size for dihedral angles in degrees for the random
stepwise excursions from the current state. It simultaneously
applies to the problem of sugar pucker sampling (→ <a
 href="keywords.html#SUGARFREQ">SUGARFREQ</a>). In both cases, four of
the seven
freely sampled degrees of freedom are dihedral angles.<br/>
<h4><a class="NoHi" id="PUCKERSTEP_AN"><b>PUCKERSTEP_AN</b></a></h4>
This keyword applies to the second (stepwise) type of pucker sampling
(see <a href="keywords.html#PKRRDFREQ">PKRRDFREQ</a>) and
controls the maximum step size for bond angles in degrees for the random
stepwise excursions from the current state. Much like
<a href="keywords.html#PUCKERSTEP_DI">PUCKERSTEP_DI</a>, this keyword
simultaneously
applies to the problem of sugar pucker sampling (→ <a
 href="keywords.html#SUGARFREQ">SUGARFREQ</a>).
In both cases, two of the seven freely sampled degrees of freedom are
bond angles and one bond angle is derived to correctly
close the loop.<br/>
<h4><a class="NoHi" id="NUCFREQ"><b>NUCFREQ</b></a></h4>
This keyword controls the frequency of all types of polynucleotide
moves excepting those sampling just
sidechain degrees of freedom. This set includes algorithms to sample
stretches of polynucleotides with end-constraints
(concerted rotation → <a href="keywords.html#NUCCRFREQ">NUCCRFREQ</a>),
dedicated algorithms to sample the constrained
dihedral angles around the sugar bond (→ <a
 href="keywords.html#SUGARFREQ">SUGARFREQ</a>), and simple
polynucleotide backbone pivot moves. The description below applies only
to the latter type which does not possess
a dedicated keyword but is the default fall-through choice for this
branch of the decision tree.<br/>
Non-terminal polynucleotides have six backbone degrees of freedom one
of which is not sampled by this type of move.
Much like for proline, the rotation around the sugar bond is hindered
and a dedicated algorithm is needed to sample
this dihedral angle (→ <a href="keywords.html#SUGARFREQ">SUGARFREQ</a>).
An
overview of the backbone degrees of freedom for terminal and
non-terminal nucleotides can be gleaned from the description of <a
 href="inputfiles.html#FMCSC_SEQFILE">sequence input</a>.
Nucleotide pivot moves are physically analogous to polypeptide
φ/ψ-moves in that they sample the backbone of a
single nucleotide residue. The new conformation will imply the rotation
of a lever arm which will render large-scale perturbations very
unlikely to be accepted (→ <a href="keywords.html#ALIGN">ALIGN</a>).
Technically, these moves are implemented slightly differently in that
the number of sampled degrees of freedom may vary
(→ <a href="keywords.html#NRNUC">NRNUC</a>).
This is to make it possible to fine-tune sampling efficiency. As with
any move coupling the sampling of independent degrees
of freedom blindly, efficiency will typically be unacceptably low for
more than two backbone dihedral angles given a realistic
interaction potential and the complicated topology of polynucleotides.
In the future, these moves are sought to
cover any type of non-polypeptide polymer and the flexible setup was
implemented partially with that in mind.<br/>
Expected numbers for all polynucleotide pivot moves may be calculated
as follows:<br/>
<a href="keywords.html#NRSTEPS">NRSTEPS</a> · (1.0-<a
 href="keywords.html#PARTICLEFLUCFREQ">PARTICLEFLUCFREQ</a>)
· (1.0-<a href="keywords.html#RIGIDFREQ">RIGIDFREQ</a>) · (1.0-<a
 href="keywords.html#CHIFREQ">CHIFREQ</a>)
· (1.0-<a href="keywords.html#CRFREQ">CRFREQ</a>) · (1.0-<a
 href="keywords.html#OMEGAFREQ">OMEGAFREQ</a>)
· NUCFREQ · (1.0-<a href="keywords.html#NUCCRFREQ">NUCCRFREQ</a>) ·
(1.0-<a href="keywords.html#SUGARFREQ">SUGARFREQ</a>)<br/>
Remember that NUCFREQ does not control the fraction of polynucleotide
pivot moves directly but only sets the expected
number for all polynucleotide moves. Note that the moves are
additionally split up into those attempting to completely
randomize the nucleotide backbone angles and those that attempt
stepwise perturbations (→
<a href="keywords.html#NUCRDFREQ">NUCRDFREQ</a>).
The default picking probabilities for these pivot moves are flat on a per-residue basis.
They can be adjusted by the <a href="inputfiles.html#FMCSC_PSWFILE">preferential sampling utility</a>,
and this could become routinely relevant in future applications, for which other polymer
types are subjected to pivot moves through this facility. In such a case, it would almost certainly
be desirable to make the picking frequencies (at the very least) proportional to the number of backbone
degrees of freedom in each residue, which may not necessarily be homogeneous.<br/>
<h4><a class="NoHi" id="NRNUC"><b>NRNUC</b></a></h4>
This keyword allows the user to set the <i>maximum</i> number of
nucleic acid backbone angles to be sampled
within a pivot polynucleotide move. The dihedral angles will always
come from the same residue. The
implementation has the following features:<br/>
<ul>
  <li>Whenever NRNUC is equal to or larger than the number of backbone
angles on a certain residue, all
backbone angles on that residue will be sampled simultaneously.</li>
  <li>Whenever NRNUC is smaller than the number of backbone angles on a
certain residue, on average NRNUC of the available angles should be
sampled simultaneously. However, the actual
average will be larger since always at least one angle has to be
sampled (in other words, there is a stochasticity to the
number of angles chosen, and the asymmetry is introduced by the
constraint to always have at least one angle in the set).</li>
</ul>
<h4><a class="NoHi" id="NUCRDFREQ"><b>NUCRDFREQ</b></a></h4>
This keyword is completely analogous to <a
 href="keywords.html#PIVOTRDFREQ">PIVOTRDFREQ</a> but applies to
polynucleotide backbone pivot moves instead of φ/ψ-moves.<br/>
<h4><a class="NoHi" id="NUCSTEPSZ"><b>NUCSTEPSZ</b></a></h4>
This keyword is completely analogous to <a
 href="keywords.html#PIVOTSTEPSZ">PIVOTSTEPSZ</a> but applies to
polynucleotide backbone pivot moves instead of φ/ψ-moves.<br/>
<h4><a class="NoHi" id="NUCCRFREQ"><b>NUCCRFREQ</b></a></h4>
This keyword sets the fraction of exact nucleic acid concerted rotation (CR)
moves amongst all nucleotide moves.
Concerted rotation algorithms are provided both for polypeptides and
polynucleotide and function
generally analogously although there are important implementation
differences. Important general information for this type of move is provided
<a href="keywords.html#CRFREQ">elsewhere</a>, along with parameters
that apply to all variants of exact CR moves (such as <a href="keywords.html#UJCRBIAS">UJCRBIAS</a>,
<a href="keywords.html#UJCRSTEPSZ">UJCRSTEPSZ</a>, and <a href="keywords.html#UJCRWIDTH">UJCRWIDTH</a>).
In particular, the reader is referred to both the <a href="references.html#ref14_2">literature</a>
and the documentation on CR moves for polypeptides (&rarr; <a href="keywords.html#CRFREQ">CRFREQ</a>
and <a href="keywords.html#TORCRFREQ">TORCRFREQ</a>) in particular with regards to the
interpretation of auxiliary keywords (<a href="keywords.html#NUCCRMIN">NUCCRMIN</a> and 
<a href="keywords.html#NUCCRMAX">NUCCRMAX</a>) and the handling of picking probabilities
and their alteration by <a href="keywords.html#FRZFILE">user-level constraints</a>
and <a href="inputfiles.html#FMCSC_PSWFILE">preferential sampling weights</a>.<br/>
 The general
idea of a concerted rotation move is to sample a stretch
of polymer without changing the absolute positions and relative
orientation of the termini.
Six degrees of freedom are required to solve this constrained problem.
Note that for nucleic acid CR moves the rotation around the sugar bond
(C4*-C3*) is
always excluded from the algorithm (treated as a rigid segment).
The order of angles is as follows:<br/>
<ol>
  <li>Any number of consecutive and permissible backbone dihedral angles <b>immediately</b>
preceding nuc_bb_4 on residue <i>i</i></li>
  <li>O5P-C5*-C4*-C3* (nuc_bb_4 on residue <i>i</i>)</li>
  <li>C4*-C3*-O3P-P (nuc_bb_5 on residue <i>i</i>)</li>
  <li>C3*-O3P-P-O5P (nuc_bb_1 on residue <i>i+1</i>)</li>
  <li>O3P-P-O5P-C5* (nuc_bb_2 on residue <i>i+1</i>)</li>
  <li>P-O5P-C5*-C4* (nuc_bb_3 on residue <i>i+1</i>)</li>
  <li>O5P-C5*-C4*-C3* (nuc_bb_4 residue <i>i+1</i>)</li>
</ol>
The first entry is the so called pre-rotation segment, and the
remaining six degrees of freedom are those for which to find a
numerical
solution that closes the chain exactly without changing the position of
any atom from
C3* on residue <i>i+1</i> onward. The solution is obtained through a
1D numerical root search in an algebraically
transformed set of equations. This part follows the work of Aaron
Dinner exactly and its parameters are explained in
further detail below. The pre-rotation segment uses its own biasing
scheme for improved efficiency based on the
work by <a href="references.html#ref14_1">Favrin <i>et al.</i></a>. Both types of biases are removed through
a modified acceptance criterion. However, it must
be pointed out that the reliability of the root search is nonetheless a
critical component to obtain an unbiased
Markov chain observing detailed balance. If unfamiliar, the user should
read all of the documentation on exact
concerted rotation methods below in addition to consulting the
literature.<br/>
The expected number of nucleic acid concerted rotation moves is
obtained as follows:<br/>
Expected numbers for polynucleotide CR moves may be calculated as
follows:<br/>
<a href="keywords.html#NRSTEPS">NRSTEPS</a> · (1.0-<a
 href="keywords.html#PARTICLEFLUCFREQ">PARTICLEFLUCFREQ</a>)
· (1.0-<a href="keywords.html#RIGIDFREQ">RIGIDFREQ</a>) · (1.0-<a
 href="keywords.html#CHIFREQ">CHIFREQ</a>)
· (1.0-<a href="keywords.html#CRFREQ">CRFREQ</a>) · (1.0-<a
 href="keywords.html#OMEGAFREQ">OMEGAFREQ</a>)
· <a href="keywords.html#NUCFREQ">NUCFREQ</a> · NUCCRFREQ<br/>
The user is reminded again that some of the parameters required for this move type apply
universally to all exact CR methods
while some apply specifically to the nucleic acid variant.
Finally, these and all other exact torsional concerted rotation moves are (currently) unavailable when using
CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a>.<br/>
<h4><a class="NoHi" id="SUGARFREQ"><b>SUGARFREQ</b></a></h4>
This keyword sets the fraction of polynucleotide backbone moves to
selectively alter the dihedral angles around
the sugar bond (C4*-C3*) amongst all polynucleotide moves not of the CR
variety. Exactly analogous to the case
for proline and similar cyclic residues in polypeptides (→ <a
 href="keywords.html#PKRFREQ">PKRFREQ</a>),
these rotations are hindered by the presence of the ring and cannot be
sampled blindly.
Moves of this type will therefore alter the pucker state of the sugar
belonging to the chosen nucleotide and
the backbone conformation of the polynucleotide (including lever arm)
simultaneously.<br/>
The expected number may be calculated as follows:<br/>
<a href="keywords.html#NRSTEPS">NRSTEPS</a> · (1.0-<a
 href="keywords.html#PARTICLEFLUCFREQ">PARTICLEFLUCFREQ</a>)
· (1.0-<a href="keywords.html#RIGIDFREQ">RIGIDFREQ</a>) · (1.0-<a
 href="keywords.html#CHIFREQ">CHIFREQ</a>)
· (1.0-<a href="keywords.html#CRFREQ">CRFREQ</a>) · (1.0-<a
 href="keywords.html#OMEGAFREQ">OMEGAFREQ</a>)
· <a href="keywords.html#NUCFREQ">NUCFREQ</a> · (1.0-<a
 href="keywords.html#NUCCRFREQ">NUCCRFREQ</a>) · SUGARFREQ<br/>
The approach chosen to sample sugars is identical to the one for
proline. There are two basic move types, one which
inverts the pucker state by flipping the sign of two dihedral-angles,
and a second one which perturbs the bond
angles and dihedral angles defining the 5-remembered ring by small
random increments while maintaining bond lengths
exactly (→ <a href="keywords.html#SUGARRDFREQ">SUGARRDFREQ</a>).
The default picking probabilities for this move type are even for all eligible, sugar-containing residues.
They can be adjusted by the <a href="inputfiles.html#FMCSC_PSWFILE">preferential sampling utility</a>.
An example application could be to preferentially sample sugars close to the binding interface
of a well-defined protein-DNA complex rather than those in the rigid portion of the DNA.
Finally, like <a href="keywords.html#PKRFREQ">polypeptide pucker moves</a>, these moves are
using no parallelization to the closure problem for the ring when CAMPARI's
<a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
which is a limitation.<br/>
<h4><a class="NoHi" id="SUGARRDFREQ"><b>SUGARRDFREQ</b></a></h4>
This keyword is exactly analogous to <a href="keywords.html#PKRRDFREQ">PKRRDFREQ</a>
but
applies to sugar pucker moves in polynucleotides instead of to
polypeptide pucker moves.<br/>
<h4><a class="NoHi" id="CHIFREQ"><b>CHIFREQ</b></a></h4>
Most biologically relevant polymers possess at least minor branches off
the main chain. These sidechains
are typically short and usually encode the alphabet underlying for
instance polypeptides and polynucleotides.
From a technical point of view, such short branches are much easier to
sample than the backbone of a polymer
since the impact of a change in conformation of the branch only affects
the branch (lever arm effects are minimal
and the assumed direction is always from the main chain outward towards
the end of the branch). Since the
perturbation is local, energy evaluations are much less costly and
acceptance rates generally higher.
There is no need for advanced algorithms and simple pivot-style moves
re-setting or perturbing the dihedral angles
angles in such a sidechain branch are sufficient to explore phase
space. This keyword sets the fraction of all sidechain moves including
a specialized move type used for analysis only
(→ <a href="keywords.html#PHFREQ">PHFREQ</a>).<br/>
Expected numbers for actual sampling moves (denoted as χ-moves) are:<br/>
<a href="keywords.html#NRSTEPS">NRSTEPS</a> · (1.0-<a
 href="keywords.html#PARTICLEFLUCFREQ">PARTICLEFLUCFREQ</a>)
· (1.0-<a href="keywords.html#RIGIDFREQ">RIGIDFREQ</a>) · CHIFREQ ·
(1.0-<a href="keywords.html#PHFREQ">PHFREQ</a>)<br/>
And for moves trying to determine the pK-values of ionizable
polypeptide sidechains:<br/>
<a href="keywords.html#NRSTEPS">NRSTEPS</a> · (1.0-<a
 href="keywords.html#PARTICLEFLUCFREQ">PARTICLEFLUCFREQ</a>)
· (1.0-<a href="keywords.html#RIGIDFREQ">RIGIDFREQ</a>) · CHIFREQ · <a
 href="keywords.html#PHFREQ">PHFREQ</a><br/>
Note that the former are decomposed further into those randomizing the
contributing degrees of freedom and those
applying stepwise perturbations (→ <a href="keywords.html#CHIRDFREQ">CHIRDFREQ</a>).
The default picking probabilities for this move type give equal weight to all residues with at least one &chi;-angle independent
of the number of &chi;-angles. This can be adjusted by the <a href="inputfiles.html#FMCSC_PSWFILE">preferential sampling utility</a>,
which as an example would allow making all residue picking probabilities directly proportional to
the number of &chi;-angles for each residue.<br/>
<h4><a class="NoHi" id="CHIRDFREQ"><b>CHIRDFREQ</b></a></h4>
This keyword is completely analogous to <a
 href="keywords.html#PIVOTRDFREQ">PIVOTRDFREQ</a> but applies to
χ-moves instead of φ/ψ-moves.<br/>
<h4><a class="NoHi" id="CHISTEPSZ"><b>CHISTEPSZ</b></a></h4>
This keyword is completely analogous to <a
 href="keywords.html#PIVOTSTEPSZ">PIVOTSTEPSZ</a> but applies to
χ-moves instead of φ/ψ-moves.<br/>
<h4><a class="NoHi" id="NRCHI"><b>NRCHI</b></a></h4>
Many sidechains have different numbers of χ-angles and the complexity
of a move would depend on the number
of such angles sampled concurrently. Therefore, this keyword allows the
user to set the <i>maximum</i> number of
χ-angles to be sampled within a sidechain move. The dihedral angles
will always come from the same sidechain
on the same residue. Analogously to <a href="keywords.html#NRNUC">NRNUC</a>,
the
implementation has the following features:<br/>
<ul>
  <li>Whenever NRCHI is equal to or larger than the number of χ-angles
on a certain residue, all
χ-angles on that residue will be sampled simultaneously.</li>
  <li>Whenever NRCHI is smaller than the number of sidechain angles on a
certain residue, on average
NRCHI of the available angles should be sampled simultaneously.
However, the actual
average will be larger since always at least one angle has to be
sampled (in other words, there is a stochasticity to the
number of angles chosen, and the asymmetry is introduced by the
constraint to always have at least one angle in the set).</li>
</ul>
<h4><a class="NoHi" id="OTHERFREQ"><b>OTHERFREQ</b></a></h4>
MC move sets are highly specialized tools that have to reflect the choice
of the system's degrees of freedom, its density, <i>etc</i>. Some of the choices
enforced by the "standard" CAMPARI move sets and mandated by the default parameterization of the 
<a href="references.html#ref19_1">ABSINTH implicit solvent model</a> are
somewhat arbitrary. This is primarily an issue for degrees of freedom
describing rotations around electronically hindered bonds and for rotations
around terminal bonds between heavy-atoms (methyl and ammonium spins). For example,
the amide bond in secondary amides is allowed to vary with
<a href="keywords.html#OMEGAFREQ">dedicated moves</a>, but these are not available
for primary amides (the reasoning behind it is connected to the vanishing
relevance of <i>cis/trans</i> isomerization in the latter case). However,
these choices may not always be desirable. Second, when attempting to simulate
entities that CAMPARI does not support natively, the majority of "standard"
move types may not be available (exceptions apply if the entities are recognized
as conforming to a supported biopolymer type). This would limit simulations
containing such entities to pure rigid-body sampling.<br/>
To address both issues, CAMPARI offers a separate class of dihedral angle
pivot moves that can be applied to any freely rotatable torsion angle
in any of the system's components. There is a requirement that the Z-matrix
be constructed such that only a single Z-matrix angle needs to be edited 
to describe the perturbation, and this is true for all candidate dihedral
angles in residues supported natively by CAMPARI that are frozen by default
(<i>e.g.</i>, C-N bond in the lysine sidechain, all C-N bonds in primary amides, CA-CB bond
in alanine, and so on). For unsupported residues, the Z-matrix is inferred from the
<a href="keywords.html#PDB_TEMPLATE">input structure</a>, and it may require
some reordering of atoms to achieve the desired results (see a 
<a href="tutorial12.html">tutorial relevant in this context</a>). In addition,
these moves can also sample torsional degrees of freedom supported by other move sets
as long as they fulfill the Z-matrix criterion (this currently excludes the polypeptide
&phi;/&psi;-angles, which are supported by the widest range of specialized move sets).<br/>
In terms of parameters, some care has to be taken that torsional potentials
describing electronic effects (<i>e.g.</i>, in primary amides) are included.
Technically, moves of this type are unique in that they always sample only 
a single degree of freedom. <a href="keywords.html#ALIGN">Chain alignment</a> works slightly differently 
for these moves. Specifically, for options 3 and 4, the number of atoms (rather than
the number of residues) moving is critical in determining alignment. Also, all 
degrees of freedom are eligible for an inverted alignment including sidechain
degrees of freedom. Even for option 3, this may consequently lead to the absence
of a "base of motion" that would stay rigorously in place in the absence of rigid body moves.
For option 2, CAMPARI attempts to preserve a well-defined base of motion at the C-terminus,
but this may not work as expected, in particular for polynucleotides and/or very short chains.<br/>
To calculate the number of all expected moves of type of OTHER, use:<br/>
<a href="keywords.html#NRSTEPS">NRSTEPS</a> · (1.0-<a
 href="keywords.html#PARTICLEFLUCFREQ">PARTICLEFLUCFREQ</a>)
· (1.0-<a href="keywords.html#RIGIDFREQ">RIGIDFREQ</a>) · (1.0-<a
 href="keywords.html#CHIFREQ">CHIFREQ</a>) · (1.0-<a
 href="keywords.html#CHIFREQ">CRFREQ</a>) · (1.0-<a
 href="keywords.html#CHIFREQ">OMEGAFREQ</a>) · (1.0-<a
 href="keywords.html#CHIFREQ">NUCFREQ</a>)
· (1.0-<a href="keywords.html#PKRFREQ">PKRFREQ</a>) · OTHERFREQ<br/>
Note that these moves are additionally split up into three basic types
(see <a href="keywords.html#OTHERUNKFREQ">OTHERUNKFREQ</a> and <a href="keywords.html#OTHERNATFREQ">OTHERNATFREQ</a>
for choosing different subsets of degrees of freedom), each of which is again
split into two variants, <i>i.e.</i>, those completely
randomizing the dihedral angle and those that attempt stepwise perturbations (→
<a href="keywords.html#OTHERRDFREQ">OTHERRDFREQ</a>).
The default picking probabilities for OTHER moves are different from other move types in CAMPARI,
since they are identical for all eligible degrees of freedom (and not identical for
all residues containing at least one eligible degree of freedom). For each subcategory of degrees
of freedom, sampling weights can be adjusted individually with the
<a href="inputfiles.html#FMCSC_PSWFILE">preferential sampling utility</a>. Details and examples
are given for the individual subcategories.<br/>
<h4><a class="NoHi" id="OTHERUNKFREQ"><b>OTHERUNKFREQ</b></a></h4>
If <a href="keywords.html#OTHERFREQ">single dihedral angle pivot (OTHER) moves</a> are in use, and if the
simulation utilizes entities (residues, molecules) that are not natively supported by CAMPARI,
this keyword allows the user to choose the bulk sampling weight for degrees of freedom
in those unsupported residues. The use of unsupported residues in simulations is explained in a
<a href="tutorial12.html">dedicated tutorial</a>.<br/>
To calculate the number of expected moves acting on single dihedral angles in unsupported residues, use:<br/>
<a href="keywords.html#NRSTEPS">NRSTEPS</a> · (1.0-<a
 href="keywords.html#PARTICLEFLUCFREQ">PARTICLEFLUCFREQ</a>)
· (1.0-<a href="keywords.html#RIGIDFREQ">RIGIDFREQ</a>) · (1.0-<a
 href="keywords.html#CHIFREQ">CHIFREQ</a>) · (1.0-<a
 href="keywords.html#CHIFREQ">CRFREQ</a>) · (1.0-<a
 href="keywords.html#CHIFREQ">OMEGAFREQ</a>) · (1.0-<a
 href="keywords.html#CHIFREQ">NUCFREQ</a>)
· (1.0-<a href="keywords.html#PKRFREQ">PKRFREQ</a>) · <a href="keywords.html#OTHERFREQ">OTHERFREQ</a> · OTHERUNKFREQ<br/>
As mentioned above, these moves are additionally split up into two subtypes
<i>i.e.</i>, those completely randomizing the dihedral angle and those that attempt stepwise perturbations (→
<a href="keywords.html#OTHERRDFREQ">OTHERRDFREQ</a>). 
The default picking probabilities for OTHER moves are different from other move types in CAMPARI,
since they are identical for all eligible degrees of freedom (and not identical for
all residues containing at least one eligible degree of freedom). They can be adjusted at the level
of individual degrees of freedom by the <a href="inputfiles.html#FMCSC_PSWFILE">preferential sampling utility</a>.
As an example, this can be useful when sampling an unsupported polymer (<i>e.g.</i>, a polyester) and
greater sampling emphasis should be placed on backbone degrees of freedom. 
<br/>
<h4><a class="NoHi" id="OTHERNATFREQ"><b>OTHERNATFREQ</b></a></h4>
If <a href="keywords.html#OTHERFREQ">single dihedral angle pivot (OTHER) moves</a> are in use,
and if not all OTHER moves are consumed on unsupported residues (&rarr; <a href="keywords.html#OTHERUNKFREQ">OTHERUNKFREQ</a>),
this keyword allows the user to choose the bulk sampling weight amongst remaining OTHER moves for degrees of freedom
that are supported natively by CAMPARI.<br/>
To calculate the number of expected moves acting on single dihedral angles natively supported, use:<br/>
<a href="keywords.html#NRSTEPS">NRSTEPS</a> · (1.0-<a
 href="keywords.html#PARTICLEFLUCFREQ">PARTICLEFLUCFREQ</a>)
· (1.0-<a href="keywords.html#RIGIDFREQ">RIGIDFREQ</a>) · (1.0-<a
 href="keywords.html#CHIFREQ">CHIFREQ</a>) · (1.0-<a
 href="keywords.html#CHIFREQ">CRFREQ</a>) · (1.0-<a
 href="keywords.html#CHIFREQ">OMEGAFREQ</a>) · (1.0-<a
 href="keywords.html#CHIFREQ">NUCFREQ</a>)
· (1.0-<a href="keywords.html#PKRFREQ">PKRFREQ</a>) · <a href="keywords.html#OTHERFREQ">OTHERFREQ</a>
· (1.0 - <a href="keywords.html#OTHERUNKFREQ">OTHERUNKFREQ</a>) · OTHERNATFREQ<br/>
This keyword also controls the fraction of moves acting on dihedral angles frozen by default, but located in residues 
supported natively by CAMPARI. Compute expected number as:<br/>
<a href="keywords.html#NRSTEPS">NRSTEPS</a> · (1.0-<a
 href="keywords.html#PARTICLEFLUCFREQ">PARTICLEFLUCFREQ</a>)
· (1.0-<a href="keywords.html#RIGIDFREQ">RIGIDFREQ</a>) · (1.0-<a
 href="keywords.html#CHIFREQ">CHIFREQ</a>) · (1.0-<a
 href="keywords.html#CHIFREQ">CRFREQ</a>) · (1.0-<a
 href="keywords.html#CHIFREQ">OMEGAFREQ</a>) · (1.0-<a
 href="keywords.html#CHIFREQ">NUCFREQ</a>)
· (1.0-<a href="keywords.html#PKRFREQ">PKRFREQ</a>) · <a href="keywords.html#OTHERFREQ">OTHERFREQ</a>
· (1.0 - <a href="keywords.html#OTHERUNKFREQ">OTHERUNKFREQ</a>) · (1.0 - OTHERNATFREQ)<br/>
Both subclasses are additionally split up into two subtypes
<i>i.e.</i>, those completely randomizing the dihedral angle and those that attempt stepwise perturbations (→
<a href="keywords.html#OTHERRDFREQ">OTHERRDFREQ</a>). 
The default picking probabilities for OTHER moves are different from other move types in CAMPARI,
since they are identical for all eligible degrees of freedom (and not identical for
all residues containing at least one eligible degree of freedom). They can be adjusted at the level
of individual degrees of freedom by the <a href="inputfiles.html#FMCSC_PSWFILE">preferential sampling utility</a>.
For the natively supported degrees of freedom, this could be useful in order to aid sampling
of backbone degrees of freedom, whereas for the natively frozen degrees of freedom it could be used
to selectively enable a few of those degrees of freedom (<i>e.g.</i>, enable flexibility of arginine
sidechains, but keep suppressing the methyl spins in hydrophobic residues).<br/>
<h4><a class="NoHi" id="OTHERRDFREQ"><b>OTHERRDFREQ</b></a></h4>
This keyword is completely analogous to <a href="keywords.html#PIVOTRDFREQ">PIVOTRDFREQ</a> but applies to
all moves of type <a href="keywords.html#OTHERFREQ">OTHER</a> instead of polypeptide backbone pivot moves.<br/>
<h4><a class="NoHi" id="OTHERSTEPSZ"><b>OTHERSTEPSZ</b></a></h4>
This keyword is completely analogous to <a href="keywords.html#PIVOTSTEPSZ">PIVOTSTEPSZ</a> but applies to
all moves of type <a href="keywords.html#OTHERFREQ">OTHER</a> instead of polypeptide backbone pivot moves.<br/>
<h4><a class="NoHi" id="CRFREQ"><b>CRFREQ</b></a></h4>
This keyword is a global frequency setting which controls and entire
branch of Monte Carlo moves all sharing
the feature that they are of the concerted rotation (CR) type and apply
to polypeptides.
The general idea of a CR move is to sample a stretch
of polymer without changing the absolute positions and relative
orientation of the termini.
Six degrees of freedom are required to solve this constrained problem
exactly but simpler
methods exist to use more degrees of freedom to solve it approximately
(→ <a href="keywords.html#CRMODE">CRMODE</a>).
The reader is referred to <a href="keywords.html#NUCCRFREQ">NUCCRFREQ</a>
for CR moves on polynucleotides.<br/>
There are four different types of CR moves for polypeptides provided in
CAMPARI:<br/>
<ol>
  <li>Exact CR moves utilizing both bond angles and dihedral angles
along the polypeptide backbone to solve the closure problem exactly
given fixed end constraints: these
moves are based on the work of Ulmschneider and Jorgensen (→ <a
 href="keywords.html#ANGCRFREQ">ANGCRFREQ</a>). (<a
 href="references.html#ref14_3">reference</a>)<br/>
  </li>
  <li>Exact CR moves utilizing φ-, ψ-, and ω-angles along the
polypeptide backbone to solve the closure problem exactly given fixed
end constraints: these
moves are primarily based on the work of Dinner (→ <a
 href="keywords.html#TORCRFREQ">TORCRFREQ</a> and <a
 href="keywords.html#TORCROFREQ">TORCROFREQ</a>). (<a
 href="references.html#ref14_2">reference</a>)<br/>
  </li>
  <li>Exact CR moves utilizing just φ- and ψ-angles along the
polypeptide backbone to solve the closure problem exactly given fixed
end constraints: these
moves are also based on the work of Dinner (→ <a
 href="keywords.html#TORCRFREQ">TORCRFREQ</a> and <a
 href="keywords.html#TORCROFREQ">TORCROFREQ</a>).</li>
  <li>Inexact CR moves utilizing just φ- and ψ-angles along the
polypeptide backbone to approximate a solution to the closure problem
by linear response: these
moves are based on the Favrin, Irbäck, and Sjunnesson (default
fall-through for this branch). (<a href="references.html#ref14_1">references</a>)<br/>
  </li>
</ol>
Note that the default picking probabilities for all CR moves (including those for polynucleotides)
are chosen such that every final residue in a CR-eligible stretch of minimal length has equal probability.
There are many factors influencing the eligibility, most notably terminal residues 
are excluded to different extents in the four algorithms described above, and 
cyclic residues (proline, <i>etc.</i>) are only supported in the exact torsional
variants (<a href="keywords.html#TORCRFREQ">caveats apply</a>). The minimal length aspect is also handled differently
in different algorithms. Specifically, the exact torsional variants will allow dynamic shortening
of the entire stretch to include the minimal number of degrees of freedom (see <a href="keywords.html#TORCRMIN_DJ">TORCRMIN_DJ</a> and
<a href="keywords.html#TORCRMIN_DO">TORCRMIN_DO</a>; this also holds for the <a href="keywords.html#NUCCRFREQ">analogous move type for nucleotides</a> &rarr; <a href="keywords.html#NUCCRMIN">NUCCRMIN</a>). This means
that more residues are eligible. Conversely, both the exact bond angle variant and the
approximate torsional variant enforce the lower limit specified for the stretch
length leading to a more restrictive scenario (see <a href="keywords.html#UJCRMIN">UJCRMIN</a> and
<a href="keywords.html#CRDOF">CRDOF</a>). Finally, the inexact torsional moves
also may require additional buffer residues (see <a href="keywords.html#CRMODE">CRMODE</a>).
It is important to point out that this does <b>not</b> lead to equivalent numbers of
attempted CR moves for all eligible residues. This is because eligible stretches are generally overlapping leading
to a bias toward sampling residues that are part of many stretches. This is particularly true
if the maximum stretch length possible is large (it results from a combination of the length of the polymer
and keywords <a href="keywords.html#UJCRMAX">UJCRMAX</a>, <a href="keywords.html#TORCRMAX_DO">TORCRMAX_DO</a>,
<a href="keywords.html#TORCRMAX_DJ">TORCRMAX_DJ</a>, <a href="keywords.html#NUCCRMAX">NUCCRMAX</a>, and
<a href="keywords.html#CRDOF">CRDOF</a>).
The default picking probabilities for moves of this general type can be adjusted via the
<a href="inputfiles.html#FMCSC_PSWFILE">preferential sampling utility</a>. Note that there is a very important
difference compared to the application of <a href="keywords.html#FRZFILE">user-level constraints</a>.
Whereas the latter render all possible CR stretches ineligible that contain the constrained residue,
the preferential sampling utility will only alter the probability for a residue being picked as
the final (most C-terminal) residue in a CR stretch. This means that the residue is generally not actually constrained
even if the picking weight is chosen as zero.<br/>
The general appeal of exact CR methods partially lies in the reduced complexity
of energy evaluations since the move only perturbs conformation locally
and large parts of the polymer (assuming sufficient
length) will remain static with respect to each other. This is never
true for pivot-type moves applied to residues at the center of the
chain. The other
aspect which makes CR moves appealing is that they introduce
correlation into the MC move set (the reader is referred to <a href="references.html#ref4_2">Vitalis and
Pappu</a> for further reading).<br/>
To compute expected numbers, use (same numbering as above):<br/>
<ol>
  <li><a href="keywords.html#NRSTEPS">NRSTEPS</a> · (1.0-<a
 href="keywords.html#PARTICLEFLUCFREQ">PARTICLEFLUCFREQ</a>)
· (1.0-<a href="keywords.html#RIGIDFREQ">RIGIDFREQ</a>) · (1.0-<a
 href="keywords.html#CHIFREQ">CHIFREQ</a>)
· CRFREQ · <a href="keywords.html#ANGCRFREQ">ANGCRFREQ</a></li>
  <li><a href="keywords.html#NRSTEPS">NRSTEPS</a> · (1.0-<a
 href="keywords.html#PARTICLEFLUCFREQ">PARTICLEFLUCFREQ</a>)
· (1.0-<a href="keywords.html#RIGIDFREQ">RIGIDFREQ</a>) · (1.0-<a
 href="keywords.html#CHIFREQ">CHIFREQ</a>)
· CRFREQ · (1.0-<a href="keywords.html#ANGCRFREQ">ANGCRFREQ</a>) · <a
 href="keywords.html#TORCRFREQ">TORCRFREQ</a> · <a
 href="keywords.html#TORCROFREQ">TORCROFREQ</a></li>
  <li><a href="keywords.html#NRSTEPS">NRSTEPS</a> · (1.0-<a
 href="keywords.html#PARTICLEFLUCFREQ">PARTICLEFLUCFREQ</a>)
· (1.0-<a href="keywords.html#RIGIDFREQ">RIGIDFREQ</a>) · (1.0-<a
 href="keywords.html#CHIFREQ">CHIFREQ</a>)
· CRFREQ · (1.0-<a href="keywords.html#ANGCRFREQ">ANGCRFREQ</a>) · <a
 href="keywords.html#TORCRFREQ">TORCRFREQ</a> · (1.0-<a
 href="keywords.html#TORCROFREQ">TORCROFREQ</a>)</li>
  <li><a href="keywords.html#NRSTEPS">NRSTEPS</a> · (1.0-<a
 href="keywords.html#PARTICLEFLUCFREQ">PARTICLEFLUCFREQ</a>)
· (1.0-<a href="keywords.html#RIGIDFREQ">RIGIDFREQ</a>) · (1.0-<a
 href="keywords.html#CHIFREQ">CHIFREQ</a>)
· CRFREQ · (1.0-<a href="keywords.html#ANGCRFREQ">ANGCRFREQ</a>) · (1.0-<a
 href="keywords.html#TORCRFREQ">TORCRFREQ</a>)</li>
</ol>
Finally, be aware that all concerted rotation moves involve steps that are difficult to parallelize.
Thus, when CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
some of the move types in this class are (currently) unavailable while others are supported but
do not offer scaling for the geometric problem (only for the incremental
<a href="keywords.html#energy_terms">energy calculations</a>).
<br/>
<h4><a class="NoHi" id="ANGCRFREQ"><b>ANGCRFREQ</b></a></h4>
This keyword selects the (sub-)fraction of Ulmschneider-Jorgensen (UJ)
CR moves (see <a href="references.html#ref14_3">J. Chem. Phys. 118 (9), pp4261-4271 (2003)</a>) according
to the formulas shown <a href="keywords.html#CRFREQ">above</a>.
Like any other exact CR move implemented in CAMPARI, UJ-CR moves
combine two strategies for efficient conformational sampling: the
approach of <a href="references.html#ref14_1">Favrin <i>et al.</i></a> (→ <a href="keywords.html#CRMODE">CRMODE</a>)
is used to obtain
a variable length pre-rotation which biases the end of the pre-rotation
segment to a position with high chance of having at least one real
solution when attempting to close it.
The closure problem is solved exactly using a numerical root search for
an algebraically transformed equation for the
following six degrees of freedom:
<ol>
  <li>Dihedral angle C<sub>i-2</sub>, N<sub>i-1</sub>, C<sub>α,i-1</sub>,
C<sub>i-1</sub> (φ<sub>i-1</sub>)</li>
  <li>Bond angle N<sub>i-1</sub>, C<sub>α,i-1</sub>, C<sub>i-1</sub></li>
  <li>Dihedral angle N<sub>i-1</sub>, C<sub>α,i-1</sub>, C<sub>i-1</sub>,
N<sub>i</sub> (ψ<sub>i-1</sub>)</li>
  <li>Bond angle C<sub>α,i-1</sub>, C<sub>i-1</sub>, N<sub>i</sub></li>
  <li>Bond angle C<sub>i-1</sub>, N<sub>i</sub>, C<sub>α,i</sub></li>
  <li>Dihedral angle C<sub>i-1</sub>, N<sub>i</sub>, C<sub>α,i</sub>, C<sub>i</sub>
(φ<sub>i</sub>)</li>
</ol>
This assumes the C-terminal constraint is defined by the "latter half"
of residue i. The pre-rotation
segment may be of variable length but must employ degrees of freedom
immediately preceding the closure segmen(&rarr; <a href="keywords.html#UJCRMIN">UJCRMIN</a> and <a
 href="keywords.html#UJCRMAX">UJCRMAX</a>).
The use of this method in general and specifically within CAMPARI is
marred as follows:<br/>
<ol>
  <li>The chain closure algorithm relies on a search process to
locate roots for a complicated equation, which makes repeated matrix
operations necessary which generate a considerable
computational overhead for a single UJ-CR move. This is true for all
exact CR methods, even much more so for exact torsional variants than
for UJ-CR moves (→ <a href="keywords.html#TORCRFREQ">TORCRFREQ</a>).</li>
  <li>The inclusion of bond angles into the pre-rotation stretch is not
a particularly useful extension but
required for reasons of ergodicity. Additional parameters are needed to
manage this aspect properly
(→ <a href="keywords.html#UJCRSCANG">UJCRSCANG</a>). The inclusion of
bond angles in the closure segments simplifies the root search
procedure by eliminating branches for solution space and generally
reducing the number of possible solutions. This makes the algorithm
faster than comparable methods using dihedral
angles only. However, varying bond angles cause two crucial issues:
  <ol style="list-style-type: lower-roman;">
    <li>Allowing bond angles to change violates CAMPARI's typical
paradigm of fixed
geometry in MC calculations and therefore might invalidate some of the
force field calibration done under this assumption. In general, it is
very important
to match the degrees of freedom chosen for the calibration phase of a
force field
with that for the application phase. The commonly held belief that the
introduction of constraints
does not alter the positions and relative weights of basins but merely
influences barriers in the
free energy landscape is <a href="references.html#ref24_11">not correct</a>.</li>
    <li>CAMPARI currently has no way of independently
sampling bond angles in Monte Carlo simulations. This means that
effectively a subset of all bond angles are
introduced as new degrees of freedom, for which is there is no <i>a
priori</i> justification whatsoever (in other words:
selectively sampling a few bond angles makes unjustified assumptions
about the remaining bond angles). It is
therefore recommended to use this feature with the utmost
caution until a more sound implementation surrounding it is added.
Presently, it may be most suitable
as part of the MC move set in hybrid runs (see <a
 href="keywords.html#DYNAMICS">DYNAMICS</a>) employing Cartesian
sampling in the dynamics portions (see <a href="keywords.html#CARTINT">CARTINT</a>)
although
this approach has its own caveats.</li>
  </ol>
  </li>
</ol>
Note that there currently is no analogous implementation of this
approach for nucleic acids even though
Ulmschneider and Jorgensen developed one. The only CR moves available
to nucleotides are exact torsional
CR moves (→ <a href="keywords.html#NUCCRFREQ">NUCCRFREQ</a>).
Final remarks: 1) for details on picking probabilities, see <a href="keywords.html#CRFREQ">above</a>;
2) these moves are using no parallelization whatsoever for the closure problem when CAMPARI's
<a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use, which is
a limitation.<br/>
<h4><a class="NoHi" id="TORCRFREQ"><b>TORCRFREQ</b></a></h4>
Aside from the UJ-CR moves which employ bond angles (see <a
 href="keywords.html#ANGCRFREQ">ANGCRFREQ</a>), analogous
methods have been formulated to instead employ exclusively dihedral
angles in both the closure and pre-rotation stretches.
This keyword sets the frequency with which both subtypes of those moves
occur during the simulation according
to the formulas listed <a href="keywords.html#CRFREQ">above</a>. The
preceding discussion has outlines the appeal
of exact CR methods and it is not repeated here. Much like Ulmschneider
and Jorgensen, CAMPARI employs a hybrid scheme
of biased pre-rotations according to <a href="references.html#ref14_1">Favrin <i>et al.</i></a> (see <a
 href="keywords.html#CRMODE">CRMODE</a>) and of exact closures
according to <a href="references.html#ref14_2">Dinner</a>. The latter half of the algorithm is the
cost-intensive one.
The algebraically transformed equation requires a numerical root
search, for which we use a modified Newton scheme
outlined <a href="keywords.html#UJCRSTEPSZ">below</a>. Typically,
multiple solutions need to be found, and a careful
weighting and bias-removal strategy has to be employed to choose
solutions with the proper probabilities (→
<a href="keywords.html#TORCRMODE">TORCRMODE</a>). Those comments apply
equally to exact polynucleotide CR moves (see <a
 href="keywords.html#NUCCRFREQ">NUCCRRFREQ</a>).
For polypeptides, there are two variants available which differ in which
peptide torsions are used to close the chain (described
<a href="keywords.html#TORCROFREQ">below</a>).<br/>
Note that proline (or any other cyclic residue with constrained
flexibility around any of the
backbone dihedral angles) causes additional problems. In theory, one could
formulate algebraic solutions
which skip the proline φ-torsion. Since the number and positions of
proline residues
in the closure stretch are not known <i>a priori</i>, this appears
impractical. We therefore provide
a coupling to (weakly biased and simplified) pucker moves (see <a
 href="keywords.html#PKRFREQ">PKRFREQ</a>) which
will simultaneously determine and propose a new pucker state while
solving the chain closure problem.
This means that:
<ol>
  <li>Sampling of the φ-angle becomes coupled to the proline sidechain
conformation (as it should be).</li>
  <li>The acceptance rate for CR moves will be significantly lower due
to the extra degrees of freedom included.</li>
  <li>The sampling of the sidechain conformation will be weakly biased
towards proper pucker states. In detail, some of
the proposed closures will yield φ-angle values incompatible with
sidechain closure and those will be discarded. For those
which yield a sane φ-angle, a corresponding χ<sub>1</sub>-value is
proposed with bias toward closable states. One of
two free bond angles is perturbed slightly in random fashion and the
last one is given by the closure as usual.</li>
  <li>Due to the above, it will be advantageous to not rely overly on
CR-sampling for proline-rich systems - both for
reasons of efficiency and accuracy. Conversely, it should be difficult
to find a statistically significant impact of
the sampler on global chain properties for polypeptides with low
proline content.</li>
</ol>
Final remarks: 1) for details on picking probabilities, see <a href="keywords.html#CRFREQ">above</a>;
2) unfortunately, these and all other exact torsional concerted rotation moves are (currently) unavailable when using
CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a>.<br/>
<h4><a class="NoHi" id="TORCROFREQ"><b>TORCROFREQ</b></a></h4>
This keyword lets the user set the fraction amongst exact, torsional
polypeptide CR moves to include ω-angles in the formulation of the
closure problem? Conversely, the remaining moves will use only
φ/ψ-angles to close the chain. Expected numbers for either type
are listed <a href="keywords.html#CRFREQ">above</a>.
In detail the ω-variant uses the following six degrees of freedom:<br/>
<ol>
  <li>Dihedral angle C<sub>α,i-2</sub>, C<sub>i-2</sub>, N<sub>i-1</sub>,
C<sub>α,i-1</sub> (ω<sub>i-1</sub>)</li>
  <li>Dihedral angle C<sub>i-2</sub>, N<sub>i-1</sub>, C<sub>α,i-1</sub>,
C<sub>i-1</sub> (φ<sub>i-1</sub>)</li>
  <li>Dihedral angle N<sub>i-1</sub>, C<sub>α,i-1</sub>, C<sub>i-1</sub>,
N<sub>i</sub> (ψ<sub>i-1</sub>)</li>
  <li>Dihedral angle C<sub>α,i-1</sub>, C<sub>i-1</sub>, N<sub>i</sub>,
C<sub>α,i</sub> (ω<sub>i</sub>)</li>
  <li>Dihedral angle C<sub>i-1</sub>, N<sub>i</sub>, C<sub>α,i</sub>, C<sub>i</sub>
(φ<sub>i</sub>)</li>
  <li>Dihedral angle N<sub>i</sub>, C<sub>α,i</sub>, C<sub>i</sub>, N<sub>i+1</sub>
(ψ<sub>i</sub>)</li>
</ol>
This implies that the carbonyl or carboxylate carbon atom of residue i 
with its three covalent bonding partners define the C-terminal constraint. The
pre-rotation segments consists of a certain
number of torsional degrees of freedom (including ω-angles) immediately
preceding the closure segment.<br/>
Conversely, for the non-ω-variant we have:<br/>
<ol>
  <li>Dihedral angle C<sub>i-3</sub>, N<sub>i-2</sub>, C<sub>α,i-2</sub>,
C<sub>i-2</sub> (φ<sub>i-2</sub>)</li>
  <li>Dihedral angle N<sub>i-2</sub>, C<sub>α,i-2</sub>, C<sub>i-2</sub>,
N<sub>i-1</sub> (ψ<sub>i-2</sub>)</li>
  <li>Dihedral angle C<sub>i-2</sub>, N<sub>i-1</sub>, C<sub>α,i-1</sub>,
C<sub>i-1</sub> (φ<sub>i-1</sub>)</li>
  <li>Dihedral angle N<sub>i-1</sub>, C<sub>α,i-1</sub>, C<sub>i-1</sub>,
N<sub>i</sub> (ψ<sub>i-1</sub>)</li>
  <li>Dihedral angle C<sub>i-1</sub>, N<sub>i</sub>, C<sub>α,i</sub>, C<sub>i</sub>
(φ<sub>i</sub>)</li>
  <li>Dihedral angle N<sub>i</sub>, C<sub>α,i</sub>, C<sub>i</sub>, N<sub>i+1</sub>
(ψ<sub>i</sub>)</li>
</ol>
Again, this implies that the carbonyl or carboxylate carbon atom of residue i 
with its three covalent bonding partners define the C-terminal constraint. 
The pre-rotation segments consists of a certain
number of torsional degrees of freedom (<b>in</b>cluding ω-angles)
immediately preceding the closure segment.
This implies that the minimal peptides needed for these moves to be
applicable is different:
For those including ω-bond sampling, the minimal peptide is an uncapped
peptide
of three amino acids: the first ψ-angle serves as the pre-rotation
segment, and the ω-, φ-,
and ψ-angles of residues two and three serve to close the chain. For
those not including
omega sampling, the minimal peptide is an N-capped peptide of three
amino acids in length.
Here, the ω-angle of the first amino acid residue serves as the
pre-rotation segment and the
phi- and ψ-angles of the three peptide residue serve to close the chain.
For details on picking probabilities, see <a href="keywords.html#CRFREQ">above</a>.<br/>
The need for different implementations is that the problems differ
algebraically (for once) and that
the stiffness of the ω-bond may make those moves using the ω-bonds in
the closure particularly ineffective. This is not the only reason,
however, to favor the non-ω-variant which is also better-behaved
in terms of finding solutions to the closure reliably. Note that
several diagnostics of the performance of exact CR
methods are reported during the simulation and after its completion in
the log-file.<br/>
<h4><a class="NoHi" id="CRMODE"><b>CRMODE</b></a></h4>
This defines the mode to use for concerted rotation moves roughly
according to the Favrin <i>et al.</i> reference: <a href="references.html#ref14_1">J. Chem. Phys. 114 (18),
8154-8158 (2001)</a>. In
general, this type of move attempts to introduce correlation into a MC
move by coupling several consecutive backbone angles
(only φ/ψ are considered) together to minimize a cost function which in
this case is
the difference of the position of the last atom in the stretch
compared to its original position. Larger biases lead to smaller moves
and higher acceptance. More often than not, this algorithm suffers
from its computational inefficiency. Because the loop is only
approximately closed, energy evaluations of high complexity (even
more expensive than a pivot move) are necessary. It is not recommended
to use moves of this type extensively.<br/>
<br/>
There are two modes available:<br/>
<ol>
  <li>A matrix relating changes in the degrees of freedom to changes in
the cost function (dr/dφ)
is computed by considering effective lever arms. In this implementation
six effective restraints are imposed through the three reference atoms
(N, C<sub>α</sub>, C)
on the residue following the last one of those whose torsions are
sampled (note, though, that algorithmically all nine Cartesian
positions are used). Note that this mode therefore requires an
additional buffer
residue at the C-terminus. Specifically, sampling is possible only
within
an interval from the third residue (in addition to the ineligible
terminal residues, there is a symmetry-creating N-terminal buffer
residue as well)
to the third last residue in each polypeptide chain. In that sense,
these moves are trivially non-ergodic since they fail to sample
a subset of the chosen degrees of freedom (<i>i.e.</i>, those within
terminal residues).
  </li>
  <li>The dr/dφ matrix is computed by nested rotation matrices
(propagating changes via matrix multiplication). This directly accounts
for peptide geometry
within the reference atoms and yields six actual restraints. Here, the
reference atoms are C<sub>α</sub>, C, and O on the last residue
of which torsions are to be sampled. The implementation with nested
rotation matrices is costlier and this mode is only marginally
supported, <i>i.e.,</i> offers very limited adaptability through the
keywords below.</li>
</ol>
These inexact CR moves are supported exclusively for polypeptides and
sample only their φ/ψ-angles. For details on picking probabilities, see <a href="keywords.html#CRFREQ">above</a>.<br/>
<h4><a class="NoHi" id="CRDOF"><b>CRDOF</b></a></h4>
If inexact concerted rotation moves for polypeptides are in use (→ <a
 href="keywords.html#CRMODE">CRMODE</a>), this keyword allows the user
to provide the exact number of torsions to use each time such a move is
performed.
The default value is eight but a different number may be chosen as long
as the chain is
long enough to accommodate these moves. A minimum of seven degrees of
freedom applies since the linear equations are otherwise
overdetermined and only trivial solutions are (asymptotically) found.
Note that this keyword is only supported if <a
 href="keywords.html#CRMODE">CRMODE</a>
is set to 1. Extensions of this to support mode 2 or to allow random,
variable lengths during the simulations are currently not anticipated.
This is due to
the overall inefficiency of the <a href="references.html#ref14_1">Favrin <i>et al. approach</i></a>
(see discussion <a href="keywords.html#CRMODE">here</a>).<br/>
<h4><a class="NoHi" id="CRWIDTH"><b>CRWIDTH</b></a></h4>
This keyword gives the standard deviation in radian of the random
normal distribution underlying inexact concerted rotation moves for polypeptides
(→ <a href="keywords.html#CRMODE">CRMODE</a>), from
which the (unbiased) displacement vectors are implicitly drawn. This
corresponds
to parameter "a" in the <a href="references.html#ref14_1">reference</a> but is specified here as its inverse
(a = 1/CRWIDTH). Note that the actual resultant distribution width is only
set by this keyword if the
<a href="keywords.html#CRBIAS">bias</a> toward minimizing the cost
function is zero. If the latter
is non-zero the resultant distribution width will be co-controlled by
the setting for <a href="keywords.html#CRBIAS">CRBIAS</a>.
Note that only values up to &pi;/2 may be specified to avoid wrap-around
artifacts which may upset
the procedure of removing the bias from these moves.<br/>
<h4><a class="NoHi" id="CRBIAS"><b>CRBIAS</b></a></h4>
This keyword specifies the strength of the bias for inexact concerted rotation moves for polypeptides
(→ <a href="keywords.html#CRMODE">CRMODE</a>) and corresponds to
parameter "b" in the <a href="references.html#ref14_1">reference</a>.
It essentially controls how close the end of the rotated segment will
end up to its original position (satisfying the restraints).
Unfortunately, this also co-regulates the step size, hence there is a
need for parameter optimization (<i>i.e.</i>,
the variance of the resultant biased distribution cannot be controlled
easily). Intuitively, the reason is that - in a linear response-type
theory -
tiny step sizes always represent one way of satisfying the restraint.
Note that with a choice of zero for this keyword,
these inexact CR moves relax to random pivot moves of multiple
residues in a row (→ <a href="keywords.html#CRDOF">CRDOF</a>)
with a sampling width controlled by <a href="keywords.html#CRWIDTH">CRWIDTH</a>.
Conversely, when choosing very large numbers
for this keyword, it should be kept in mind that the evaluation of the
acceptance criterion requires inclusion
of an exponential factor, exp[- (Δφ<sup>T</sup><b> A </b>Δφ) + (Δφ'<sup>T</sup><b>
A' </b>Δφ') ]. Here, the primed quantities are for the reverse move.
Matrix <b>A</b> is diagonal
if this keyword is set to zero which implies <b>A</b> = <b>A'</b>,
and the bias correction is unity. For large values of CRBIAS, the
two elements within the exponential become disparate in magnitude very
quickly and the exponential may exceed numerical limits
even for double precision variables. This may cause some compilers to
throw exceptions. Note that the complete bias
correction formula includes the determinant of matrix <b>A</b> as well.<br/>
<h4><a class="NoHi" id="UJCRBIAS"><b>UJCRBIAS</b></a></h4>
Despite its name, this keyword regulates the biasing strength for the
pre-rotation
steps in <b>all</b> exact CR methods, <i>i.e.</i>, nucleic acid CR moves,
UJ-CR moves
and both types of exact polypeptide CR moves (→ <a
 href="keywords.html#ANGCRFREQ">ANGCRFREQ</a>,
<a href="keywords.html#TORCRFREQ">TORCRFREQ</a>, and <a
 href="keywords.html#NUCCRFREQ">NUCCRFREQ</a>).
The strength of the bias controls how close the end of the pre-rotation
segment remains to its original position hence improving the chances
for successful closure. This parameter is
strongly co-dependent "with" the default distribution width in the
absence of any bias (→ <a href="keywords.html#UJCRWIDTH">UJCRWIDTH</a>).
This
keyword parameter is analogous to <a href="keywords.html#CRBIAS">CRBIAS</a>
in the <a href="references.html#ref14_1">Favrin <i>et al. scheme</i></a> and
is called "c2" in the <a href="references.html#ref14_3">UJ reference</a>. It should be stressed that all
caveats outlined <a href="keywords.html#CRBIAS">above</a>
apply here as well.
<br/>
<h4><a class="NoHi" id="UJCRWIDTH"><b>UJCRWIDTH</b></a></h4>
Despite its name, this keyword regulates the general (in the absence of
bias) width of the distribution (in degrees)
sampled in the pre-rotation segment for <b>all</b> exact CR methods (→ <a
 href="keywords.html#ANGCRFREQ">ANGCRFREQ</a>,
<a href="keywords.html#TORCRFREQ">TORCRFREQ</a>, and <a
 href="keywords.html#NUCCRFREQ">NUCCRFREQ</a>).
As in the <a href="references.html#ref14_1">Favrin <i>et al. scheme</i></a> (which is practically embedded in all exact
CR methods implemented in CAMPARI),
the resultant width is co-dependent on the bias factor (see <a
 href="keywords.html#UJCRBIAS">UJCRBIAS</a>
and for comparison: <a href="keywords.html#CRBIAS">CRBIAS</a> and <a
 href="keywords.html#CRWIDTH">CRWIDTH</a>). It corresponds to "1/c1" in
the <a href="references.html#ref14_3">UJ reference</a> and therefore larger values give wider distributions.<br/>
<h4><a class="NoHi" id="UJCRSTEPSZ"><b>UJCRSTEPSZ</b></a></h4>
The chain closure algorithm works in most exact CR
implementations by reducing a multi-dimensional variable search to a 1D
root-search, which is then solved by some form of step-through protocol
and subsequent
bisection. This keyword allows the user to choose the step-size for
that root search in degrees for <b>all</b> exact CR methods. Currently, the
UJ-CR method (→ <a href="keywords.html#ANGCRFREQ">ANGCRFREQ</a>) uses
a simple, non-adaptive stepping protocol (see also <a
 href="keywords.html#UJCRINTERVAL">UJCRINTERVAL</a>). Larger step-sizes
there increase
the speed of the algorithm significantly, but also increase the
fraction of attempts in which no solution is found at all (a
quantity reported at the end of the log-file). The recommended value by
the authors is 0.05°. Conversely, the exact torsional CR methods for
both
polypeptides and polynucleotides (→ <a href="keywords.html#TORCRFREQ">TORCRFREQ</a>
and <a href="keywords.html#NUCCRFREQ">NUCCRFREQ</a>) employ a modified
Newton scheme to map out
the complete solution space in three hierarchical steps. In those
cases, this
keywords merely defines the largest step size to ever be used (<i>i.e.</i>,
if target function
and derivative indicate that no root is near, the step size is not
adjusted to very large
values but instead to the value given by this keyword). For these
methods, a setting of
around 1.0 appears much more appropriate. In the future, the
implementation of the UJ-CR method may be adjusted to use the same protocol as the
torsional methods. For clarity, it shall be repeated that this keyword applies to
<b>all</b>
exact CR methods (but is inapplicable to inexact CR moves: &rarr; <a href="keywords.html#CRMODE">CRMODE</a>).
It is very important to understand that the numerical root search will
invariably be unreliable, <i>i.e.</i>,
that there are conformations for which the function may be approaching
zero asymptotically while
also approaching imaginary solution space. This implies that with such
a technique, it will be nearly
impossible to eliminate all biases rigorously although it will be
possible to reduce their amplitude
below that of statistical noise, even when the settings are such that satisfactory
computational efficiency is provided (which of course is a crucial element to consider for expensive
algorithms such as exact CR methods).<br/>
<h4><a class="NoHi" id="UJCRMIN"><b>UJCRMIN</b></a></h4>
Specifically for the bond angle-based Ulmschneider-Jorgensen algorithm (→ <a
 href="keywords.html#ANGCRFREQ">ANGCRFREQ</a>), this specifies the
minimum requested length (in terms of number of residues) for the
pre-rotation
segment in the implementation. Note that if no molecule in the system
is at least UJCRMIN+4 residues
long (two for closure, two terminal buffer residues that can be caps), CR moves will be
disabled entirely. Due to the problems outlined above, this suboptimal
implementation has not yet been improved. Note that UJCRMIN and <a
 href="keywords.html#UJCRMIN">UJCRMAX</a> are analogous to keywords <a
 href="keywords.html#TORCRMIN_DO">TORCRMIN_DO</a> and <a
 href="keywords.html#TORCRMAX_DO">TORCRMAX_DO</a>, but
use residue numbers instead of numbers of degrees of freedom.
Another restriction is that - unlike for <a href="keywords.html#TORCRMIN_DO">TORCRMIN_DO</a>
and analogous keywords - UJCRMIN is enforced strictly, <i>i.e.</i>,
candidate residues are only those that provide the correct padding
on either side (for the exact, torsional variants, the specified minimum padding
is generally adjusted to the absolute minimum for stretches that would
otherwise be too short).
Therefore, the implementation
of the angular UJ-CR moves generally offers less flexibility.<br/>
<h4><a class="NoHi" id="UJCRMAX"><b>UJCRMAX</b></a></h4>
Specifically for the bond angle-based Ulmschneider-Jorgensen algorithm (→ <a
 href="keywords.html#ANGCRFREQ">ANGCRFREQ</a>), this keyword specifies
the maximum requested length (in numbers of residues) for the
pre-rotation
segment in those moves. Note that this parameter is automatically
reduced if a move is
attempted for a molecule which is too short to allow
the full range of segment lengths (but long enough to satisfy <a
 href="keywords.html#UJCRMIN">UJCRMIN</a> of course). This will make it
difficult
to predict the resultant distribution of pre-rotation segment lengths
(compare <a href="keywords.html#TORCRMIN_DO">TORCRMIN_DO</a>).<br/>
<h4><a class="NoHi" id="UJCRINTERVAL"><b>UJCRINTERVAL</b></a></h4>
Specifically for the bond angle-based 
Ulmschneider-Jorgensen algorithm (→ <a href="keywords.html#ANGCRFREQ">ANGCRFREQ</a>),
this keyword
lets the user choose the size of the search interval for the
one-dimensional root-search (see <a href="keywords.html#UJCRSTEPSZ">UJCRSTEPSZ</a>).
The algebraically isolated degree
of freedom is scanned over the interval [φ-d;φ+d] where φ is the
original value and d is the (half-)interval size specified by this
keyword. The recommended value
is 20.0°. Note that this implementation is unique to the bond angle
UJ-CR method and offers
much reduced overhead cost per CR move compared to the exhaustive
search performed by exact torsional
methods. The efficiency and justifiability of the method both rely on
the crucial assumption that - given a typical pre-rotation -
approximately one solution will be found in the scanned interval. If
the
number of solutions is often zero or larger than one, the algorithm
violates detailed balance and the
resultant distributions will be strongly biased. It is generally
recommended to analyze the performance
of the algorithm beforehand by checking for proper Boltzmann weights in
the distributions of both torsional
and angular degrees of freedom. This is most easily and meaningfully
done employing only bond angle potentials
(→ <a href="keywords.html#SC_BONDED_A">SC_BONDED_A</a>) but no other
terms in the Hamiltonian. Then, the distributions of the dihedral angles must
be flat and those for the angular degrees of freedom must be such that
to -k<sub>b</sub>T·ln(p(α)) equals the acting bond angle potential on α.<br/>
<h4><a class="NoHi" id="UJCRSCANG"><b>UJCRSCANG</b></a></h4>
This keyword applies exclusively to the bond angle-based
Ulmschneider-Jorgensen CR algorithm for
polypeptides (→ <a href="keywords.html#ANGCRFREQ">ANGCRFREQ</a>). It
lets the user set a scaling factor to reduce the magnitude of
pre-rotation perturbations of bond angle degrees of freedom (in the
absence of pre-rotation bias, resultant width will be proportional to
<a href="keywords.html#UJCRWIDTH">UJCRWIDTH</a>&#183;UJSCRANG → values
less than unity are desirable).
Large perturbations on those bond angles would reduce the efficacy of the method
considerably due to the stiff potentials typically used to keep bond
angles in the valid regimes.
Note that the UJ-CR method never considers ω-angles for conformational
sampling and that
they are consequently excluded from pre-rotation sampling in their
entirety. This is a bit of
an arbitrary choice - in particular when considering the problems
introduced by the bond
angle sampling in the first place (discussion <a
 href="keywords.html#ANGCRFREQ">here</a>) - and remedied in exact but
purely torsional CR methods (→ <a href="keywords.html#TORCRFREQ">TORCRFREQ</a>).
The parameter specified here corresponds to "1/c3" in the <a href="references.html#ref14_3">UJ reference</a>.<br/>
<h4><a class="NoHi" id="TORCRMODE"><b>TORCRMODE</b></a></h4>
Unlike standard MC moves (such as φ/ψ-pivot
moves), exact CR methods do not
constitute an ergodic move set beyond the subspace satisfying the
constraint (which
is of course invariant toward sampling on that manifold). This
necessitates mixing
exact CR moves with other types of moves to achieve sampling of the
entire phase space.
Moreover, they solve an analytical problem numerically with finite
error rate, <i>i.e.</i>,
not all solutions are always found. If these errors are dependent on
the "position"
of the constraint, <i>i.e.</i>, on polymer conformation, the resultant
sampling is biased even though Jacobian corrections are applied. This
small bias is nearly impossible to
remove entirely. CAMPARI supports two implementations for exact,
torsional CR methods:
<ul>
  <li> When set to 1, at each step, a superset of solutions is created
containing the original solution, a
set of alternative closures given the original pre-rotation state, and
a set of new conformations
with a given, altered pre-rotation state and a set of closures for that
altered state.
For each solution, the Jacobian determinants with respect to the closure constraint
and the pre-rotation
constraint are evaluated, multiplied, and a solution is picked using
the net Jacobian
as a weight factor. The chosen move is then evaluated via the <a href="keywords.html#MC_ACCEPT">acceptance criterion</a>
given the additional
bias correction of evaluating the randomness of the pre-rotation move
forward and backward
as in the <a href="references.html#ref14_1">Favrin <i>et al. scheme</i></a>. In the absence of any pre-rotation bias,
this algorithm
is conceptually rejection-free. It also (in theory) satisfies detailed balance on
account of the construction
of the solution superset.</li>
  <li> When set to 2, at each step, a finite number of trials (see <a
 href="keywords.html#UJMAXTRIES">UJMAXTRIES</a>) of pre-rotations
according to the <a href="references.html#ref14_1">Favrin <i>et al. scheme</i></a> is performed. Closure is attempted
and in case solutions are found, the possible closures
along with the sampled pre-rotation constitute the set of possible
moves. A random one is chosen
(uniform probability) and the new conformation is evaluated via
Metropolis with the Jacobian
corrections for the proposed vs. the current state (with respect to
both types of constraints) and
the randomness correction for the pre-rotation step. Because solutions
only need to be found
given the pre-rotation, this algorithm is usually twice as fast as the
one above given sane
pre-rotation settings. This implementation does not satisfy detailed
balance even in theory but
attempts to remain globally balanced.</li>
</ul>
Note that this keyword applies to all exact, torsional CR methods, <i>i.e.</i>,
to torsional
polypeptide CR (→ <a href="keywords.html#TORCRFREQ">TORCRFREQ</a> and <a
 href="keywords.html#TORCROFREQ">TORCROFREQ</a>)
as well as to nucleic acid CR (→ <a href="keywords.html#NUCCRFREQ">NUCCRFREQ</a>)
but that it is not (yet)
supported for the Ulmschneider-Jorgensen bond-angle CR algorithm (→ <a
 href="keywords.html#ANGCRFREQ">ANGCRFREQ</a>)
and inapplicable to the <a href="references.html#ref14_1">Favrin <i>et al. scheme</i></a> (→ <a
 href="keywords.html#CRMODE">CRMODE</a>).<br/>
<h4><a class="NoHi" id="TORCRMIN_DO"><b>TORCRMIN_DO</b></a></h4>
This specifies the minimum requested number of degrees of freedom for
the pre-rotation segment for
exact CR moves for polypeptides utilizing ω-angles during closure (→ <a
 href="keywords.html#TORCRFREQ">TORCRFREQ</a>).
Note that this minimum number is <i>not</i> rigorously enforced but
will be ignored
if closure residues too close to the N-terminus are used. This is done
in the interest of generality and to prevent the code from disabling
these types of moves frequently. It is therefore not as straightforward
as one may think to compute the expected distribution of pre-rotation
segment lengths (and which residues
are part of them with what probability) for each polypeptide. Note that
here numbers of <i>degrees of freedom</i>
are specified whereas for the bond angle UJ method, numbers of <i>residues</i>
are specified
(→ <a href="keywords.html#UJCRMIN">UJCRMIN</a>).<br/>
<h4><a class="NoHi" id="TORCRMAX_DO"><b>TORCRMAX_DO</b></a></h4>
This specifies the maximum requested number of degrees of freedom for
the pre-rotation segment for
exact CR moves for polypeptides utilizing ω-angles during closure (→ <a
 href="keywords.html#TORCRFREQ">TORCRFREQ</a>).
Note that this maximum number is in fact a rigorous upper limit and
never exceeded <i>but</i> that the length of some polypeptides in
the system may be such that it is never realizable. In the latter case,
there will be an additional complication in predicting the resultant
distribution of pre-rotation segment lengths
(see <a href="keywords.html#TORCRMIN_DO">TORCRMIN_DO</a> as well).<br/>
<h4><a class="NoHi" id="TORCRMIN_DJ"><b>TORCRMIN_DJ</b></a></h4>
This keyword is exactly analogous to <a
 href="keywords.html#TORCRMIN_DO">TORCRMIN_DO</a> but applies to exact
CR moves
for polypeptides without using ω-angles in the closure.<br/>
<h4><a class="NoHi" id="TORCRMAX_DJ"><b>TORCRMAX_DJ</b></a></h4>
This keyword is exactly analogous to <a
 href="keywords.html#TORCRMAX_DO">TORCRMAX_DO</a> but applies to exact
CR moves
for polypeptides without using ω-angles in the closure.<br/>
<h4><a class="NoHi" id="TORCRSCOME"><b>TORCRSCOME</b></a></h4>
This parameter is analogous to <a href="keywords.html#UJCRSCANG">UJCRSCANG</a>
and scales down the magnitude of
the step-size for ω-bonds in the pre-rotation segment of exact
torsional CR methods for polypeptides. Since
stiff torsional potentials usually act on ω-bonds (→ <a
 href="keywords.html#OMEGAFREQ">OMEGAFREQ</a>), the
likelihood of obtaining rejected moves mostly on account of excursions
of the ω-angle is high. This unwanted
behavior may be alleviated by employing small values for TORCRSCOME.
Remember, however, that the pre-rotation
step size will often be relatively small in general.<br/>
<h4><a class="NoHi" id="UJMAXTRIES"><b>UJMAXTRIES</b></a></h4>
Despite its name, this keyword regulates the maximum number of
pre-rotation sampling events to consider
in exact, torsional CR methods with <a href="keywords.html#TORCRMODE">TORCRMODE</a>
set to 2. If no solution is found within UJMAXTRIES, the
move is counted as rejected. Naturally, detailed balance is maintained
only if there is always at least
one solution found given the new pre-rotation (<i>i.e.</i>, this
keyword is rendered obsolete). As alluded
to above, this is never the case for the entirety of a simulation. It
is difficult to predict what setting in those cases would best
preserve global balance. The main utility of this keyword, however,
lies in different sampling applications,
<i>e.g.</i>, in the efficient and exhaustive sampling of different loop
conformations given a fixed constraint.<br/>
<h4><a class="NoHi" id="NUCCRMIN"><b>NUCCRMIN</b></a></h4>
This keyword is analogous to <a href="keywords.html#TORCRMIN_DO">TORCRMIN_DO</a>
but applies to exact CR moves
for polynucleotides. Note that the sugar bond (C3*-C4*) is always
excluded from pre-rotation sampling.<br/>
<h4><a class="NoHi" id="NUCCRMAX"><b>NUCCRMAX</b></a></h4>
This keyword is analogous to <a href="keywords.html#TORCRMAX_DO">TORCRMAX_DO</a>
but applies to exact CR moves
for polynucleotides. Note that the sugar bond (C3*-C4*) is always
excluded from pre-rotation sampling.<br/>
<h4><a class="NoHi" id="PHFREQ"><b>PHFREQ</b></a></h4>
This is the frequency out of all sidechain moves (see <a
 href="keywords.html#CHIFREQ">CHIFREQ</a>) whether to perform a
(de)ionization MC move.
These moves will be turned off automatically in case there
are no titratable residues in the system (currently only polypeptide
residues D, E, R, K, and H (use neutral form) are supported). Note that
these are pseudo-MC moves,
<i>i.e.</i>, they do not interface intuitively with the rest of the MC
code. This means
that the guidance criterion for accepting / rejecting titration moves
is based on a distinct and simplified energy
evaluation which has no impact on the actual Markov chain. These moves
are therefore analyzing (on-the-fly) an independently
generated Markov chain (using whatever Hamiltonian was specified) but
do not perturb the conformational ensemble generated by said Markov
chain in any way.
This essentially corresponds to the assumption that the generated
ensemble is independent of titration states -
an assumption which is always wrong but may - in certain circumstances
such as extreme denaturing conditions - nonetheless
be justified. These moves rely on environmental settings (<a
 href="keywords.html#PH">PH</a> and <a href="keywords.html#IONICSTR">IONICSTR</a>)
and are required for obtaining output in <a
 href="outputfiles.html#PHTIT.dat">PHTIT.dat</a>. The default picking probabilities
for ionizable residues are flat and cannot be altered.<br/>
<h4><a class="NoHi" id="PSWFILE"><b>PSWFILE</b></a></h4>
This keyword specifies name and location (full or relative path) of an optional
input file parsed to alter the default picking probabilities for all types of moves in CAMPARI at most
down to the residue level (but not further). In general, the idea of preferential
sampling rests on the realization that any ergodic and unbiased move set is theoretically capable
of producing a Markov chain yielding the correct phase space distribution. This means that the sampling
weights given to degrees of freedom of the system need not be equivalent, but rather can be chosen
arbitrarily (as long as a choice of zero somewhere does not eliminate ergodicity). Of course, the
convergence properties of a Monte Carlo simulation are an exceptionally complicated function of the move set,
and therefore deviation from default choices should be properly justified. Examples have been
listed above, <i>e.g.</i> in the discussion of <a href="keywords.html#CHIFREQ">sidechain sampling</a>.<br/>
CAMPARI generally allows the preferential sampling facility to overlap with
<a href="keywords.html#FRZFILE">user-level constraints</a>. Constraints are applied first, and then
picking probabilities are altered. In the process, it is possible to effectively introduce
additional constraints on account of setting selected sampling weights to zero. This is tolerated as long
as it does not deplete the pool for a class of moves entirely. In such a case, the program terminates
with an error. There is a notable difference in zero sampling weights and constraint requests
for concerted rotation moves of polymers (described <a href="keywords.html#CRFREQ">elsewhere</a>).
Note that it is not possible to control frequencies that would lead to incorrect sampling. In particular,
it is impossible to control picking probabilities for <a href="keywords.html#PARTICLEFLUCFREQ">particle permutation moves</a>,
and <a href="keywords.html#PARTICLEFLUCFREQ">particle insertion and deletion</a> moves can only be controlled
down to the molecule type level. Rigid-body moves are generally limited to the scope of molecules, not residues.
The format of the input file is described <a href="inputfiles.html#FMCSC_PSWFILE">elsewhere</a>.<br/>
<h4><a class="NoHi" id="PSWREPORT"><b>PSWREPORT</b></a></h4>
If the default picking probabilities are altered (→ <a href="keywords.html#PSWFILE">PSWFILE</a>)
in torsional space Monte Carlo simulations,
this keyword acts as a simple logical whether or not to write out a
summary of the resultant picking frequencies for every move type that is active and has been modified (to the log-file).<br/>
<br/>
<br/>
<br/>
<h3><a class="NoHi" id="files_directories">Files and Directories:</a></h3>
<hr style="width: 100%; height: 2px;"></hr> (<a href="keywords.html#TOP">back to top</a>)<br/>
<h4><i>Preamble (this is not a keyword)</i></h4>
In general, files and directories should be provided using absolute paths. This is often
advantageous in deployment-based computing where relative directory structures
and/or shortcuts may change or not exist. However, CAMPARI may fail in reading strings
longer than 200 characters leading to truncation and subsequent failure. This should be kept in mind.
Also, this section is merely a list of the auxiliary files potentially required by CAMPARI.
The functionalities itself (including the files) are usually explained elsewhere (links are provided).<br/>
<br/>
<hr/>
<h4><a class="NoHi" id="BASENAME"><b>BASENAME</b></a></h4>
This keyword allows the user to pick a name for the simulation/system that is going to be used
in the names of all <a href="outputfiles.html#trajectory_output">structural output files</a>.
However, all other output files produced by CAMPARI use generic names and will be overwritten
if simulations are continuously run in the same directory.<br/>
<h4><a class="NoHi" id="SEQFILE"><b>SEQFILE</b></a></h4>
This is the most important input file as it instructs CAMPARI which system to simulate.
Its format and possible entries are explained in detail <a href="inputfiles.html#FMCSC_SEQFILE">elsewhere</a>.<br/>
<h4><a class="NoHi" id="SEQREPORT"><b>SEQREPORT</b></a></h4>
This keyword is a simple logical (specifying 1 means "true", everything else means "false") that
controls whether CAMPARI writes out a summary of some of the system's features initially.
In detail, it will provide an overview of the identified molecule types, <i>viz.</i>, the numbers of each
molecule type present, the first instance, their formal concentration, their molecular mass,
and their high-level suitability for performing
CAMPARI-internal analyses. The latter would for example report that urea molecules are not
suitable for peptide-centric analysis such as <a href="keywords.html#DSSPCALC">secondary structure analyses</a>.
In addition, the parsing of these molecule types into <a href="keywords.html#ANGRPFILE">analysis groups</a>
is written to log-output.<br/>
<h4><a class="NoHi" id="PDBFILE2"><b>PDBFILE</b></a></h4>
Among other functions, this is the main input file for providing a starting conformation for 
a simulation. See <a href="keywords.html#PDBFILE">below</a> for details.<br/>
<h4><a class="NoHi" id="DCDFILE2"><b>DCDFILE</b></a></h4>
&nbsp;See <a href="keywords.html#DCDFILE">below</a>.<br/>
<h4><a class="NoHi" id="XTCFILE2"><b>XTCFILE</b></a></h4>
&nbsp;See <a href="keywords.html#XTCFILE">below</a>.<br/>
<h4><a class="NoHi" id="NETCDFFILE2"><b>NETCDFFILE</b></a></h4>
&nbsp;See <a href="keywords.html#NETCDFFILE">below</a>.<br/>
<!--<h4><a class="NoHi" id="FYCFILE2"><b>FYCFILE</b></a></h4>
&nbsp;See <a href="keywords.html#FYCFILE">below</a>.<br/>-->
<h4><a class="NoHi" id="FRZFILE2"><b>FRZFILE</b></a></h4>
&nbsp;See <a href="keywords.html#FRZFILE">above</a>.<br/>
<h4><a class="NoHi" id="PSWFILE2"><b>PSWFILE</b></a></h4>
&nbsp;See <a href="keywords.html#PSWFILE">above</a>.<br/>
<h4><a class="NoHi" id="SHAKEFILE2"><b>SHAKEFILE</b></a></h4>
&nbsp;See <a href="keywords.html#SHAKEFILE">above</a>.<br/>
<h4><a class="NoHi" id="PARTICLEFLUCFILE"><b>PARTICLEFLUCFILE</b></a></h4>
This keyword is relevant only when <a href="keywords.html#ENSEMBLE">ENSEMBLE</a> is set to either 5 or 6 (ensembles
with fluctuating particle numbers). It provides the location of the file that
specifies the particle types that are allowed to fluctuate, the numbers of particles of those types to
initially include in the system, and the chemical potentials of each
fluctuating particle type (see <a href="inputfiles.html#FMCSC_PARTICLEFLUCFILE">here</a>).
<h4><a class="NoHi" id="REFILE2"><b>REFILE</b></a></h4>
&nbsp;See <a href="keywords.html#REFILE">below</a>.<br/>
<h4><a class="NoHi" id="FEGFILE"><b>FEGFILE</b></a></h4>
This keyword lets the user specify name and location of the <a href="inputfiles.html#FMCSC_FEGFILE">input file</a>
from which CAMPARI extracts which residues and/or molecules to subject to scaled interaction
potentials with the rest of the system in free energy growth (<a href="keywords.html#GHOST">ghosting</a>)
calculations.<br/>
<h4><a class="NoHi" id="DRESTFILE2"><b>DRESTFILE</b></a></h4>
&nbsp;See <a href="keywords.html#DRESTFILE">below</a>.<br/>
<h4><a class="NoHi" id="BIOTYPEPATCHFILE2"><b>BIOTYPEPATCHFILE</b></a></h4>
&nbsp;See <a href="keywords.html#BIOTYPEPATCHFILE">above</a>.<br/>
<h4><a class="NoHi" id="MPATCHFILE2"><b>MPATCHFILE</b></a></h4>
&nbsp;See <a href="keywords.html#MPATCHFILE">above</a>.<br/>
<h4><a class="NoHi" id="RPATCHFILE2"><b>RPATCHFILE</b></a></h4>
&nbsp;See <a href="keywords.html#RPATCHFILE">above</a>.<br/>
<h4><a class="NoHi" id="BPATCHFILE2"><b>BPATCHFILE</b></a></h4>
&nbsp;See <a href="keywords.html#BPATCHFILE">below</a>.<br/>
<h4><a class="NoHi" id="LJPATCHFILE2"><b>LJPATCHFILE</b></a></h4>
&nbsp;See <a href="keywords.html#LJPATCHFILE">below</a>.<br/>
<h4><a class="NoHi" id="CPATCHFILE2"><b>CPATCHFILE</b></a></h4>
&nbsp;See <a href="keywords.html#CPATCHFILE">below</a>.<br/>
<h4><a class="NoHi" id="FOSPATCHFILE2"><b>FOSPATCHFILE</b></a></h4>
&nbsp;See <a href="keywords.html#FOSPATCHFILE">below</a>.<br/>
<h4><a class="NoHi" id="SAVPATCHFILE2"><b>SAVPATCHFILE</b></a></h4>
&nbsp;See <a href="keywords.html#SAVPATCHFILE">below</a>.<br/>
<h4><a class="NoHi" id="ASRPATCHFILE2"><b>ASRPATCHFILE</b></a></h4>
&nbsp;See <a href="keywords.html#ASRPATCHFILE">below</a>.<br/>
<h4><a class="NoHi" id="NCPATCHFILE2"><b>NCPATCHFILE</b></a></h4>
&nbsp;See <a href="keywords.html#NCPATCHFILE">below</a>.<br/>
<h4><a class="NoHi" id="TORFILE2"><b>TORFILE</b></a></h4>
&nbsp;See <a href="keywords.html#TORFILE">below</a>.<br/>
<h4><a class="NoHi" id="POLYFILE2"><b>POLYFILE</b></a></h4>
&nbsp;See <a href="keywords.html#POLYFILE">below</a>.<br/>
<h4><a class="NoHi" id="TABCODEFILE2"><b>TABCODEFILE</b></a></h4>
&nbsp;See <a href="keywords.html#TABCODEFILE">below</a>.<br/>
<h4><a class="NoHi" id="TABPOTFILE2"><b>TABPOTFILE</b></a></h4>
&nbsp;See <a href="keywords.html#TABPOTFILE">below</a>.<br/>
<h4><a class="NoHi" id="TABTANGFILE2"><b>TABTANGFILE</b></a></h4>
&nbsp;See <a href="keywords.html#TABTANGFILE">below</a>.<br/>
<h4><a class="NoHi" id="EMMAPFILE2"><b>EMMAPFILE</b></a></h4>
See <a href="keywords.html#EMMAPFILE">below</a>.<br/>
<h4><a class="NoHi" id="WL_GINITFILE2"><b>WL_GINITFILE</b></a></h4>
&nbsp;See <a href="keywords.html#WL_GINITFILE">above</a>.<br/>
<h4><a class="NoHi" id="EWWISDOMFILE2"><b>EWWISDOMFILE</b></a></h4>
&nbsp;See <a href="keywords.html#EWWISDOMFILE">below</a>.<br/>
<h4><a class="NoHi" id="ANGRPFILE2"><b>ANGRPFILE</b></a></h4>
See <a href="keywords.html#ANGRPFILE">below</a>.<br/>
<h4><a class="NoHi" id="BBSEGFILE"><b>BBSEGFILE</b></a></h4>
This keyword lets the user choose an input file containing a map annotating &phi;/&psi;-space for
polypeptides with canonical secondary structure regions. This mapping is used to perform <a href="keywords.html#SEGCALC">
segment-based</a> analyses of polypeptide secondary structure. CAMPARI provides two such files
already (in the data/ subdirectory). These and the files' format are explained in detail <a
 href="inputfiles.html#FMCSC_BBSEGFILE">elsewhere</a>.<br/>
<h4><a class="NoHi" id="GRIDDIR"><b>GRIDDIR</b></a></h4>
This keyword sets the directory CAMPARI browses to find input files
for grid-assisted sampling (see <a href="keywords.html#PIVOTMODE">above</a>).
CAMPARI provides by default sample input files in $CAMPARI_HOME/data/grids/.
The code assumes filenames to follow a systematic naming convention
"xyz_grid.dat", where xyz is the lower-case, three-letter code of
the standard 20 amino acids.<br/>
This functionality is <i>de facto</i> obsolete and should not be used.
It may be removed entirely in the future.<br/>
<h4><a class="NoHi" id="BESSELFILE"><b>BESSELFILE</b></a></h4>
This keyword sets the location and name of the file CAMPARI expects to read for the
tabulation of Fourier-Bessel (Hankel) transforms. This is required for
<a href="keywords.html#DIFFRCALC">diffraction analysis</a> and is normally
contained in the CAMPARI data directory.
Details on the input are found <a href="inputfiles.html#FMCSC_BESSELFILE">elsewhere</a>.<br/>
<h4><a class="NoHi" id="PCCODEFILE2"><b>PCCODEFILE</b></a></h4>
&nbsp;See <a href="keywords.html#PCCODEFILE">below</a>.<br/>
<h4><a class="NoHi" id="SAVATOMFILE2"><b>SAVATOMFILE</b></a></h4>
&nbsp;See <a href="keywords.html#SAVATOMFILE">below</a>.<br/>
<h4><a class="NoHi" id="ALIGNFILE2"><b>ALIGNFILE</b></a></h4>
&nbsp;See <a href="keywords.html#ALIGNFILE">below</a>.<br/>
<h4><a class="NoHi" id="TRAJIDXFILE2"><b>TRAJIDXFILE</b></a></h4>
&nbsp;See <a href="keywords.html#TRAJIDXFILE">below</a>.<br/>
<h4><a class="NoHi" id="FRAMESFILE2"><b>FRAMESFILE</b></a></h4>
&nbsp;See <a href="keywords.html#FRAMESFILE">below</a>.<br/>
<h4><a class="NoHi" id="TRACEFILE2"><b>TRACEFILE</b></a></h4>
&nbsp;See <a href="keywords.html#TRACEFILE">below</a>.<br/>
<h4><a class="NoHi" id="CFILE2"><b>CFILE</b></a></h4>
&nbsp;See <a href="keywords.html#CFILE">below</a>.<br/>
<h4><a class="NoHi" id="TRAJBREAKSFILE2"><b>TRAJBREAKSFILE</b></a></h4>
&nbsp;See <a href="keywords.html#TRAJBREAKSFILE">below</a>.<br/>
<h4><a class="NoHi" id="TRAJLINKSFILE2"><b>TRAJLINKSFILE</b></a></h4>
&nbsp;See <a href="keywords.html#TRAJLINKSFILE">below</a>.<br/>
<h4><a class="NoHi" id="CLUFILE2"><b>CLUFILE</b></a></h4>
&nbsp;See <a href="keywords.html#CLUFILE">below</a>.<br/>
<h4><a class="NoHi" id="NBLFILE2"><b>NBLFILE</b></a></h4>
&nbsp;See <a href="keywords.html#NBLFILE">below</a>.<br/>
<h4><a class="NoHi" id="CLUUNFOLDFILE2"><b>CLUUNFOLDFILE</b></a></h4>
&nbsp;See <a href="keywords.html#CLUUNFOLDFILE">below</a>.<br/>
<h4><a class="NoHi" id="CLUFOLDFILE2"><b>CLUFOLDFILE</b></a></h4>
&nbsp;See <a href="keywords.html#CLUFOLDFILE">below</a>.<br/>
<h4><a class="NoHi" id="NCDM_NCFILE2"><b>NCDM_NCFILE</b></a></h4>
&nbsp;See <a href="keywords.html#NCDM_NCFILE">below</a>.<br/>
<h4><a class="NoHi" id="NCDM_ASFILE2"><b>NCDM_ASFILE</b></a></h4>
&nbsp;See <a href="keywords.html#NCDM_ASFILE">below</a>.<br/>
<h4><a class="NoHi" id="NCDM_CFILE2"><b>NCDM_CFILE</b></a></h4>
&nbsp;See <a href="keywords.html#NCDM_CFILE">below</a>.<br/>
<h4><a class="NoHi" id="NCDM_FRAMESFILE2"><b>NCDM_FRAMESFILE</b></a></h4>
&nbsp;See <a href="keywords.html#NCDM_FRAMESFILE">below</a>.<br/>
<br/>
<br/>
<br/>
<h3><a class="NoHi" id="structure_manipulation">Structure Input and Manipulation:</a></h3>
<hr style="width: 100%; height: 2px;"></hr> (<a href="keywords.html#TOP">back to top</a>)<br/>
<h4><a class="NoHi" id="RANDOMIZE"><b>RANDOMIZE</b></a></h4>
This keyword determines the randomization aspects of initial structure generation. CAMPARI can 
generate default structures, completely random structures or, alternatively, use some or all available information from
a <a href="keywords.html#PDBFILE">structural input file</a>. The outcome is determined
both by the choices below and by the choice for keyword <a href="keywords.html#PDB_READMODE">PDB_READMODE</a>.
In general, the program employs a hierarchical procedure whereby stretches of the input
sequence are randomized residue-by-residue or molecule-by-molecule. If no excluded volume
term has been enabled (<a href="keywords.html#SC_IPP">SC_IPP</a> or <a href="keywords.html#SC_WCA">SC_WCA</a>),
the randomization will almost certainly produce structures with steric clashes (the majority of
energy terms are ignored; for example, it is not possible to implement excluded volume only by means of
<a href="keywords.html#SC_TABUL">tabulated potentials</a> and to rely on randomization to produce
a clash-free initial structure). The only other, possibly relevant terms during randomization are 
<a href="keywords.html#BOUNDARY">boundary potentials</a>,bonded potentials, and
<a href="keywords.html#SC_OSMO">compartmentalization potentials</a>.
It is a general limitation that other stiff potentials (including bias potentials such as <a href="keywords.html#SC_DREST">distance and position restraints</a>)
as well as suboptimal clash resolution can easily generate very large energies and forces for the initial structures produced by randomization.
While not generally a problem in Monte Carlo runs, the large forces will make any gradient-based simulation
immediately unstable. In these cases, the cleanest workaround is to set up a hybrid calculation
(see <a href="keywords.html#DYNAMICS">DYNAMICS</a>) that first runs a number of Monte Carlo steps
large enough to resolve all large forces (see <a href="keywords.html#CYCLE_MC_FIRST">CYCLE_MC_FIRST</a>) 
followed by a single, very long dynamics segment (keywords <a href="keywords.html#CYCLE_DYN_MIN">CYCLE_DYN_MIN</a>
and  <a href="keywords.html#CYCLE_DYN_MIN">CYCLE_DYN_MIN</a> should both be set to 
 <a href="keywords.html#NRSTEPS">NRSTEPS</a>-1). Alternatively, two separate calculations can
be run with the Monte Carlo one being restarted as a gradient-based one with the help of keywords
<a href="keywords.html#RESTART">RESTART</a> and <a href="keywords.html#RST_MC2MD">RST_MC2MD</a>.
Because of the large forces, CAMPARI will exit during a randomization encountering an unresolvable clash for a pure gradient-based
calculation (including minimization) unless <a href="keywords.html#UNSAFE">UNSAFE</a> is set to 1.
The definition of "clash" is provided primarily by keyword  <a href="keywords.html#RANDOMTHRESH">RANDOMTHRESH</a>.<br/>
Any possible randomizations proceed according to the following three-step hierarchy, but not all
steps are performed depending on the choice for RANDOMIZE.<br/>
<ol type='A'>
<li>If a <a href="keywords.html#PDBFILE">structural input file</a> was read and parts but not all coordinates of one or
more complex molecules were read, CAMPARI may generate random conformations for sidechains (<i>i.e.</i> short branches
off a main chain confined entirely to a single residue, which excludes crosslinks). This happens if one or more relevant
heavy atoms in the side chain are missing from structural input. The step is desirable because sidechains constructed
using default dihedral angles are likely to create local but significant clashes.
The interactions the sidechain in question is subjected to are evaluated with respect to all residues read at least in
part from structural input and include an <a href="keywords.html#SC_IPP">excluded volume bias</a> (if either 
<a href="keywords.html#SC_IPP">SC_IPP</a> or <a href="keywords.html#SC_WCA">SC_WCA</a> is turned on),
all enabled bonded potentials (<a href="keywords.html#SC_BONDED_B">SC_BONDED_B</a>, <i>etc.</i>), and any
possible <a href="keywords.html#BOUNDARY">boundary potentials</a>.
Sidechain resampling treats every sidechain independently in the order they appear in the sequence by a Monte Carlo
minimization procedure. Importantly, some natively frozen degrees in supported residues (such as the out-of-plane torsion &chi;<sub>5</sub>
in arginine), can be moved during this procedure. CAMPARI will print, in the summary of the calculation, some information
as to how many residues the procedure was applied to (if nonzero).<br/>
At the end of the first stage, if performed (RANDOMIZE is 1 or 2), structural input has been augmented by missing side chains, and the resultant 
conformations, aside from missing parts, should be free of major clashes that are not already present in the
<a href="keywords.html#PDBFILE">input pdb file</a>. If this stage was skipped (RANDOMIZE is 0 or 3), missing side chains
are in default conformations, and clashes are extremely likely.</li>
<li>If a <a href="keywords.html#PDBFILE">structural input file</a> was read and parts but not all coordinates of one or more complex molecules
were read, CAMPARI may generate random conformations for any missing tails. This is fully supported only in conjunction
with option 3 for <a href="keywords.html#PDB_READMODE">PDB_READMODE</a> because otherwise at most a single C-terminal tail
in the last processed molecule is treated this way. Missing chain-internal residues are a separate problem and not dealt with.
The tails are built in a systematic and hierarchical Monte Carlo minimization procedure starting from the residue closest
to the part that was read in and proceeding towards the 
respective terminus. Different tails are processed in the order that they appear in in the sequence. During randomization,
every tail interacts at most with those atoms read in from file and those having already been placed as part of tails occurring
before in the sequence. The interactions are an <a href="keywords.html#SC_IPP">excluded volume bias</a> (if either 
<a href="keywords.html#SC_IPP">SC_IPP</a> or <a href="keywords.html#SC_WCA">SC_WCA</a> is turned on),
all enabled bonded potentials (<a href="keywords.html#SC_BONDED_B">SC_BONDED_B</a>, <i>etc.</i>), and any
possible <a href="keywords.html#BOUNDARY">boundary potentials</a>.
If the tails contain residues participating in intramolecular crosslinks, these crosslinks will at best be satisfied approximately.
During the randomization procedure, they are whenever possible implemented in the same way as during the final simulation, <i>i.e.</i>, by
means of bonded potentials (which are thus required for obtaining a meaningful result). This is the case if a crosslink
exists entirely within the same tail or if it links a tail to part of the coordinates having been read in. The situation 
is more complicated if a crosslink links tails in different molecules or two different tails in the same molecule. In these
cases, results may be entirely unsatisfactory because all the burden of achieving a "closable" conformation is deferred
to the tail occurring later in the sequence whereas the tail occurring earlier ignores crosslink constraints entirely. 
At the end of the second stage, if performed (RANDOMIZE is 1 or 2), all molecules read in at least partially from
<a href="keywords.html#PDBFILE">structural input</a> 
should be in a state that is defined by the input or built randomly in a way that is approximately free of intramolecular clashes.
If RANDOMIZE is 1, and there is more than one such molecule, they should additionally be free of intermolecular clashes.
If the second stage is not performed but eligible tails exist, they are simply constructed in default polymer conformations
and disregarding any clashes or crosslinks. This is unlikely to be useful and will almost certainly cause an error unless
the simulation starts with a sufficient number of or uses only Monte Carlo steps.
</li>
<li>The third stage loops over all molecules and deals, for each molecule in this order, with internal
followed by external degrees of freedom. The internal conformation of molecules for which no <a href="keywords.html#PDBFILE">structural input</a>
was provided is constructed randomly unless RANDOMIZE is 0 or 3 or unless the molecule has no relevant
internal degrees of freedom. This random conformation is constructed as follows. For each residue, CAMPARI reserves
<a href="keywords.html#RANDOMATTS">RANDOMATTS</a> total attempts per residue and applies a threshold 
penalty of <a href="keywords.html#RANDOMTHRESH">RANDOMTHRESH</a> kcal/mol. This penalty corresponds to 
the required mean interaction energy per relevant (<i>i.e.</i>, included by <a href="keywords.html#MCNBCUTOFF">the short-range cutoff</a>)
residue pair. The relevant energy terms are a possible <a href="keywords.html#SC_IPP">excluded volume bias</a> and any
<a href="keywords.html#SC_BONDED_T">torsional potentials</a> but do not include <a href="keywords.html#BOUNDARY">boundary potentials</a>
or other bonded potentials. Energies are evaluated for residue pairs involving the current
residue and all residues further toward the N-terminus of the stretch (already processed) and the single
residue immediately following in the stretch (not yet processed). If the sum of these energies plus the difference
in any <a href="keywords.html#SC_BONDED_T">torsional potential energies</a> from the initial state is less than
the <a href="keywords.html#RANDOMTHRESH">threshold</a>, the algorithm proceeds to the next residue. 
Thus, the excluded volume contribution is evaluated as its absolute value, which means that the threshold will have to depend
on the particular choice of <a href="parameters.html#S2_LJ-types">Lennard-Jones parameters</a> (&rarr; <a href="keywords.html#PARAMETERS">PARAMETERS</a>).
If the threshold criterion is passed, the calculation proceeds to the next residue.<br/>
This randomization occurs in three hierarchical phases (1/3 each of the
<a href="keywords.html#RANDOMATTS">total attempts per residue</a>). In the first, only freely rotatable
backbone angles (excluding all pucker and &omega;-angles) are considered, <i>e.g.</i>, the &phi;/&psi;-angles of polypeptides,
or any backbone-like angles in unsupported residues. In the second stage, rotatable
sidechain angles (excluding those in native CAMPARI residues that are frozen by default) of the current residue are
added to the set as well. In the third stage, all aforementioned degrees of freedom for the
residue immediately prior in the sequence are added. It is obvious that even with all 3 stages triggered,
a stretch may be "stuck", <i>e.g.</i> fold back onto itself, thus requiring a completely new solution. Resolving such situations is not supported
as this would lead to an uncontrollable runtime. Instead, the energetically most favorable conformation
of the sampled ones is picked and a warning or error (depending on keyword <a href="keywords.html#DYNAMICS">DYNAMICS</a>)
is produced.
<br/>
For molecules free of internal crosslinks, the stretch considered is the entire molecule. If there are
internal crosslinks, the molecule is divided hierarchically into stretches. Stretches under no constraint
are processed sequentially (from N- to C-terminus). Crosslink-constrained stretches are parsed, and CAMPARI
tries to find a hierarchical order starting with the "innermost" stretches in the hope of arriving at a solution
that is both clash-free and satisfies all intramolecular crosslinks exactly. Priority is given to crosslinks
over clashes because it is very easy to arrive at structures that are more or less clash-free and have a dramatically
perturbed crosslink geometry that cannot relax properly without a complete reorganization of the molecule.
This procedure can be very slow because <a href="keywords.html#RANDOMATTS">RANDOMATTS"</a> attempts per residue are used
to construct a potentially closable stretch conformation (using an empirical bias in addition to the aforementioned
potentials) followed by an energetic evaluation of all identified loop closures. If the solutions have too many
clashes or none are found, the entire cycle is repeated up to <a href="keywords.html#RANDOMATTS">RANDOMATTS</a> times.
In the case of coupled crosslinks (for example, nested or staggered), it remains likely that the hierarchical procedure 
encounters a dead end and exits with a warning or error as before.<br/>
If successful, at the end of this step, the molecule processed should be in one of four possible states:
<ul>
<li>In a newly generated, random, and clash-free conformation
that satisfies any intramolecular crosslinks exactly (RANDOMIZE is 1 or 2 and no structural input was provided).</li>
<li>In a conformation partially or fully supplied by <a href="keywords.html#PDBFILE">structural input</a> with any tails
randomized (RANDOMIZE is 1 or 2 and structural input was provided, see above).</li>
<li>In a conformation partially or fully supplied by <a href="keywords.html#PDBFILE">structural input</a> with any tails
in default conformations (RANDOMIZE is 0 or 3 and structural input was provided, see above).</li>
<li>In its default conformation, which is generally not 
clash-free, with all (if any) intramolecular crosslinks broken (RANDOMIZE is 0 or 3 and no structural input was provided).</li>
</ul>
In the second step of the third stage, the rigid-body coordinates of the molecules are dealt with
(position of centroid and rotational orientation). This step is skipped only if <a href="keywords.html#PDBFILE">structural input</a>
was provided and RANDOMIZE is either 0 or 1. It is performed in all other circumstances.<br/>
If the molecule is not connected to another molecule occurring earlier in the sequence by an intermolecular crosslink,
the procedure is simple. There is only
 a single phase with the same number of <a href="keywords.html#RANDOMATTS">total attempts (now per molecule)</a>.
Energies are evaluated in pairwise fashion for all molecules occurring prior in
<a href="inputfiles.html#FMCSC_SEQFILE">sequence input</a> <i>vs.</i> the current molecule. 
As before, the computed energy is taken as the mean interaction energy per relevant
(<i>i.e.</i>, included by <a href="keywords.html#MCNBCUTOFF">the short-range cutoff</a>)
residue pair. The relevant energy terms are a possible <a href="keywords.html#SC_IPP">excluded volume bias</a>,
all enabled bonded potentials (although they matter only for intermolecular crosslinks), and any
<a href="keywords.html#BOUNDARY">boundary potentials</a>, all of which are taken as absolute values. The 
step ends as soon as the computed mean interaction energy is below the specified <a href="keywords.html#RANDOMTHRESH">threshold</a>.<br/>
Conversely, a molecule bound by an intermolecular crosslink to a molecule earlier in the sequence may not be placed freely.
CAMPARI analyzes intermolecular crosslinks to determine a hierarchy that prioritizes molecules with more crosslinks
(these should ideally be placed as early as possible in the sequence). While the higher-priority molecule is placed freely,
a lower priority molecules instead satisfies the crosslink exactly, and the molecule is placed with the only randomization coming from the 
central 3 dihedral angles of the actual crosslink. This may require deferring this step until the higher priority molecule has 
been placed. Depending on the conformations of the involved molecules determined
previously, this can easily lead to an unresolvable clash, which, as before, will be reported as a warning or error.
Notably, there is no mechanism in place to displace molecules that have already been placed in previous iterations of
the loop. This means that it is advantageous to place molecules joined by an intermolecular crosslink directly adjacent
in the sequence file. If a molecule is crosslinked to more than one molecule occurring earlier in the sequence, a warning
is produced and at most one of these crosslinks is respected in the generated conformation. Intermolecular crosslinks
will at best be satisfied approximately in such a case (the same is true if only the position of a lower priority molecule
in a crosslinked pair is determined by structural input).<br/>
At the end of the second step of the third stage, the molecule should be placed randomly in the simulation
container without clashing with any molecules occurring earlier in the sequence. It should also satisfy intermolecular crosslinks to at most one molecule
occurring earlier in the sequence. Note that even if <a href="keywords.html#PDB_READMODE">PDB_READMODE</a> is 3, it 
is not possible for a molecule requiring random placement to precede, in <a href="inputfiles.html#FMCSC_SEQFILE">sequence input</a>,
a molecule placed based on <a href="keywords.html#PDBFILE">structural input</a>.
The only molecules not placed randomly at the end of this stage are those read from
<a href="keywords.html#PDBFILE">structural input</a> if RANDOMIZE is 0 or 3. To continue, the second stage 
proceeds to the next molecule until there are no unprocessed molecules left.
The placement of molecules is very unlikely to be clash-free if the density is high (for example,
liquid water).</li>
</ol>
This summarizes the procedure CAMPARI uses to generate initial conformations where all
or parts are missing. As mentioned, if the resulting starting structure is not free
of clashes or other problems, a warning or error is produced. The options selectable for RANDOMIZE
are listed below. To understand the implications, it is necessary to refer to the description above:<br/>
<ol start='0'>
<li>Minimal randomization is performed. It is the same as option 1 below
if a <a href="keywords.html#PDBFILE">structural input file</a> is given that provides
coordinates for all parts of the system. It is the same as option 3 if no <a href="keywords.html#PDBFILE">structural input file</a>
whatsoever is provided. With this option, any missing tails in molecules with partial input are built in default conformations.
No intramolecular crosslinks missing from structural input are satisfied initially. All molecules missing
from structural input are built in default conformations and placed randomly in the box. Intermolecular
crosslinks are satisfied as possible (see above).</li>
<li>Supplementary randomization is performed, which is the default. This option is the same as option 0
if a <a href="keywords.html#PDBFILE">structural input file</a> is given that provides
coordinates for all parts of the system. It is the same as option 2 if no <a href="keywords.html#PDBFILE">structural input file</a>
whatsoever is provided. With this option, any missing tails in molecules with partial input are built in random, clash-free conformations
that satisfy any crosslinks at best approximately. All molecules missing entirely
from structural input are built in random conformations that satisfy intramolecular crosslinks exactly, and are placed randomly in the box.
Intermolecular crosslinks are satisfied as possible (see above).</li>
<li>This is the same as option 1 above only that the rigid-body coordinates are randomized even for those
molecules read fully or at least partially from the <a href="keywords.html#PDBFILE">structural input file</a>.
This option is the same as option 3 if a <a href="keywords.html#PDBFILE">structural input file</a> is given that provides
coordinates for all parts of the system. This option can be useful for generating random starting structures
for studies of the assembly of a protein complex from rigid components.</li>
<li>This is the same as option 0 above only that the rigid-body coordinates are randomized even for those
molecules read fully or at least partially from the <a href="keywords.html#PDBFILE">structural input file</a>.
This option is the same as option 2 if a <a href="keywords.html#PDBFILE">structural input file</a> is given that provides
coordinates for all parts of the system.</li>
</ol>
Some additional technical information is provided next. It is a very important restriction that initial structure randomization does not observe
<a href="keywords.html#FRZFILE">user-level constraints</a>. In order to have a degree of freedom, which is
accessible to randomization, start out in a well-defined state, randomization of the corresponding
class of degrees of freedom must be disabled entirely (in which case the initial state comes either
from the CAMPARI default or - more likely - from <a href="keywords.html#PDBFILE">structural input</a>). 
This is somewhat similar to the limitation regarding restraint potentials before. Stiff potentials 
such as <a href="keywords.html#SC_POLY">polymeric biases</a>, <a href="keywords.html#SC_EMICRO">density restraints</a>,
<a href="keywords.html#SC_ZSEC">secondary structure biases</a>, or <a href="keywords.html#SC_DREST">distance/position restraints</a>
are ignored by the initial structure generation. This means that a (partly) random structure can be clash-free,
can satisfy all crosslinks, yet can still be subjected to very large forces initially. Performance-wise,
the initial structure randomization procedure (like all initial setup) is unaware of the
<a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization of CAMPARI</a>. Computationally,
it may thus be more efficient to use an explicit Monte Carlo simulation to generate initial structures
in comparable fashion (although the overall cost is often negligible regardless).<br/>
In general, the importance of initial structure randomization
lies in avoiding initial structure biases that may be difficult to detect. Alternative procedures
found in the literature often use simple reference states (fully extended chains) or results from
high-temperature runs of an experimentally determined structure. With these approaches, it is quite difficult
or even impossible to rigorously assert that the final results are not subtly influenced by the choice
of starting conformation(s). Conversely, the random structures generated by CAMPARI are usually so independent from each other
that the convergence of results is a good indicator of statistical error at the level of the chosen analysis.
This is not to say that they are not biased by the simplified Hamiltonian used to construct them, which they of 
course are. Intramolecular crosslinks in particular generate constraints that can restrict the available space down to just
a few "clusters" of solutions, and CAMPARI's hierarchical procedure may well pick with a strong bias from this set.
Disregarding crosslinks, the excluded volume-centric Hamiltonian used in randomization will differ from the one used in
the actual production simulations. This in itself is a bias of course. In most cases, the production Hamiltonian
differs dramatically, in particular since it will generally contain net attractive potentials. This means 
that the beginning of a simulation corresponds to a quench/relaxation scenario, similar to what is seen experimentally
in temperature-jump experiments or computationally in methods like simulated annealing. This instantaneous quench, 
broadly speaking, leads to the sampler taking the system to configurations, which are (more) compliant with the
production Hamiltonian <i>and</i> most easily accessible from the starting configuration. Here, "most easily accessible" depends 
critically on <a href="keywords.html#DYNAMICS">the chosen sampler</a>. Thus, memory can be retained and errors can be masked
if the starting structures are not completely independent. It should be kept in mind that it is, outside of 
trivial cases, never possible to know <i>a priori</i> the subspace of configurations relevant to the system under
the chosen conditions as this is usually the question one tries to answer by means of simulations. Errors pertaining
to a lack of exhaustiveness can therefore not be diagnosed or understood based on randomized starting structures.
For this, a robustness across different samplers and <a href="keywords.html#NRSTEPS">simulation lengths</a> <br/>
Note that in <a href="keywords.html#REMC">replica exchange</a> or <a href="keywords.html#MPIAVG">MPI averaging runs</a>,
all replicas will start from different conditions <i>unless</i> <a href="keywords.html#RANDOMSEED">RANDOMSEED</a>
is given explicitly by the user.<br/>
<h4><a class="NoHi" id="RANDOMATTS"><b>RANDOMATTS</b></a></h4>
If any type of <a href="keywords.html#RANDOMIZE">initial structure randomization</a> is requested,
this keyword sets the general number of maximum attempts in randomizing the permissible degrees of freedom
for a single residue or molecule. Large numbers (&gt; 10000) may produce unacceptably slow performance
when trying to randomize a long, complex polymer and/or a dense fluid. Large numbers in conjunction with too small
a <a href="keywords.html#RANDOMTHRESH">threshold</a> can also be counterproductive. This is because
this scenario corresponds to a hierarchical minimization and thus may limit the search space for 
dependent elements of the hierarchy. This problem can be exacerbated for intramolecular constraints,
in particular coupled ones.<br/>
<h4><a class="NoHi" id="RANDOMTHRESH"><b>RANDOMTHRESH</b></a></h4>
If any type of <a href="keywords.html#RANDOMIZE">initial structure randomization</a> is requested,
this keyword sets the universal energy threshold to be applied with respect to energetic penalties
for <a href="keywords.html#SC_IPP">excluded volume</a>, <a href="keywords.html#SOFTWALL">boundary potentials</a> (rigid-body only),
and bonded terms (<i>e.g.</i>, <a href="keywords.html#SC_BONDED_T">torsional potential energies</a>).
Roughly speaking, for every residue or molecule being processed, there will be a given number of interacting
residues (depending on the <a href="keywords.html#NBCUTOFF">short-range cutoff</a>). While the total 
energy is used to pick the best current solution, the threshold is evaluated against a mean interaction
energy per residue pair, and this is the value specified by RANDOMTHRESH (in kcal/mol). Different terms
contribute for different stages of randomization <a href="keywords.html#RANDOMIZE">as described above</a>.
All these terms are pure penalty terms and cannot yield negative energies. Specifying small values for the 
threshold will generally yield lower starting energies because they make the procedure more minimization-like.
There is a caveat in that parts of the randomization procedure are hierarchical, <i>i.e.</i>, the solvability
of a subproblem may depend on the solution of previous problem. Since the algorithm has very limited capability 
to "go back," a well-minimized result for a particular task may actually prevent subsequent problems from being
solved satisfactorily. It is thus recommended to keep the threshold large enough and the <a href="keywords.html#RANDOMATTS">number of attempts</a>
small enough that solutions remain diverse.<br/>
<h4><a class="NoHi" id="PDBFILE"><b>PDBFILE</b></a></h4>
This keyword provides the (base)name and location of a structural input file
in <a href="http://www.wwpdb.org/docs.html" target="_TOP">pdb convention</a>.
This can either be a pdb trajectory (for analysis) or, more commonly, the intended
(partial) starting conformation of the system. The two interpretation modes are switched based
on keyword <a href="keywords.html#PDBANALYZE">PDBANALYZE</a> and have different requirements.
General and specific formatting information for pdb files (which also apply to keyword
<a href="keywords.html#PDB_TEMPLATE">PDB_TEMPLATE</a>) are given in the 
<a href="inputfiles.html#FMCSC_PDBFILE">corresponding input file documentation</a>. The 
parsing of pdb files depends on a number of auxiliary keywords, specifically 
<a href="keywords.html#PDB_READMODE">PDB_READMODE</a>, <a href="keywords.html#PDB_HMODE">PDB_HMODE</a>, <a href="keywords.html#PDB_INPUTSTRING">PDB_INPUTSTRING</a>,
<a href="keywords.html#PDB_TOLERANCE_A">PDB_TOLERANCE_A</a>, <a href="keywords.html#PDB_TOLERANCE_B">PDB_TOLERANCE_B</a>,
<a href="keywords.html#PDB_R_CONV">PDB_R_CONV</a>, and <a href="keywords.html#PDB_MPIMANY">PDB_MPIMANY</a>.<br/>
If trajectory analysis mode is enabled, CAMPARI will interpret the input to this keyword either
as a pdb trajectory file (using the MODEL/ENDMDL records) or as the first in a series
of systematically numbered files (&rarr; <a href="keywords.html#PDB_FORMAT">PDB_FORMAT</a>).
For the former, the MODEL / ENDMDL syntax is checked and has to be interpretable (the actual numbering on the MODEL line is ignored, however).
For the latter, a systematic numbering scheme is inferred from the provided file name (based on plain numbers, or numbers with leading
zeros). In this scenario, the first of such files should be
provided; CAMPARI will then try to extract the numbering scheme and
open <a href="keywords.html#NRSTEPS">NRSTEPS</a>-1 consecutive
snapshots. Note that in this mode the filename <b>must not</b> contain
any additional numeric characters (<i>i.e.</i>, foo_001.pdb is permissible while ala7_001.pdb
is not). To choose between single-file and multiple-file formats, keyword <a href="keywords.html#PDB_FORMAT">PDB_FORMAT</a> is used.
If the set of numbered files or the trajectory do not provide enough snapshots to 
satisfy the selected value for <a href="keywords.html#NRSTEPS">NRSTEPS</a>, CAMPARI
will either terminate with an error (if any <a href="keywords.html#MPI_settings">MPI parallel execution mode is used</a>)
or dynamically adjust the run length (if serial or <a href="keywords.html#NRTHREADS">OpenMP</a>-only code is used).
The latter can be confusing and may produce nonsensical output from built-in analysis routines
(if the run is shortened enough to effectively disable an analysis that would have been enabled given
<a href="keywords.html#NRSTEPS">NRSTEPS</a>, it is not guaranteed that all output from this analysis is
correctly suppressed).
Since the point here is to analyze a given trajectory,
CAMPARI expects the <a href="inputfiles.html#FMCSC_SEQFILE">specified sequence input</a> to match exactly what is
present in the pdb input file. This does not necessarily require that all atoms in every residue are read successfully, but it does
require that all residues are found. The use of pdb files with atoms that were not read successfully or missing
is of course quite confusing depending on the types of analyses to be performed. This is because the positions
of these atoms will be reconstructed, <i>i.e.</i>, some of the coordinates entering analysis may be 
derived, arbitrary, or, in the worst case scenario, numerically ill-defined.
While possibly tolerated by CAMPARI, it can be extremely confusing to supply a pdb
trajectory (or set of files) that do not all contain the exact same set of atoms with the exact same names.
The total number of rebuilt atoms will be reported at the end of the run to log output. Mismatches between
CAMPARI's representation of a residue and what is present in the pdb file may be circumvented with
keyword <a href="keywords.html#UAMODEL">UAMODEL</a> and can always be masked by renaming them
to be recognized as unsupported residues as demonstrated in <a href="tutorial11.html">Tutorial 10</a>.<br/>
The more common use of this keyword is for CAMPARI to attempt to read an external file to construct an initial
nonrandom conformation for the system. Depending on the setting
for <a href="keywords.html#RANDOMIZE">RANDOMIZE</a>, only some of the
information may be used.
Naturally, the system (sequence) in the pdb file has to be at least partially consistent
with the choices made via <a href="keywords.html#SEQFILE">SEQFILE</a>. Note that parallel runs can
use multiple input structures (&rarr; <a href="keywords.html#PDB_MPIMANY">PDB_MPIMANY</a>).
In particular, CAMPARI will not reorder atoms or residue blocks in the pdb except for 
very specific exceptions. In a box with a protein, solvent, and ions, it is therefore 
necessary that the order of the components in <a href="inputfiles.html#FMCSC_SEQFILE">sequence input</a>
is the same as in pdb input. If not, most of the system information will be discarded.
The input file can be processed with varying degrees of leeway and two different
paradigms (both depend on the choice for <a href="keywords.html#PDB_READMODE">PDB_READMODE</a>).<br/>
Note that it is not possible to directly start a simulation from a structure
provided in a binary trajectory file format. In this case, however,
CAMPARI can be used to extract a suitable pdb file from the trajectory
with the help of keywords <a href="keywords.html#PDBANALYZE">PDBANALYZE</a>,
<a href="keywords.html#XYZPDB">XYZPDB</a>, <a
 href="keywords.html#XYZOUT">XYZOUT</a>, <a
 href="keywords.html#XYZMODE">XYZMODE</a>,
and - for example - <a href="keywords.html#DCDFILE">DCDFILE</a>.<br/>
Lastly it is important to mention that PDBFILE provides some functionality that is
overlapping with that provided by <a href="keywords.html#PDB_TEMPLATE">PDB_TEMPLATE</a>.
Specifically, runs containing residues not natively supported by CAMPARI 
require the topology of those moieties to be inferred from file. If an 
<a href="keywords.html#PDBANALYZE">analysis run</a> operates on a single pdb file,
a trajectory file in pdb format or a series of pdb files, or if a simulation
run is supposed to start from a specific structure supplied via PDBFILE, then 
PDBFILE can (but need not) serve the function of topology inference as described
for <a href="keywords.html#PDB_TEMPLATE">PDB_TEMPLATE</a>. Conversely, 
PDBFILE never replaces the function of <a href="keywords.html#PDB_TEMPLATE">PDB_TEMPLATE</a>
in the other contexts it is relevant in, <i>viz.</i>, to provide a map from binary 
trajectory input file to CAMPARI, and to serve as a reference structure for
<a href="keywords.html#ALIGNCALC">alignment</a>.<br/>
<h4><a class="NoHi" id="XTCFILE"><b>XTCFILE</b></a></h4>
This is only relevant if <a href="keywords.html#PDBANALYZE">PDBANALYZE</a>
is true: It then specifies name and location of the trajectory
(xtc format) to analyze. Like all other
xtc-related options, this is only available if the code was in fact
compiled and linked with XDR support (→ <a href="install.html">installation
instructions</a>). See <a href="keywords.html#PDB_TEMPLATE">PDB_TEMPLATE</a>
for instructions how to convert binary trajectory files with non-CAMPARI
atom order. If the analysis run is parallel (&rarr; <a href="keywords.html#REMC">REMC</a>), 
an example is given <a href="inputfiles.html#FMCSC_PDBFILE">elsewhere</a>.
Because binary trajectory files are not annotated, many of the above formatting
options apply, at most, to the template. Specifically, 
keywords <a href="keywords.html#PDB_READMODE">PDB_READMODE</a>, <a href="keywords.html#PDB_HMODE">PDB_HMODE</a>,
<a href="keywords.html#PDB_TOLERANCE_A">PDB_TOLERANCE_A</a>, <a href="keywords.html#PDB_TOLERANCE_B">PDB_TOLERANCE_B</a>,
<a href="keywords.html#PDB_R_CONV">PDB_R_CONV</a>, and <a href="keywords.html#PDB_NUCMODE">PDB_NUCMODE</a> are all
irrelevant for the processing of the actual information in the xtc file whereas
<a href="keywords.html#XYZ_FORCEBOX2">XYZ_FORCEBOX</a> is respected. Should the data in the trajectory
file be corrupted or exhausted before <a href="keywords.html#NRSTEPS">NRSTEPS</a> snapshots have been
read successfully, CAMPARI will either terminate with an error
(if any <a href="keywords.html#MPI_settings">MPI parallel execution mode is used</a>)
or dynamically adjust the run length (if serial or <a href="keywords.html#NRTHREADS">OpenMP</a>-only code is used).
Binary xtc files have a header section for each snapshot that specifies box coordinates,
the number of atoms, and additional information. All of these except the number of atoms 
are ignored during read-in.<br/>
<h4><a class="NoHi" id="DCDFILE"><b>DCDFILE</b></a></h4>
Analogous to <a href="keywords.html#XTCFILE">XTCFILE</a>, this keyword
is only relevant if <a href="keywords.html#PDBANALYZE">PDBANALYZE</a>
is true: It then specifies name and location of the trajectory
(dcd format) to analyze.
See <a href="keywords.html#PDB_TEMPLATE">PDB_TEMPLATE</a> for
instructions how to convert binary trajectory files with non-CAMPARI
atom order. Binary dcd files have a single header section at the beginning of the file that specifies 
several control parameters including the number of atoms. All of these except the number of atoms 
are ignored during read-in (as are the box coordinates, if present).<br/>
<br/>
<h4><a class="NoHi" id="NETCDFFILE"><b>NETCDFFILE</b></a></h4>
Analogous to <a href="keywords.html#XTCFILE">XTCFILE</a>, this keyword
is only relevant if <a href="keywords.html#PDBANALYZE">PDBANALYZE</a>
is true: It then specifies name and location of the trajectory
(NetCDF format) to analyze.
Like all other NetCDF-related options, this is only available if the
code was in fact
compiled and linked with NetCDF-support (→ <a href="install.html">installation
instructions</a>). See <a href="keywords.html#PDB_TEMPLATE">PDB_TEMPLATE</a>
for instructions how to convert binary trajectory files with non-CAMPARI
atom order. Unlike xtc or dcd files, NetCDF files do not need to be parsed sequentially and
are in general fully annotated. CAMPARI thus determines immediately whether <a href="keywords.html#NRSTEPS">NRSTEPS</a> snapshots
are present in the file. If not, CAMPARI will adjust this number to the available one.
If any <a href="keywords.html#MPI_settings">MPI parallel execution mode is used</a>, this is
the minimum across all MPI processes (which read different files). Binary NetCDF files encode a well-defined standard. For
trajectory data of particle systems, CAMPARI resorts to the standard developed for the <a href="http://www.ambermd.org" target="_TOP">AMBER</a>
program suite described <a href="http://www.ambermd.org/netcdf/nctraj.pdf" target="_TOP">elsewhere</a> both 
in <a href="keywords.html#XYZPDB">writing</a> and in reading. Because NetCDF files do not need
to be processed sequentially, they offer an additional benefit of analyzing snapshots in a specific 
order that is not the same as the original trajectory (&rarr; <a href="keywords.html#FRAMESFILE">FRAMESFILE</a> for details).<br/>
<h4><a class="NoHi" id="FRAMESFILE"><b>FRAMESFILE</b></a></h4>
If <a href="keywords.html#PDBANALYZE">PDBANALYZE</a> is true, it is possible
for CAMPARI to analyze a specific set of frames from the trajectory file
(see <a href="keywords.html#PDB_FORMAT">PDB_FORMAT</a>) rather than the entire trajectory. It is also
possible to give every analyzed snapshot a sampling weight, and both functionalities
are implemented by this keyword. Example applications are the extraction of structural clusters from
a trajectory or the reweighting of biased simulations.<br/>
Most input trajectories currently need to be processed sequentially (this applies to
<a href="keywords.html#XTCFILE">xtc</a>, <a href="keywords.html#DCDFILE">dcd</a>, and
<a href="keywords.html#PDBFILE">pdb</a> trajectory files, <i>i.e.</i>, <a href="keywords.html#PDB_FORMAT">PDB_FORMAT</a> is
1, 3, or 4). For these, the list of requested frames is sorted first, and duplicates are removed.
This means that any newly written trajectory files (&rarr; <a href="keywords.html#XYZOUT">XYZOUT</a>)
will have exactly the same order of snapshots as the input. Conversely, the snapshots encoded in
individual pdb files and <a href="keywords.html#NETCDFFILE">NetCDF</a> trajectory files 
(<a href="keywords.html#PDB_FORMAT">PDB_FORMAT</a> is 2 or 5) can be accessed in arbitrary order.
For these two settings, the frames file is processed "as is" unless there are floating point
weights per snapshot or unless this is a parallel trajectory analysis run. Frames files processed "as is"
have the advantage that they can arbitrarily reorder and duplicate individual simulation snapshots, which
is relevant, for example, in the construction of synthetic trajectories.<br/> 
It is important to note that the settings for <a href="keywords.html#NRSTEPS">NRSTEPS</a>
and <a href="keywords.html#EQUIL">EQUIL</a> and all related frequency settings for 
analysis routines (see <a href="keywords.html#output_analysis">corresponding section</a>) lose their straightforward
interpretations if not all snapshots in the original trajectory are processed exactly once and in sequence.
For the case of a processed frames file (sorted and free of duplicates), the analysis frequencies will
still refer to the original, full trajectory file. This means that CAMPARI will read all frames sequentially and
increment step counters accordingly. However, all the frames that are not part of the list are simply skipped.
This implies that it is possible for a selection of 20 frames from a larger trajectory 
to fail to produce any output for polymeric quantities if <a href="keywords.html#POLCALC">POLCALC</a>
is set to 10, 5, or even 2 (simply on account of chance). It will therefore generally be easier
to set such frequency flags to 1 if processed frame lists are used (this is the only setting that guarantees
that the number of analyzed snapshots will be exactly proportional to the size of the list).  Conversely,
for a frames file used "as is," the unused frames are never read and no step counters are incremented. This means
that the effective step becomes the processing of the frames file itself. Returning to the above example,
a selection of 20 (possibly duplicated) frames from a larger trajectory will in this case 
always produce output for polymeric quantities
if <a href="keywords.html#POLCALC">POLCALC</a> is set to any value of 20 or less.<br/>
As mentioned above, the frames file allows the user to alter the type of averaging that is normally
assumed for CAMPARI analysis functions. By default, each data point (trajectory snapshot) contributes
the same weight to computed averages or histograms (distribution functions). This implied that the
input trajectory conforms (was sampled from) the distribution and ensemble of interest. If, however, the input
trajectory does not correspond a well-defined ensemble (or to a different one), it is common and possible
to apply snapshot-reweighting techniques based on analyses of system energies or coupled parameters using
weighted histogram methods. The result is a set of weights for each snapshot, which allows 
simulation averages and distribution functions to conform to that target distribution and ensemble. 
As an example, one may combine all data from a <a href="keywords.html#REMC">replica-exchange run</a> (that 
no longer conform to a canonical ensemble at a given temperature), use a technique such as T-WHAM to derive
a set of snapshot weights for a target temperature that was not part of the replica-exchange set, and
then use this input file containing the weights to compute proper simulation averages at the target 
temperature.<br/>
The input file for this functionality is very simple and explained <a href="inputfiles.html#Frameindexinput">elsewhere</a>.
There are three important points of caution. First, floating-point weights imply that floating-point precision errors
may occur. The implied summation of weights of very different sizes may then become inaccurate. CAMPARI provides
a warning if it expects such errors to be large (based purely on the weights themselves). Second, snapshot weights do not
influence the values reported for instantaneous output such as <a href="outputfiles.html#POLYMER.dat">POLYMER.dat</a>
or for analyses that do not imply averaging (such as <a href="keywords.html#CCOLLECT">structural clustering</a>). Third, 
reweighting techniques have associated errors that are difficult to predict. Simultaneous assessment of statistical
errors via block averaging or similar techniques is therefore strongly recommended.<br/>
<h4><a class="NoHi" id="PDB_FORMAT"><b>PDB_FORMAT</b></a></h4>
This simple keyword lets the user select the file format for a <a
 href="keywords.html#PDBANALYZE">trajectory analysis run</a>:<br/>
<ol>
  <li>CAMPARI expects a single trajectory file in <a
 href="keywords.html#PDBFILE">pdb</a>-format using the MODEL /ENDMDL
syntax to denote the individual snapshots.</li>
  <li>CAMPARI expects to find multiple pdb files with one snapshot each
that are systematically numbered starting from the file provided
via <a href="keywords.html#PDBFILE">PDBFILE</a>.</li>
  <li>CAMPARI expects to find a single trajectory in binary <a
 href="keywords.html#XTCFILE">xtc</a>-format (GROMACS style).</li>
  <li>CAMPARI expects to find a single trajectory in binary <a
 href="keywords.html#DCDFILE">dcd</a>-format (CHARMM/NAMD style).</li>
  <li>CAMPARI expects to find a single trajectory in binary <a
 href="keywords.html#NETCDFFILE">NetCDF</a>-format (AMBER style). (<a
 href="references.html#ref16_1">reference</a>)<br/>
  </li>
</ol>
Note that .xtc, .nc, and .dcd trajectory files are not annotated and
that the order of atoms between
the file and CAMPARI's inner workings must be consistent. Since this is
almost never true for binary
trajectory files obtained with other software, CAMPARI offers the user
to provide a pdb template which contains the order of atoms in the
binary file in annotated form (see <a href="keywords.html#PDB_TEMPLATE">PDB_TEMPLATE</a>).
<h4><a class="NoHi" id="PDB_READMODE"><b>PDB_READMODE</b></a></h4>
This keyword (integer) controls how the information in a supplied pdb file is meant to be used.
(see keyword <a href="keywords.html#PDBFILE">PDBFILE</a> and <a href="inputfiles.html#FMCSC_PDBFILE">input file documentation</a>).
A maximum of three options is available with the first one offering restricted support
depending on the type of calculation:<br/>
<ol>
  <li>CAMPARI attempts to read in the Cartesian coordinates of heavy
atoms from the pdb file, proceeds to extract the values for
CAMPARI's "native" degrees of freedom (<i>i.e.</i>, the unconstrained dihedral angles and the
rigid body degrees of freedom in Monte Carlo or torsional molecular dynamics runs →
<a href="keywords.html#CARTINT">CARTINT</a>), and lastly rebuilds the
entire structure using the determined values as well
as internal geometry parameters for the constrained internal degrees of
freedom (extracted from high resolution crystallographic databases).
This hybrid approach will often lead to a propagation of error along
the backbone of longer polymers and is therefore unsuitable
for reading larger proteins or particularly for macromolecular
complexes. While it is never a useful choice for structural input that contains 
complex molecules but does
not <i>exactly</i> encode the same covalent geometry as what CAMPARI uses
by default, it is of limited usefulness even when these conditions are met.
Specifically, it should be used in conjunction with high precision PDB input 
(see <a href="keywords.html#PDB_INPUTSTRING">PDB_INPUTSTRING</a> and
 <a href="keywords.html#PDB_OUTPUTSTRING">PDB_OUTPUTSTRING</a>) for the remaining 
cases (essentially, CAMPARI runs in <a href="keywords.html#CARTINT">rigid-body/dihedral angle space</a>
not relying on any  <a href="keywords.html#PDBFILE">structural input</a>).
This input mode does not support the processing of unsupported residues 
(see <a href="keywords.html#PDB_TEMPLATE">PDB_TEMPLATE</a>) and, upon discovery of unsupported
residues in <a href="inputfiles.html#FMCSC_SEQFILE">sequence input</a>, will be changed
automatically to option 3 (the default) below. There are further limitations to this mode.
For example, it requires strictly that the first 3 atoms (in CAMPARI convention) are present 
for each molecule (unless there are less atoms in the molecule or it is a water, ammonium, or methane molecule),
it does not recover (read) values for degrees of freedom in supported residues 
that are considered nonnative (<i>e.g.</i>, hydrogen positions in methyl groups irrespective of values for
<a href="keywords.html#TMD_UNKMODE">TMD_UNKMODE</a> and <a href="keywords.html#OTHERFREQ">OTHERFREQ</a>),
and the read in is stopped as soon as there is any mismatch in sequence and structure inputs at the residue level
(the remaining degrees of freedom missing from the pdb file are treated according 
to keyword <a href="keywords.html#RANDOMIZE">RANDOMIZE</a>).
Overall, this option should be considered largely obsolete.</li>
  <li>CAMPARI attempts to read in the Cartesian coordinates of all
atoms from the pdb file and uses those explicitly
(<i>i.e.</i>, it implicitly adopts the encoded geometry even for
degrees of freedom that are normally constrained within CAMPARI).
This will produce warnings if very unusual bond lengths or angles are
encountered (see <a href="keywords.html#PDB_TOLERANCE_A">PDB_TOLERANCE_A</a>
and <a href="keywords.html#PDB_TOLERANCE_B">PDB_TOLERANCE_B</a>), which
are most often indicative of missing atoms in the pdb-file (in
particular termini and hydrogens). Some of these problems will be dealt
with automatically, but it is always recommended 
to check the file <a href="outputfiles.html#basename_START.pdb">{basename}_START.pdb</a>
to make sure that no drastic deviations occur. Such drastic deviations are almost inevitable
if backbone atoms are missing from polymer chains, and in these cases preprocessing of the 
pdb file may be necessary. Conversely, if the input geometries are merely distorted
(experimental structures do not have arbitrary resolution or correctness), 
the automatic rebuilding CAMPARI may perform should probably be 
circumvented by increasing the thresholds
for <a href="keywords.html#PDB_TOLERANCE_B">PDB_TOLERANCE_B</a> and 
<a href="keywords.html#PDB_TOLERANCE_A">PDB_TOLERANCE_A</a>.<br/>
Note that simulations with constraints cannot preserve exact values for the constrained
degrees of freedom upon restarts of simulations from standard pdb files.
If the sampler is in <a href="keywords.html#CARTINT">Cartesian space</a> and <a href="keywords.html#SHAKESET">constraints are used</a>,
keyword <a href="keywords.html#SHAKEFROM">SHAKEFROM</a> is a potential remedy. Conversely,
simulations in rigid body or torsional space have no way of relaxing input geometries
to the built-in (or any user-desired) values for bond lengths, angles, and rigid dihedral
angles. In these cases, it may be useful (like for mode 1 above) to modify
the assumed pdb format to improve precision (see <a href="keywords.html#PDB_INPUTSTRING">PDB_INPUTSTRING</a> and
 <a href="keywords.html#PDB_OUTPUTSTRING">PDB_OUTPUTSTRING</a>) and/or to rely on 
<a href="keywords.html#RESTART">restart files</a> whenever possible. The limitations
of mode 2 are that atom names must be understood (automatic translation routines are in-place but not
exhaustive) and that the read-in stops as soon as there is any mismatch in sequence and structure inputs at the residue level
(the remaining degrees of freedom missing from the pdb file are treated according 
to keyword <a href="keywords.html#RANDOMIZE">RANDOMIZE</a>).</li>
<li>This mode is identical to mode 2 above with the exception of how mismatches between
pdb and <a href="inputfiles.html#FMCSC_SEQFILE">sequence input</a> are addressed. Here,
CAMPARI will assume that all of the structural input is potentially relevant but that some parts
of polymer chains may be missing, which is a common issue with experimental structures. It will thus
try to match maximally long sequence stretches from individual molecules (in the order of appearance in
the sequence) with the sequence in the pdb file. Read-in stops as soon as structural input is exhausted or
whenever an unresolvable mismatch occurs. An unresolvable mismatch occurs when, for a molecule
present in sequence input, no information whatsoever can be found in the pdb or when the pdb file contains
any residue that cannot be mapped to the current or next molecule. This mode enables the generation of initial 
structures with multiple C- and N-terminal tails to polymers being rebuilt. The rebuilding 
is under the control of keyword <a href="keywords.html#RANDOMIZE">RANDOMIZE</a>. Note that the proper
construction of N-terminal tails requires the first 3 main-chain atoms of the subsequent residue
to be read in correctly from the input file. This option is the default option.</li>
</ol>
More information, in particular on naming and other pdb conventions is provided in the documentation
to the <a href="inputfiles.html#FMCSC_PDBFILE">structural input file itself</a> and for keywords
<a href="keywords.html#PDB_INPUTSTRING">PDB_INPUTSTRING</a>, <a href="keywords.html#PDB_R_CONV">PDB_R_CONV</a>,
<a href="keywords.html#PDB_NUCMODE">PDB_NUCMODE</a>, and <a href="keywords.html#PDBFILE">PDBFILE</a>.<br/>
<h4><a class="NoHi" id="PDB_INPUTSTRING"><b>PDB_INPUTSTRING</b></a></h4>
This keyword allows changing the assumed PDB formatting string
(Fortran) for PDB files. This is required to make CAMPARI be able to read in altered PDB files produced by
the analogous keyword <a href="keywords.html#PDB_OUTPUTSTRING">PDB_OUTPUTSTRING</a> or by other software
or scripts. The default is "a6,a5,1x,a4,a1,a3,1x,a1,i4,a1,3x,3f8.3" (<i>with</i> the quotes).
Because Fortran in general deals poorly with string-based I/O, any improper use of this keyword can easily lead to 
abnormal program termination. In the format string, the letters (a, i, f) give
the type of variable, which must not change. The numbers give the fields lengths, and these
can be customized for variables of type integer ("i") or real ("f"). It is also possible to modify the
field widths of string variables ("a") but is not possible for extra content to be read, <i>i.e.</i>, the
resultant behavior is undefined. The only exception to this is the second variable (atom number), which is of the "wrong" type
here because these values are ignored on input. This particular field width can be increased without harm.
It is of course intended and required that the corresponding output string format uses an integer field here,
by default "i5" instead of "a5".<br/>
Common problems with standard PDB files, which can be addressed at least in part by the format string,
are that the integer number for atom index overflows, that the chain 
indicator becomes fused to neighboring columns (because of overlong residue names or large residue numbers),
that the residue number column overflows, that the coordinate entries get fused or overflow (if absolute coordinates
are not centered at small (in absolute magnitude) values), or that the coordinate precision
is insufficient for recovering exact covalent geometries based on this information alone.<br/>
<h4><a class="NoHi" id="PDB_HMODE"><b>PDB_HMODE</b></a></h4>
If structural input from a pdb file is requested in modes 2 or 3 (see <a
 href="keywords.html#PDB_READMODE">PDB_READMODE</a>
and <a href="keywords.html#PDBFILE">PDBFILE</a>) or if a <a
 href="keywords.html#PDBANALYZE">trajectory analysis run</a>)
is being performed, this keyword offers two choices for dealing with
hydrogen atoms (which will often be missing from the <a href="inputfiles.html#FMCSC_PDBFILE">pdb input file</a>):<br/>
<ol>
  <li>CAMPARI will attempt to read in the Cartesian coordinates of all
hydrogen atoms directly and only rebuild those hydrogen (and other) atoms
which cause a geometry violation defined by keywords <a
 href="keywords.html#PDB_TOLERANCE_B">PDB_TOLERANCE_B</a> and
    <a href="keywords.html#PDB_TOLERANCE_A">PDB_TOLERANCE_A</a>.</li>
  <li>CAMPARI will rebuild all hydrogen atoms according to its
underlying default models for local geometry in chemical
building blocks. This is most useful if hydrogen atoms are missing entirely
from the input file.</li>
</ol>
Note that the second option is not available for analysis runs
operating on binary trajectory files in which the atom number match
has to exactly match sequence input anyway, and which are typically
only generated by computer simulation themselves. Similarly, the keyword has no influence on unsupported residues where there is
no knowledge of missing hydrogen atoms or reference geometries (everything is defined
by the <a href="inputfiles.html#FMCSC_PDBFILE">pdb input file</a>).<br/>
<h4><a class="NoHi" id="PDB_NUCMODE2"><b>PDB_NUCMODE</b></a></h4>
For processing structural input, keyword PDB_NUCMODE explained <a
 href="keywords.html#PDB_NUCMODE">below</a> is ignored. It is listed here nonetheless to
explain what CAMPARI actually does when reading in a pdb file supplied via <a href="keywords.html#PDBFILE">PDBFILE</a>
or via <a href="keywords.html#PDB_TEMPLATE">PDB_TEMPLATE</a>:<br/>
If the input file is in CAMPARI convention, <i>i.e.</i>, the O3* oxygen atom
is part of the same residue as the phosphate it belongs to, the read in is consistent
with internal convention. If, however, the input file is in pdb convention (also used
by almost all other simulation software), <i>i.e.</i>, the O3* oxygen atom is always part of the
same residue as the sugar it belongs to, a heuristic is used to avoid an incorrect assignment.
This heuristic relies on the geometry of the input structure being sane as it checks 
the bond distance to the appropriate phosphorous atom. For the heuristic to be successful, it is essential that the
4-letter atom name for the phosphorous atoms is always " P  ". In terminal residues,
 it is possible that two oxygen atoms appear, and in this case it is important that they have different names 
(" O3*" and "2O3*" in standard CAMPARI convention).<br/>
As long as atom names can be parsed (see also <a href="keywords.html#PDB_R_CONV">below</a>), the
user should therefore not have to worry about the placement convention used in <a href="inputfiles.html#FMCSC_PDBFILE">pdb input files</a>.
This implies that it <i>is</i> possible to supply a binary trajectory file
(for example via <a href="keywords.html#DCDFILE">DCDFILE</a>) written
in the non-CAMPARI convention of assigning the O3*-atom to the residue
carrying the sugar it is attached to by the use of an appropriate <a href="keywords.html#PDB_TEMPLATE">template</a>.<br/>
<h4><a class="NoHi" id="PDB_R_CONV"><b>PDB_R_CONV</b></a></h4>
CAMPARI can in general process different conventions for the formatting
of PDB files. A large fraction of simple atom naming convention
multiplicities is handled automatically without the use of any
keywords. PDB_R_CONV allows the user to select the format a
read-in pdb-file is assumed to be in to be able to deal with more severe discrepancies.
Possible choices currently consist of:<br/>
<ol>
  <li>CAMPARI format (of course suitable for reading back in any
CAMPARI-generated output even if <a href="keywords.html#PDB_NUCMODE">PDB_NUCMODE</a> was used
→ see <a href="keywords.html#PDB_NUCMODE2">above</a>).</li>
  <li>GROMOS format (nucleotide naming). This option offers very little unique functionality since most of the
supported conversions are handled automatically regardless of the setting for this keyword. It
is primarily used to handle the GROMOS residue names for nucleotides (ADE, DADE, and so on).</li>
  <li>CHARMM format (in particular atom naming, cap and nucleotide residue names and
numbering (patches), ...). Note that there are two exceptions
pertaining to C-terminal cap residues (NME and NH2) which arise due to
non-unique naming in CHARMM: 1), NH2 atoms need to be called NT2
(instead of NT) and HT21, HT22 (instead of HT1, HT2), and 2), NME
methyl hydrogens need to be called HAT1, HAT2, HAT3 (instead of HT1,
HT2, HT3). For nucleotides, there is an additional exception to 5'-residues
carrying a 5'-terminal phosphate (the hydrogen in the terminal POH unit
needs to be called "5HO*" instead of " H5T"). This is again due
to nonunique naming conventions within CHARMM.</li>
  <li>AMBER format (atom and residue naming in particular for nucleotides). Note that this option
is the least tested one. Please let the developers know of any additional issues you may encounter.</li>
</ol>
As mentioned above, this setting is relevant for files requiring more
advanced reinterpretation (such as the patch
conventions in CHARMM / NAMD). It should allow the user to keep the manual processing
of pdb files to a minimum. However, support is generally limited to standard biomacromolecules
supported within CAMPARI, and in most cases does not extend to small molecules or unusual
polymer residues. This is the twin keyword
to <a href="keywords.html#PDB_W_CONV">PDB_W_CONV</a> below.<br/>
<h4><a class="NoHi" id="XYZ_FORCEBOX2"><b>XYZ_FORCEBOX</b></a></h4>
This keyword is a combined input/output keyword and explained 
<a href="keywords.html#XYZ_FORCEBOX">below</a>. It can be used to process
structural input with molecules that are broken up for periodic systems.<br/>
<h4><a class="NoHi" id="PDB_TOLERANCE_A"><b>PDB_TOLERANCE_A</b></a></h4>
This setting allows the user to override CAMPARI's built-in defaults
for the tolerances it applies on a read-in structure (usually xyz from
pdb).
Since it is not always easy to distinguish distorted structures from
missed input, the code applies a tolerance when comparing read-in bond
angles
to the internal reference value (which is derived from crystallographic
databases). The default is an interval to either side of 20.0&deg; and
this setting can be expanded or contracted using this keyword. If a
violation is found, the code usually overrides the faulty value with
the default since
it assumes that atomic positions were missing. This can sometimes lead
to unwanted effects which can be avoided by setting this to a large
number.<br/>
<h4><a class="NoHi" id="PDB_TOLERANCE_B"><b>PDB_TOLERANCE_B</b></a></h4>
This is analogous to <a href="keywords.html#PDB_TOLERANCE_A">PDB_TOLERANCE_A</a>,
but allows the user to change the interval for considering bond length
exceptions. The difference here is that <i>two</i> numbers are
required: a lower fractional (down to 0.0) and an upper fractional
number (preferably larger than 1.0 of course). This is because bond
lengths ranges are inherently not normalized and in addition nonlinear
(exceptions with too long bond lengths are much more frequent). The
default is an interval between 80% and 125% of the crystallographic
reference value (settings 0.8 and 1.25).<br/>
<h4><a class="NoHi" id="PDB_TEMPLATE"><b>PDB_TEMPLATE</b></a></h4>
This keyword allows the user to provide name and location of a pdb file
that serves in possibly several auxiliary functions. A template pdb file
is relevant in the following circumstances:<br/>
<ul>
<li>
In a <a href="keywords.html#PDBANALYZE">trajectory analysis run</a>, 
it can serve as a map to correct a mismatch in atom ordering
between a binary trajectory file (<a href="keywords.html#DCDFILE">dcd</a>,
<a href="keywords.html#XTCFILE">xtc</a>,
<a href="keywords.html#NETCDFFILE">NetCDF</a>) and CAMPARI's intrinsic
convention. Typically, a pdb file provided by
the program having generated the binary file will serve this purpose.
In order for the map to work, it is crucial to ensure that every single
atom to be read in has a proper match (by atom name) in the pdb file,
<i>i.e.</i>, it is not tolerable to provide a pdb template with missing
atoms or with atom names that CAMPARI cannot parse.
In general, CAMPARI's pdb parser is relatively flexible and allows
additional control via <a href="keywords.html#PDB_R_CONV">PDB_R_CONV</a>.
It is typically not possible, however, to correct mismatches in the
grouping of atoms into residues (with the exception of the processing coordinates
for nucleotides, see <a href="keywords.html#PDB_NUCMODE">PDB_NUCMODE</a>). This
is because CAMPARI treats a <i>change</i> in residue number on consecutive coordinate
records as the signal for delineating entries by residue. Conversely, the absolute 
numbers are irrelevant.</li>
<li>The template pdb file can simultaneously 
serve as a reference structure if alignment is requested in <a
 href="keywords.html#PDBANALYZE">trajectory analysis runs</a> (→ <a
 href="keywords.html#ALIGNCALC">ALIGNCALC</a>). This has the same requirements as the previous function
meaning that it is not trivially possible to align trajectories using an incomplete or different reference structure.
However, alignment to a reference structure is a functionality offered by almost every molecular visualization program.</li>
<li>In all types of runs, the template pdb file can be used to infer the topology of 
residues not natively supported by CAMPARI. This is crucial for handling these systems. 
Importantly, using the template for this purpose decouples the topology determination
from <a href="keywords.html#PDBFILE">structural input</a> for simulation runs, which allows
initial <a href="keywords.html#RANDOMIZE">randomization</a> (possibly partial) of systems containing such unsupported residues.
The content of the template should contain each unique unsupported residue in the same order
that they appear in in the <a href="inputfiles.html#FMCSC_SEQFILE">sequence file</a>. For unsupported residues that are
part of a polymer chain, each occurrence in the sequence must have its own entry also containing the 
immediate N- and C-terminal sequence context in the polymer chain. This is unless consecutive unsupported
residues are part of the same polymer chain (sequence context is mutually shared). If the unsupported residue is a small molecule
(single residue), the template should contain a single instance.
Beyond this, there are precise requirements
for both input files. They are listed in the corresponding documentation for both the
<a href="inputfiles.html#FMCSC_SEQFILE">sequence file</a> and the <a href="inputfiles.html#FMCSC_PDBFILE">pdb file</a>.
Assuming both files to be properly formatted, CAMPARI then does the following:<br/>
<ol>
<li>From the sequence file, the number of unknown residues and their intended linkages are extracted.</li>
<li>The template is read and the atomic indices delimiting all unknown residues are extracted. Single-residue
molecules that are unsupported and occur repeatedly in the sequence can (but need not necessarily) reuse the same
indices as the first instance of this type (matched by residue name in the <a href="inputfiles.html#FMCSC_PDBFILE">pdb file</a>).
The procedure will try to match <a href="inputfiles.html#FMCSC_SEQFILE">sequence input</a> with the data in the template
while allowing for gaps in both: i) supported residue present in sequence input and not required as context
for unsupported polymer residues are skipped; ii) supported residues present in the template are ignored;
iii) unsupported single-residue molecules occurring a second or more times in sequence input are skipped if (and only if)
a different unsupported residue is found next in the template. The last condition means that the second occurrence 
of an unsupported single-residue molecule may or may not be used (depending on sequence input). After this,
basic parameters such as the effective residue radius and the reference atom are inferred. It is therefore important that
the conformation of the residue in the pdb file is somewhat representative.</li>
<li>The remainder of the system topology is constructed. The internal order of atoms for unsupported residues always reflects the order in
the input pdb file exactly. The pdb template file is parsed again to ensure that the required sequence context is present.
This applies only to those unsupported residues that are part of a chain (polymer).</li>
<li>From the pdb atom names, the chemical element is guessed (C, O, N, H, P, S, halogens, various metals, and metalloids) and the mass is set 
to that of an appropriate <a href="parameters.html#S2_LJ-types">atom type</a> in the parameter file
(identification by attempts to match mass and valence). The assignment will be poor if the parameter
file does not support the chemical element in question. Further details are found 
<a href="inputfiles.html#FMCSC_PDBFILE">elsewhere</a>.
This can later be overridden by a <a href="inputfiles.html#FMCSC_BIOTYPEPATCHFILE">biotype patch</a>
and/or a combination of other patches.</li>
<li>A new biotype is created for every new atom type encountered. This biotype is initialized to be empty
with the exception of keeping the atom name and the (already) assigned atom type. The numbering of these
new biotypes continues from what the highest number in the <a href="parameters.html#S1_Biotypes">parameter file</a>
is. It is therefore not possible to use the parameter file for these assigned biotypes directly.
Instead, it is recommended to use a <a href="inputfiles.html#FMCSC_BIOTYPEPATCHFILE">biotype patch</a>
or specialized patches. The assignment of an atom type is sufficient to provide basic support, so for
certain applications no patches may be required. For residues duplicated in sequence relative to the template,
this and all subsequent information is simply copied from the first (and usually only) instance.
For valid unsupported residues with identical names, which occur multiple times in the sequence, only the
type (but not the geometry) information is copied from the reference instance.</li>
<li>The covalent bond information is used to infer the molecular topology (including a detection of rings). This 
defines the Z-matrix entries (internal coordinate representation) for unsupported residues. Similarly, the linkage
to covalently bound residues that are either supported or also unsupported is inferred. In the process,
rotatable dihedral angles are detected automatically. This procedure, which explicitly tests for bond 
angle or length variations upon rotation, is critical to most subsequent assignments.</li>
<li>Given a set of pdb names, atom types, valences, and a topology, CAMPARI attempts to conclude by analogy
whether the residue conforms to the backbone of one of the supported polymer types (currently, polypeptides
and polynucleotides). If it does, as many internal pointers as possible are set to identify the residue accordingly (this
does not work for single-residue molecules).</li>
<li>If a residue is recognized as being part of a supported polymer type, the topology itself is corrected (the goal
is that it should make no difference to CAMPARI whether a residue is supported or whether it is masked (by changing
the name) as an unsupported one and all the information has to be inferred from the input structure).
Further corrections pertain to the setup of interactions, <i>etc.</i> Note that the match cannot always be perfect, <i>e.g.</i>,
 fudge factors that are not zero or unity in conjunction with <a href="keywords.html#MODE_14">MODE_14</a> being 2 and 
 <a href="keywords.html#INTERMODEL">INTERMODEL</a> being 1 may lead to energetic inconsistencies. The interaction
setup relies on determining local rigidity via its knowledge of which dihedral angles are rotatable. Due to 
code-specific reasons (scanning for short-range exceptions, exclusions, <i>etc</i>),
it is highly recommended to parse the chain into residues such that any pair of atoms in residues
<i>i</i> and <i>i+2</i> is separated by a least four rotatable bonds.</li>
<li>All flexible dihedral angles may be made part of basic sampling routines if the simulation is in
<a href="keywords.html#CARTINT">internal coordinate space</a>. These are the torsional dynamics sampler
(&rarr; <a href="keywords.html#TMD_UNKMODE">TMD_UNKMODE</a> for details) and the basic Monte Carlo moves for
degrees of freedom of this type (&rarr; <a href="keywords.html#OTHERUNKFREQ">OTHERUNKFREQ</a>). Furthermore,
access will be granted to the specialized samplers if the residue is detected as eligible. This, however, may
sometimes lead to an altered interpretation of the absolute values of certain dihedral angles or even alter
details of the sampler slightly, <i>e.g.</i>, the <a href="keywords.html#PKRFREQ">pucker sampling</a> of
proline-like, unsupported residues may end up perturbing different sets of auxiliary bond angles.</li>
<li>If <a href="keywords.html#output_analysis">analyses</a> are requested, these routines will respond to the unsupported
residue according to the values set in the previous steps. Basically, the better the match to natively supported
entities is, the more analysis functionalities will be available. Straightforward cases depend only
on Cartesian coordinates (<i>e.g.</i>, <a href="keywords.html#RHCALC">RHCALC</a> or
<a href="keywords.html#CONTACTCALC">CONTACTCALC</a>), whereas polymer type-specific analyses
(<i>e.g.</i>, <a href="keywords.html#DSSPCALC">DSSPCALC</a>) require an unsupported residue to be recognized
as the corresponding polymer type. Care must be taken in mixed polymers or other exotic cases, and it may
occasionally be necessary to disable certain analysis routines.</li>
</ol>
The success of the inference depends very strongly on the input pdb file. Atom names and in particular atom order should
be - if possible - made as compliant with CAMPARI's internal convention as possible.
The code will report if analogy-based settings have been applied. In general, inference regarding
polymer type is restricted to the backbone level
with the small exception of detecting residues eligible for pucker sampling (see <a href="keywords.html#PKRFREQ">PKRFREQ</a>
and <a href="keywords.html#SUGARFREQ">SUGARFREQ</a>).
The inferred topology is available from <a href="outputfiles.html#basename_START.int">the starting Z-matrix coordinate file</a>.
Except in output pdb files, unsupported residues will be referenced with the three-letter code "UNK" (for example
in the header to the <a href="outputfiles.html#CONTACTMAP.dat">contact map output file</a>).
Note that simulation runs featuring unsupported residues will generally require the application of patches
to the energy function (see <a href="keywords.html#BIOTYPEPATCHFILE">BIOTYPEPATCHFILE</a>, 
<a href="keywords.html#MPATCHFILE">MPATCHFILE</a>, <a href="keywords.html#LJPATCHFILE">LJPATCHFILE</a>,
<a href="keywords.html#BPATCHFILE">BPATCHFILE</a>, <a href="keywords.html#NCPATCHFILE">NCPATCHFILE</a>,
<a href="keywords.html#CPATCHFILE">CPATCHFILE</a>, <a href="keywords.html#RPATCHFILE">RPATCHFILE</a>, 
<a href="keywords.html#ASRPATCHFILE">ASRPATCHFILE</a>, <a href="keywords.html#SAVPATCHFILE">SAVPATCHFILE</a>,
and <a href="keywords.html#FOSPATCHFILE">FOSPATCHFILE</a>).</li>
</ul>
<br/>
<h4><a class="NoHi" id="PDB_MPIMANY"><b>PDB_MPIMANY</b></a></h4>
For <a href="keywords.html#MPI_settings">MPI parallel (multi-copy) runs</a>, this logical keyword (1 means "on") allows the user to provide 
different starting structures via pdb files for different <a href="keywords.html#REPLICAS">replicas (copies)</a>. The keyword 
is irrelevant in parallel <a href="keywords.html#PDBANALYZE">trajectory analysis mode</a> where this is the required and automatic behavior.<br/>
CAMPARI used to restrict the use of this keyword to certain classes of calculations, but this is no longer the case.
There are some risks associated with PDB_MPIMANY as follows: In internal coordinate
space, the default accuracy of pdb files is too low to ensure that the covalent geometries 
across multiple input structures are sufficiently similar even when they were exactly the same in the underlying
full precision coordinates. The distortions in covalent
geometries mean that the simulated systems are no longer exactly the same, which is undesirable in cases
where this is implied because the copies are coupled, <i>e.g.</i>, in <a href="keywords.html#REMC">replica exchange</a> or
<a href="keywords.html#MPI_PIGS">PIGS</a> calculations. The magnitude of this effect can be diagnosed, for instance, by
analyzing these geometries (&rarr; <a href="keywords.html#INTCALC">INTCALC</a> directly or by comparing short-range energy terms, in particular bonded ones
(such as <a href="keywords.html#SC_BONDED_A">bond angle potentials</a>). The effect can be circumvented with the help
of keyword <a href="keywords.html#PDB_INPUTSTRING">PDB_INPUTSTRING</a>, which allows redefining the pdb format to be high-precision.
This is the most obvious solution but only available if pdb files can be generated from higher-precision coordinates to begin with.
In <a href="keywords.html#CARTINT">Cartesian space</a> simulations, geometries usually relax to their force field
minima unless  <a href="keywords.html#SHAKESET">holonomic constraints</a> are in use (in which case keyword <a href="keywords.html#SHAKEFROM">SHAKEFROM</a> can be 
used to circumvent precision issues with PDB_MPIMANY).<br/>
If this option is active, CAMPARI expects to find systematically named pdb files with the base name
given via keyword <a href="keywords.html#PDBFILE">PDBFILE</a>. The naming is analogous to the convention
CAMPARI uses for outputs of parallel runs and also identical to what parallel
trajectory analysis runs require. It is explained  <a href="inputfiles.html#FMCSC_PDBFILE">elsewhere</a>. 
A list of keywords specific to running CAMPARI in parallel is found <a href="keywords.html#MPI_settings">found below</a>.<br/>
<!--<h4><a class="NoHi" id="FYCFILE"><b>FYCFILE</b></a></h4>
This near-obsolete keyword allows the user to provide an input file to
re-build the coordinates of a
<i>single</i> macromolecule based on a list of its "native" CAMPARI
degrees of freedom. This serves
to start a simulation from a non-random, file-encoded structure.
CAMPARI provides an <a href="outputfiles.html#FYC.dat">output file</a>
suitable for this task
(→ <a href="keywords.html#TOROUT">TOROUT</a>) and the format has to
match exactly.
Note that <a href="outputfiles.html#FYC.dat">FYC.dat</a> does not
encode rigid-body coordinates
which is the reason why only single molecule structural input is
supported via this method.
Only if this keyword is present will CAMPARI attempt to read any such
torsional input. This functionality
is overridden should the user provide a valid specification for <a
 href="keywords.html#PDBFILE">PDBFILE</a> as well.
Note that this form of input is not supported for analysis runs (→ <a
 href="keywords.html#PDBANALYZE">PDBANALYZE</a>)
and that the systems of course have to be identical.<br/>-->
<br/>
<br/>
<br/>
<h3><a class="NoHi" id="energy_terms">Energy Terms:</a></h3>
<hr style="width: 100%; height: 2px;"></hr> (<a href="keywords.html#TOP">back to top</a>)<br/>

<h4><i>Preamble (this is not a keyword)</i></h4>
There are various classes of energy terms. They include the core nonbonded
energy terms (<a href="keywords.html#SC_IPP">SC_IPP</a>, <a href="keywords.html#SC_ATTLJ">SC_ATTLJ</a>,
<a href="keywords.html#SC_POLAR">SC_POLAR</a>, <a href="keywords.html#SC_IMPSOLV">SC_IMPSOLV</a>,
<a href="keywords.html#SC_TABUL">SC_TABUL</a>, <a href="keywords.html#SC_WCA">SC_WCA</a>, and
<a href="keywords.html#GHOST">ghosted variants thereof</a>),
which typically use a <a href="keywords.html#cutoff_settings">truncation scheme</a> involving
neighbor lists. When CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
these interactions are calculated in parallel using a detailed scheme operating at the neighbor lists level to achieve load balance.
The second class of energy terms are those that are not pairwise, require no cutoff scheme, and are truly "local". Some of these, such as bonded 
potentials, <i>e.g.</i>, <a href="keywords.html#SC_BONDED_B">bonded terms</a> are generally split
by residue across threads without difficulty, <i>i.e.</i>, there are sums of independent terms.
The final class of energy terms are various restraint (bias) terms requiring a synthesis 
of information across many residues, <i>e.g.</i>, <a href="keywords.html#SC_EMICRO">spatial density restraints</a>.
For these, the documentation below lists explicitly the parallelization support in each case.<br/>
<br/>
<hr/>
<h4><a class="NoHi" id="HSSCALE"><b>HSSCALE</b></a></h4>
This keyword controls a generic scaling factor for size
parameters (Lennard Jones σ<sub>ii</sub> and σ<sub>ij</sub>) that were
read in from the <a href="parameters.html#S2_LJ-types">parameter file</a>.
This fundamentally alters the excluded volume properties of the system and also
affects derived properties.
Motivation for using this keyword (which naturally defaults to 1.0) may
arise
during parameter development or in specialized calculations.<br/>
The directly affected potentials are <a href="keywords.html#SC_IPP">SC_IPP</a>, <a href="keywords.html#SC_ATTLJ">SC_ATTLJ</a>,
and <a href="keywords.html#SC_WCA">SC_WCA</a>, but the <a href="keywords.html#SC_IMPSOLV">ABSINTH solvation model</a>
will also generally respond to it (this depends on the use of "radius" overrides in
the <a href="parameters.html#S2_LJ-types">parameter file</a>. The analogous modification 
of scaling universally the &epsilon; parameters is achievable by 
means of the scale factors (<a href="keywords.html#SC_IPP">SC_IPP</a>, <a href="keywords.html#SC_ATTLJ">SC_ATTLJ</a>,
and <a href="keywords.html#SC_WCA">SC_WCA</a>).<br/>
<h4><a class="NoHi" id="SC_IPP"><b>SC_IPP</b></a></h4>
This keyword allows the user to specify the linear scaling factor
controlling the strength of the inverse power potential (IPP) defined
as:<br/>
<br/>
E<sub>IPP</sub> = c<sub>IPP</sub>·4.0ΣΣ<sub>i,j</sub>ε<sub>ij</sub>f<sub>1-4,ij</sub>·(σ<sub>ij</sub>/r<sub>ij</sub>)<sup>t</sup><br/>
<br/>
Here, the σ<sub>ij</sub> and ε<sub>ij</sub> are the size and
interaction parameters for atom pair i,j, f<sub>1-4,ij</sub> are
potential 1-4 fudge factors (see <a href="keywords.html#FUDGE_ST_14">FUDGE_ST_14</a>)
that generally will be unity, r<sub>ij</sub> is the
interatomic distance, t is the exponent, and the (double) sum runs over
all interacting pairs of atoms.
Lastly, c<sub>IPP</sub> is the linear scaling factor controlled by this
keyword which - unlike most other scaling factors for energy
terms - defaults to 1.0. In most applications, the inverse power
potential will
be the repulsive arm of the Lennard-Jones potential (t = 12 → 12<sup>th</sup>
power, see <a href="keywords.html#IPPEXP">IPPEXP</a>).
The interpretation and application of the provided parameters (see <a
 href="parameters.html#S2_LJ-types">documentation</a>
and keyword <a href="keywords.html#PARAMETERS">PARAMETERS</a>) can be
controlled
through keywords <a href="keywords.html#SIGRULE">SIGRULE</a>, <a
 href="keywords.html#EPSRULE">EPSRULE</a>,
<a href="keywords.html#INTERMODEL">INTERMODEL</a>, <a
 href="keywords.html#FUDGE_ST_14">FUDGE_ST_14</a>,
and <a href="keywords.html#MODE_14">MODE_14</a>. Note that the use of
the Weeks-Chandler-Andersen
(WCA) potential (→ <a href="keywords.html#SC_WCA">SC_WCA</a>) is
mutually exclusive with inverse power potentials.<br/>
<h4><a class="NoHi" id="IPPEXP"><b>IPPEXP</b></a></h4>
This keyword allows the user to adjust the exponent (an even integer that defaults to 12) for
the inverse power potential. An important restriction is that many of the optimized loops
in <a href="keywords.html#DYNAMICS">dynamics calculations</a>
do not support any other choice except 12.
Note that very large numbers will of course - possibly in compiler-dependent fashion - 
slow down code execution due to the increasing complexity of expensive operations in innermost loops.
By (formally) setting this to a value greater than 100, CAMPARI is instructed to replace the IPP
potential with a hard-sphere (HS) potential, which is only available in <a href="keywords.html#DYNAMICS">pure Monte Carlo</a> runs.
In this case the scaling factor is ignored, the "infinity"-value (penalty
for nuclear fusion) is determined by the setting for <a
 href="keywords.html#BARRIER">BARRIER</a>, and
the use of a size reduction factor (<a href="keywords.html#HSSCALE">HSSCALE</a>)
is strongly recommended. In hard-sphere potentials, any energy readout for
the IPP term should now
be in multiples of <a href="keywords.html#BARRIER">BARRIER</a>, and all
persisting non-zero values would indicate a
frustrated (non-relaxable) system. The actual value specified for IPPEXP is then irrelevant.<br/>
<h4><a class="NoHi" id="SIGRULE"><b>SIGRULE</b></a></h4>
This keyword defines the combination rule for combining the size
parameters of Lennard-Jones (and WCA) potentials, <i>i.e.</i>, how to
construct σ<sub>ij</sub> from σ<sub>ii</sub> and σ<sub>jj</sub> if σ<sub>ij</sub>
is not provided as a specific override in the parameter file (for
details see <a href="parameters.html#S2_LJ-types">PARAMETERS</a>).<br/>
The choices are:<br/>
&nbsp;1) σ<sub>ij</sub> = 0.5·(σ<sub>ii</sub> + σ<sub>jj</sub>)
(arithmetic mean)<br/>
&nbsp;2) σ<sub>ij</sub> = (σ<sub>ii</sub> · σ<sub>jj</sub>)<sup>0.5</sup>
(geometric mean)<br/>
&nbsp;3) σ<sub>ij</sub> = 2.0·(σ<sub>ii</sub><sup>-1</sup> + σ<sub>jj</sub><sup>-1</sup>)<sup>-1</sup>
(harmonic mean)<br/>
<h4><a class="NoHi" id="EPSRULE"><b>EPSRULE</b></a></h4>
Analogous to <a href="keywords.html#SIGRULE">SIGRULE</a>, this keyword
defines the combination rule for interaction parameters
of Lennard-Jones potentials. The same options are available and the
same caveats apply with respect to overrides in the
parameter file.<br/>
<h4><a class="NoHi" id="SC_ATTLJ"><b>SC_ATTLJ</b></a></h4>
This keyword allows the user to specify the linear scaling factor
controlling the strength of the dispersive (van der Waals) interactions
defined as:<br/>
<br/>
E<sub>ATTLJ</sub> = -c<sub>ATTLJ</sub>·4.0ΣΣ<sub>i,j</sub>ε<sub>ij</sub>f<sub>1-4,ij</sub>·(σ<sub>ij</sub>/r<sub>ij</sub>)<sup>6</sup><br/>
<br/>
Here, the σ<sub>ij</sub> and ε<sub>ij</sub> are the size and
interaction parameters for atom pair i,j, f<sub>1-4,ij</sub> are
potential 1-4 fudge factors (see <a href="keywords.html#FUDGE_ST_14">FUDGE_ST_14</a>)
that generally will be unity, r<sub>ij</sub> is the
interatomic distance, and the (double) sum runs over all interacting
pairs of atoms. Together with an inverse power potential
with scaling factor 1.0 and exponent 12 (see <a
 href="keywords.html#SC_IPP">SC_IPP</a>), the canonical Lennard-Jones
potential is constructed if
the scaling factor, c<sub>ATTLJ</sub>, is set to unity.<br/>
<h4><a class="NoHi" id="INTERMODEL"><b>INTERMODEL</b></a></h4>
This very important keyword controls the exclusion rules for
short-range interactions of the excluded volume and dispersion types
(see <a href="keywords.html#SC_IPP">SC_IPP</a>, <a
 href="keywords.html#SC_ATTLJ">SC_ATTLJ</a>, and <a
 href="keywords.html#SC_WCA">SC_WCA</a>).
For Monte Carlo or torsional dynamics simulations assuming rigid
geometries, the computation of spurious (constant) LJ
interactions is inefficient. Conversely, in Cartesian
sampling, bonded interactions are almost always parametrized with all
1-4, and certainly with all 1-5-interactions in
place. The latter refer to intramolecular atom pairs separate by either
exactly three (1-4) or four (1-5) bonds.
The ABSINTH implicit solvation model, which is one of the core features
of CAMPARI, was parametrized with a reduced
interaction model. Hence, this keyword allows two choices:<br/>
<ol>
  <li>Consider only interactions which are not rigorously
or
effectively frozen when using internal coordinate space sampling. This
setting for example excludes all interactions within aromatic rings.
As for determining 1-4-interactions, the rules outlined
under <a href="keywords.html#MODE_14">MODE_14</a>
apply.</li>
  <li>Consider all interactions separated by at least three bonds
to
be valid. This is the default setting for molecular mechanics force
fields. Note, however, that many of these interactions are quasi-rigid
and that their computation is somewhat
nonsensical even in a full Cartesian description. Also note that due
to the inherent assumption that every bond is rotatable the setting for
    <a href="keywords.html#MODE_14">MODE_14</a> does not
matter if INTERMODEL is set to
2. All atoms separated by exactly three bonds will be considered 1-4.
It is important to point out that the setting chosen for INTERMODEL affects the setting for
    <a href="keywords.html#ELECMODEL">ELECMODEL</a> as well (see <a
 href="keywords.html#ELECMODEL">ELECMODEL</a>).</li>
  <li>The <a href="references.html#ref1_6">GROMOS force field</a> uses a very specific set of non-bonded
exclusions which is
supported by choosing this option for INTERMODEL. It is essentially a
weakened
version of the first (sane) option. Note that to reproduce the GROMOS
force field exactly, <a href="keywords.html#ELECMODEL">ELECMODEL</a> (which remains an independent setting) has to
be set to 2 and INTERMODEL to 3.</li>
</ol>
<h4><a class="NoHi" id="LJPATCHFILE"><b>LJPATCHFILE</b></a></h4>
This keyword can be used to provide the location and name of an <a href="inputfiles.html#FMCSC_LJPATCHFILE">
input file</a> that allows reassigning the size exclusion and dispersion parameters
used in describing generic short-range potentials of the Lennard-Jones
(see <a href="keywords.html#SC_ATTLJ">SC_ATTLJ</a> and <a href="keywords.html#SC_IPP">SC_IPP</a>)
or <a href="keywords.html#SC_WCA">WCA</a> types. The parameter file that
CAMPARI parses will contain <i><a href="parameters.html#S2_LJ-types">atom</a></i> entries that specify general atom types.
These types have associated with them entries of the <i>contact</i> and <i>epsilon</i>
types specifying the Lennard-Jones &sigma;<sub>ij</sub> and &epsilon;<sub>ij</sub> parameters (see equations
provided with scale factor keywords). Within the list of <i><a href="parameters.html#S1_Biotypes">biotypes</a></i>, 
each biotype is assigned an atom type, and the patch functionality described here allows
the user to change this to a different atom type for a specific instance of a biotype.
Note that the reassignment is restricted to the Lennard-Jones parameters, but excludes
other atomic parameters specified by atom types such as mass, proton number, description,
or valence. Conversely, parameters derived from Lennard-Jones parameters <b>are
altered</b>. This is particularly important for the derived atomic radii and volumes
used in the <a href="keywords.html#SC_IMPSOLV">continuum solvation model</a> and <a href="keywords.html#SAVCALC">analysis</a>.
If those parameters are meant to be left unchanged or set to yet another set of values,
either the <i><a href="parameters.html#S2_LJ-types">radius</a></i>
facility of the parameter file must be employed (if it is not already in use for the original atom type in
question), or a <a href="keywords.html#RPATCHFILE">patch of atomic radii</a> must be applied in addition.
Because size exclusion and dispersion parameters rely on combination rules and/or 
many overrides for special cases, it can be tedious to patch them. This is because a patch
will often require the user to define a new atom type, which, for example, for the GROMOS force fields
can be a lot of work. Some more details are given <a href="inputfiles.html#FMCSC_LJPATCHFILE">elsewhere</a>.<br/>
<h4><a class="NoHi" id="SC_EXTRA"><b>SC_EXTRA</b></a></h4>
This (somewhat obsolete) keyword specifies a linear scaling factor for
certain structural correction
potentials. Assuming the typical set of torsional space constraints
(see <a href="keywords.html#CARTINT">CARTINT</a>),
these are applied to rotatable bonds with electronic effects which
cannot be captured by atomic pairwise contributions.
These consist of:<br/>
<ol>
  <li>Secondary amides: The rotation around the C-N bond is hindered
due to the partial double-bond character present in amides. Corrections
are therefore applied to residues which have an ω-angle (all
non-N-terminal peptide residues
excluding NH2 as well as the secondary amides NMF and
NMA &rarr; <a href="inputfiles.html#FMCSC_SEQFILE">sequence input</a>). These keep the peptide bond roughly planar while allowing for
<i>cis</i>/<i>trans</i>-isomerization and increased overall flexibility. The
potentials are
directly ported from OPLS-AA.</li>
  <li>Phenolic polar hydrogens: The rotation around the C-O bond in
phenols is
hindered due to its partial double bond character and in-plane
arrangements
of the attached hydrogen are favored. Corrections are applied to
tyrosine (TYR)
and <i>p</i>-cresol (PCR). These keep the polar hydrogen in their favored position.
The potential is not overly stiff so that out-of-plane arrangements
will be populated as well. The parameters are again ported directly
from OPLS-AA.</li>
</ol>
Like all other linear energy scaling factors with the exception of <a href="keywords.html#SC_IPP">SC_IPP</a>,
the parameter controlled by this keyword defaults to zero. Its use is recommended
for rigorous backward compatibility in certain cases only. We
recommend employing the torsional potentials specified via the
parameter file itself (see <a href="parameters.html#S7_Dihedral_angle_torsional_potential">PARAMETERS</a>) instead. In that
case, concurrent use of canonical torsional potentials (<a
 href="keywords.html#SC_BONDED_T">SC_BONDED_T</a>)
and this term will produce a warning since this is nonsensical. For all cases, the use
of the correct OPLS-based hybrid parameter files with (<a
 href="keywords.html#SC_BONDED_T">SC_BONDED_T</a>) should provide an exact
match to the potentials available by this keyword. <br/>
<h4><a class="NoHi" id="SC_BONDED_B"><b>SC_BONDED_B</b></a></h4>
This keyword gives the linear scaling factor for all bond length
potentials. Their usage is
permissible in all simulations but not meaningful unless bond lengths
are actually allowed to vary, <i>i.e.</i>, typically unless sampling
happens fully in Cartesian degrees of freedom (see <a
 href="keywords.html#CARTINT">CARTINT</a>). It is important to remember, however,
that even in rigid-body / torsional space simulations, specific move types and systems
will require setting this to unity (so we recommend it throughout). For bond length
potentials, the only such exceptions are crosslinked molecules (see
<a href="keywords.html#CRLK_MODE">CRLK_MODE</a>). Note that the parameter
file has to provide support to be able to
use this energy term (see <a href="parameters.html#S5_Bond_length_potential_types">PARAMETERS</a>
for details), and that simulations relying on those terms will otherwise fail, crash, or produce
nonsensical results. Use <a href="keywords.html#GUESS_BONDED">GUESS_BONDED</a> to
circumvent those issues for incomplete parameter files.<br/>
<h4><a class="NoHi" id="SC_BONDED_A"><b>SC_BONDED_A</b></a></h4>
Similar to <a href="keywords.html#SC_BONDED_B">SC_BONDED_B</a>
for all bond angle potentials. Bond angle potentials (see
<a href="parameters.html#S6_Bond_angle_potential_types">PARAMETERS</a>
for details) matter for sampling in Cartesian space (see <a
 href="keywords.html#CARTINT">CARTINT</a>), for crosslinked molecules (see
<a href="keywords.html#CRLK_MODE">CRLK_MODE</a>),
and for the sampling of five-membered, flexible rings
(see <a href="keywords.html#PKRFREQ">PKRFREQ</a> and <a href="keywords.html#SUGARFREQ">SUGARFREQ</a>).
The coordinate derivatives for bond angles diverge at the extreme values of both
0&deg; and 180&deg;. This means that care must be taken in setting up the Z-matrix
such that no terms are included, which would explicitly demand these values. In other
software, this is sometimes overcome by the use of dummy atoms. In CAMPARI, this is 
unlikely to be problematic in Monte Carlo simulations. In <a href="keywords.html#DYNAMICS">dynamics</a>,
forces are buffered to avoid program crashes due to floating point errors, but 
the actual values are no longer meaningful. This issue is primarily relevant when modifying the
code or when simulating unsupported residues, for which the Z-matrix is inferred from input
(see <a href="keywords.html#PDB_TEMPLATE">elsewhere for details</a>).<br/>
<h4><a class="NoHi" id="SC_BONDED_I"><b>SC_BONDED_I</b></a></h4>
Similar to <a href="keywords.html#SC_BONDED_A">SC_BONDED_A</a>
for all improper dihedral angle potentials.<br/>
<h4><a class="NoHi" id="SC_BONDED_T"><b>SC_BONDED_T</b></a></h4>
Similar to <a href="keywords.html#SC_BONDED_B">SC_BONDED_B</a>
for all torsional potentials. Note that these do in fact encompass
degrees of freedom sampled in all types of simulations supported within
CAMPARI and hence are
always relevant. As alluded to above, torsional potentials can be
easily set up to cover the
same correction terms as the ones applied within <a
 href="keywords.html#SC_EXTRA">SC_EXTRA</a>. If that is the case, we
therefore recommend not using <a href="keywords.html#SC_EXTRA">SC_EXTRA</a>
(otherwise energy terms will in fact be applied twice, which is effectively
scaling up those torsions; in such a case, CAMPARI produces an appropriate warning as well).<br/>
<h4><a class="NoHi" id="SC_BONDED_M"><b>SC_BONDED_M</b></a></h4>
Similar to <a href="keywords.html#SC_BONDED_B">SC_BONDED_B</a>
for all CMAP potentials. These grid-based correction potentials are
part of the CHARMM
force field and explained in <a href="parameters.html#S8_CMAP_potential_types">PARAMETERS</a>.
This keyword
specifies the "outside" scaling factor. Note that CMAP corrections can
theoretically be relevant for all possible simulations of biopolymers within CAMPARI since
they act on consecutive dihedral angles. The default CMAP corrections
from CHARMM only apply to polypeptides, however, and are only
contained within the <a href="keywords.html#charmm_prm">reference CHARMM parameter file</a>.<br/>
<h4><a class="NoHi" id="IMPROPER_CONV"><b>IMPROPER_CONV</b></a></h4>
If improper dihedral potentials are in use
(&rarr; <a href="keywords.html#SC_BONDED_I">SC_BONDED_I</a>), this
very specialized keyword can be used to force a reinterpretation of 
the input sequence for the assignment of improper dihedral angle
potentials to bonded types (see <a href="parameters.html#S9_Bonded_types">elsewhere</a>).
When set to 2, this keyword forces CAMPARI to switch the meaning
of the first and third specified bonded type when it comes to energy
and force evaluations. This allows a more or less exact match to the
convention used in the <a href="keywords.html#AMBER">AMBER</a> set of force fields (and by extension: in <a href="keywords.html#OPLSAAL">OPLS-AA</a>).
For any other value specified, CAMPARI will use the CAMPARI-native convention
(that is the same as in the <a href="keywords.html#CHARMM">CHARMM</a> and <a href="keywords.html#GROMOS">GROMOS</a> force fields).<br/>
<h4><a class="NoHi" id="CMAPORDER"><b>CMAPORDER</b></a></h4>
If CMAP corrections are used (→ <a href="keywords.html#SC_BONDED_M">SC_BONDED_M</a>),
this keyword
sets the interpolation order for cardinal splines (assuming those are
chosen through parameter
input → <a href="parameters.html#S8_CMAP_potential_types">PARAMETERS</a>). A higher
spline order
will yield a smoother surface. Since the splines are non-interpolating,
however, rapidly varying or coarsely
tabulated functions may not be well approximated in such cases. The
only interpolating cardinal B spline
is the linear one which requires a choice of 2 for this keyword. This
keyword is irrelevant
should bicubic splines be chosen.<br/>
<h4><a class="NoHi" id="CMAPDIR"><b>CMAPDIR</b></a></h4>
If CMAP corrections are used (→ <a href="keywords.html#SC_BONDED_M">SC_BONDED_M</a>),
this keyword
lets the user specify the absolute path of the directory in which the
CMAP files are to be found
(by default they are in the data/-subdirectory of the main distribution
tree).<br/>
<h4><a class="NoHi" id="BPATCHFILE"><b>BPATCHFILE</b></a></h4>
This keyword can be used to provide the location and name of an <a href="inputfiles.html#FMCSC_BPATCHFILE">
input file</a> that allows reassigning or adding bonded potential terms (see
<a href="keywords.html#SC_BONDED_B">bond length potentials</a>, <a href="keywords.html#SC_BONDED_A">bond angle potentials</a>,
<a href="keywords.html#SC_BONDED_I">improper dihedral angle potentials</a>, <a href="keywords.html#SC_BONDED_T">torsional potentials</a>, and <a href="keywords.html#SC_BONDED_M">CMAP potentials</a>).
At the level of the parameter file that CAMPARI parses to generate default
assignments based on biotypes (see <a href="parameters.html#S9_Bonded_types">elsewhere</a>), there 
are limitations to how finely the system can be parsed. For instance, it is technically not possible to have different
bond length potentials acting on the N&rarr;C<sub>&alpha;</sub> bonds of two non-terminal glycine
residues (because biotypes are identical). Of course, even providing bonded parameter
assignments exactly at biotype resolution would generally be inordinately complicated,
which is the reason for grouping biotypes into so-called bonded types in the parameter
file. In cases where specific alterations to a given a system are desired, the
patch functionality provided by this input file will generally be the most 
convenient (and often the only) route to take.
For stiff terms, CAMPARI can also  <a href="keywords.html#GUESS_BONDED">guess values</a>
based on initial geometries. Applied patches to bonded interactions are always
printed to log-output In order to diagnose their correctness more easily,
it is recommended to use the <a href="keywords.html#BONDREPORT">report functionality</a> for bonded potential
terms. Note that the most critical limitation is that extra or alternative
bonded potentials can only be applied to such internal coordinates that are
eligible for default assignments themselves, <i>e.g.</i>, it is <b>not</b>
possible to apply a bond angle potential to atoms a-b-c if 
a is not covalently bound to b or if b is not covalently bound to c.<br/>
<h4><a class="NoHi" id="GUESS_BONDED"><b>GUESS_BONDED</b></a></h4>
This keyword lets the user CAMPARI instruct to construct a set of bonded
parameters from the most basic information available, which are the default molecular geometries (
usually from high-resolution crystal structures) for residues natively supported by CAMPARI
or structural input for unsupported residues (see documentation on <a href="inputfiles.html#FMCSC_SEQFILE">sequence input</a>
for details). Options are as follows:<br/>
<ol start="0">
<li>No potentials are guessed. This means that the only bonded potentials available are those defined
in the <a href="keywords.html#PARAMETERS">parameter file</a> and mapped by matching the entries
on <a href="parameters.html#S9_Bonded_types">bonded types</a> to the available potentials, <i>e.g.</i>
<a href="parameters.html#S5_Bond_length_potential_types">bond length potentials</a>, as well
as those potentials defined in a <a href="keywords.html#BPATCHFILE">corresponding patch file</a>,
which also rely on the parameter file. Missing bonded interactions can make it impossible
or meaningless to run simulations in <a href="keywords.html#CARTINT">Cartesian space</a>.</li>
<li>CAMPARI will guess missing harmonic potentials (type 1) for all bond lengths and angles defined
by molecular topology. The equilibrium positions are defined as mentioned above. The force constants
are flat, which is obviously a crude approximation, and evaluate to 300kcal&#183;mol<sup>-1</sup>&#8491;<sup>-2</sup>
for bond lengths and 80kcal&#183;mol<sup>-1</sup>rad<sup>-2</sup> for bond angles, respectively. It is not
possible to add potentials to doublets or triplets of atoms that are not topologically
derived. This is important for unsupported residues where a suboptimal Z matrix may be 
constructed because of bad atom input order.</li>
<li>This options implies the previous option. In addition, eligible improper dihedral
angles (see documentation on <a href="parameters.html#S9_Bonded_types">bonded types</a>)
are given a harmonic potential (type 2), and the strength is set to 40kcal&#183;mol<sup>-1</sup>rad<sup>-2</sup>.
Note that the functional form here includes a factor of 1/2 not present for bond angles.</li>
</ol>
It is important that the information from the parameter file takes precedence over the guessed potentials.
This means that the use of this keyword can add potentials to improper dihedral angle terms
that were left empty by design in the force field in question, which can be undesirable. 
An easy solution avoiding this scenario (that is also used in many parameter files) is to define a null potential
and map it to the terms in question. Conversely, patches are able to override both.<br/>
While these potentials are obviously too crude to study problems requiring very high resolution
at the local geometry level, they can be very useful too quickly enable Cartesian space simulations of unsupported
systems where often calibration data are missing (or unreliable) to begin with. The guessed
potentials are written to log output, and parsing this with a script can help in creating templates
for exhaustive <a href="keywords.html#BPATCHFILE">patch files</a>, which are tedious to create
from scratch. Note that the source data do not come from structural input for supported residues,
which means that initial structures deviating dramatically from the assumed local geometries
can be subject to large forces.<br/>
<h4><a class="NoHi" id="BONDREPORT"><b>BONDREPORT</b></a></h4>
This report flag allows the user to request a summary of the bonded
potentials found and not found during processing of the parameter file.
This is primarily useful as a sanity and debugging tool for
creating parameter files. Note that missing but necessary parameters
(necessary ones are all bond length and angle potentials if and only if
<a href="keywords.html#CARTINT">CARTINT</a> is 2) as well as guessed
parameters (see <a href="keywords.html#GUESS_BONDED">GUESS_BONDED</a>)
are always
reported upon.<br/>
<h4><a class="NoHi" id="SC_WCA"><b>SC_WCA</b></a></h4>
Mutually exclusive to the use of the Lennard-Jones potential, CAMPARI
allows
using the extended Weeks-Chandler-Andersen (WCA) potential which is
defined as :<br/>
<br/>
E<sub>WCA</sub> = 4.0·c<sub>WCA</sub>ΣΣ<sub>i,j</sub>ε<sub>ij</sub>f<sub>1-4,ij</sub>·[(σ<sub>ij</sub>/r<sub>ij</sub>)<sup>12</sup>
- (σ<sub>ij</sub>/r<sub>ij</sub>)<sup>6</sup> + 0.25·(1.0 - c<sub>2</sub>)]&nbsp;&nbsp;&nbsp;&nbsp;if
r<sub>ij</sub> &lt; σ<sub>ij</sub>·2<sup>1/6</sup><br/>
E<sub>WCA</sub> = c<sub>2</sub>·c<sub>WCA</sub>ΣΣ<sub>i,j</sub>ε<sub>ij</sub>f<sub>1-4,ij</sub>·[0.5·cos(c<sub>3</sub>·(r<sub>ij</sub>/σ<sub>ij</sub>)<sup>2</sup>
+ c<sub>4</sub>) - 0.5]&nbsp;&nbsp;&nbsp;&nbsp;if r<sub>ij</sub> &lt; σ<sub>ij</sub>·c<sub>1</sub><br/>
E<sub>WCA</sub> = 0.0&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
<br/>
with:<br/>
<br/>
c<sub>3</sub> = π·(c<sub>1</sub><sup>2</sup> - 2<sup>1/3</sup>)<sup>-1</sup><br/>
c<sub>4</sub> = π - c<sub>3</sub>·2<sup>1/3</sup><br/>
<br/>
(<a href="references.html#ref18_1">reference</a>)<br/>
<br/>
Here, the size, interaction, and fudge parameters are used as defined
before. c<sub>1</sub> is the interaction cutoff (in units of σ<sub>ij</sub>)
while
c<sub>2</sub> is the depth of the attractive well to be spliced in (in
units of ε<sub>ij</sub>). c<sub>1</sub> and c<sub>2</sub> can be set by keywords
<a href="keywords.html#ATT_WCA">ATT_WCA</a> and <a href="keywords.html#CUT_WCA">CUT_WCA</a>, respectively. The potential provides a
continuous function mimicking a LJ potential in which the dispersive
term can be spliced in without shifting the position of the minimum. c<sub>WCA</sub>
denotes the linear scaling factor specified by this keyword.<br/>
<h4><a class="NoHi" id="ATT_WCA"><b>ATT_WCA</b></a></h4>
This allows the user to specify the well depth (positive number) for
the attractive part of the WCA potential
in units of ε<sub>ij</sub> (parameter c<sub>2</sub> under <a
 href="keywords.html#SC_WCA">SC_WCA</a>).<br/>
<h4><a class="NoHi" id="CUT_WCA"><b>CUT_WCA</b></a></h4>
This allows the user to specify the cutoff value for the extended WCA
potential in units of σ<sub>ij</sub> (parameter
c<sub>1</sub> under <a href="keywords.html#SC_WCA">SC_WCA</a>). Note
that the minimum allowed choice here is 1.5.<br/>
<h4><a class="NoHi" id="VDWREPORT"><b>VDWREPORT</b></a></h4>
This keyword is a simple logical deciding whether or not to print out a
summary of the Lennard-Jones (size exclusion and dispersion)
parameters, <i>i.e.</i>, to report the base values (σ<sub>ii</sub> and
ε<sub>ii</sub>), the combination rules, and
in particular all "special" values which overwrite the default
combination rule-derived result.<br/>
<h4><a class="NoHi" id="INTERREPORT"><b>INTERREPORT</b></a></h4>
Mostly for debugging purposes, this simple logical allows the user to
demand a summary of
short-range interactions. Naturally, this output can be very large and
the keyword should
only be used when absolutely needed, for example to understand the
settings for <a href="keywords.htmlMODE_14">MODE_14</a> and <a
 href="keywords.html#FUDGE_ST_14">FUDGE_ST_14</a>.<br/>
<h4><a class="NoHi" id="SC_POLAR"><b>SC_POLAR</b></a></h4>
CAMPARI only supports fixed-charge atom-based electrostatic
interactions which work by defining partial
charges for each atom and then writing the potential as:<br/>
<br/>
E<sub>POLAR</sub> = c<sub>POLAR</sub>·ΣΣ<sub>i,j</sub> [ (f<sub>1-4,C,ij</sub>·q<sub>i</sub>q<sub>j</sub>)
/ (4.0πε<sub>0</sub>·r<sub>ij</sub>)]<br/>
<br/>
Here, the q<sub>i</sub> are the atomic partial charges, f<sub>1-4,C,ij</sub>
are potential 1-4 fudge factors
(see <a href="keywords.html#FUDGE_EL_14">FUDGE_EL_14</a>) that
generally will be unity, ε<sub>0</sub> is the vacuum permittivity, r<sub>ij</sub>
is the interatomic distance, and the (double) sum runs over all
eligible atom pairs (see <a href="keywords.html#ELECMODEL">ELECMODEL</a>).
c<sub>POLAR</sub>
is the linear scaling factor for all polar interactions specified by
this keyword.
Since electrostatic interactions are characterized by the potential to
yield long-range effects (distance scaling ranges from r<sup>-1</sup> for monopole-monopole terms
to r<sup>-6</sup> for dipole-dipole terms between molecules tumbling freely), the
Coulombic term can employ a different cutoff in
MC calculations (see <a href="keywords.html#cutoff_settings">below</a>)
than
short-range potential. The correct long-range treatment of
electrostatic interactions is
one of the most investigated areas in molecular simulations and the
user is referred to current literature and keywords <a
 href="keywords.html#LREL_MC">LREL_MC</a> and <a
 href="keywords.html#LREL_MD">LREL_MD</a> for details. All required partial charges
are read either through the <a href="parameters.html#S3_Charge_types">parameter file</a>
or can be set by a <a href="keywords.html#CPATCHFILE">dedicated patch</a>.<br/>
Note that the functional form given above is only correct if no
implicit solvation model
is in use. In such a scenario, Coulomb interactions are usually
modified by an extra term
s<sub>ij</sub> which can be complicated function of interatomic
distance and/or the positions of all
nearby atoms. The reader is referred to <a href="references.html#ref19_1">Vitalis and Pappu</a> for the exact
functional forms used in the ABSINTH implicit solvation model.<br/>
<h4><a class="NoHi" id="ELECMODEL"><b>ELECMODEL</b></a></h4>
This important keyword is somewhat analogous to <a
 href="keywords.html#INTERMODEL">INTERMODEL</a> and allows the user to
set
the interaction model for electrostatic interactions:<br/>
<ol>
  <li>Depending on the setting for <a href="keywords.html#INTERMODEL">INTERMODEL</a>,
interactions are either screened for connectivity and frozen interactions are excluded
(<a href="keywords.html#INTERMODEL">INTERMODEL</a> is 1), or are purely considered based
on the number of bonds separating two atoms (<a href="keywords.html#INTERMODEL">INTERMODEL</a> is 2). In any
case, partial charges interact without
considerations of net neutrality (see below), which is problematic for short-range
interactions. Consider for example the ω-bond in
polypeptides and assume that CO and NH both form neutral groups
supposed to indicate dipole moments. If <a href="keywords.html#INTERMODEL">INTERMODEL</a> is 2 and ELECMODEL is 1, the interaction
between O and H is considered (1-4) but none of the others as they are
topologically too close. This leads to spurious (and very strong)
Coulomb interactions between what essentially are
fractional, net charges. This is an inherent weakness of the point
charge model which is typically addressed by extensive
co-parameterization of bonded parameters, 1-4-fudge factors, <i>etc.</i> (see <a
 href="keywords.html#FUDGE_EL_14">FUDGE_EL_14</a>).</li>
  <li>The partial charge set in the parameter file is
read and the assigned charges are screened for (generally) net neutral 
charge groups. These charge groups are determined largely automatically and are 
currently not patchable <i>per se</i>. The automatic charge group generation operates by trying
to group partial charges into groups of minimum size and spanning a minimum
number of covalent bonds satisfying a target net charge. The default target net charges
are derived from knowledge of every CAMPARI-supported residue and assumptions about
their titration states (if any). This means, for example, that a nonterminal lysine residue
will be processed by first looking for a charge group with a net charge of +1 before
trying to identify as many net neutral groups as possible.
While CAMPARI does not allow grouping charges arbitrarily, there is a
<a href="keywords.html#NCPATCHFILE">dedicated patch</a> which allows defining
a series of (arbitrary) target values for the net charges of charge groups in a given residue. This is
required to deal with charge sets that do not group at all, or to deal with
residues that contain multiple ionic moieties. For example, depending on the charge set
in use, one may want to partition free, zwitterionic alanine either as multiple
groups with +1, -1, and 0 charges, or simply as one or more net neutral groups.
For multiple targets, failure of the grouping algorithm at a given stage will lead to this
stage being skipped. Conversely, failure at the last stage will result in all 
remaining atoms in the residue being members of a single group. Groups that are not
well-defined charge groups according to CAMPARI's standards will be reported on in log output.
With the groups in place, only interactions between those groups, for which all possible atom-atom
pairs are separated by at least one significant degree of
freedom, are computed. Interactions within a group are always excluded. 
What constitutes a significant degree of freedom
is predetermined by the choice for <a href="keywords.html#INTERMODEL">INTERMODEL</a>,
and the reader is encouraged to read up on this if necessary. Essentially, 
<a href="keywords.html#INTERMODEL">INTERMODEL</a> will define the maximum set of
short-range interaction pairs that can also be considered for polar interactions.
As an example, for the 6 net neutral CH units in benzene,
if <a href="keywords.html#INTERMODEL">INTERMODEL</a> is 1, no
intramolecular polar interactions can be considered (the maximum set is empty).
Conversely, if <a href="keywords.html#INTERMODEL">INTERMODEL</a>
is 2, several group-group interactions are now permissible
(C1H-C4H, C2H-C5H, C3H- C6H). Depending on the charge set and on the
choice for <a href="keywords.html#INTERMODEL">INTERMODEL</a>, setting
ELECMODEL to 2 can lead to a massive depletion of short-range electrostatics.
This paradigm clashes heavily with traditional force field development,
but - in the authors' opinion - is the only sane
treatment of dipole-dipole interactions if the latter are
represented by point charges.</li>
</ol>
The partitioning into charge groups for option 2 is currently relevant for 2 additional areas
(independent of the setting for ELECMODEL):<br/>
<ul>
<li>The charge groups are important for deciding how long-range electrostatic
interactions between ionic groups are computed exactly (see options 1, 2, and 3
for <a href="keywords.html#LREL_MC">LREL_MC</a> and options 4 and 5 for
<a href="keywords.html#LREL_MD">LREL_MD</a>).</li>
<li>The charge groups are used as the basis for computing group-averaged screening
factors for certain screening models in the ABSINTH framework (see options
1, 3, 5, and 7 for <a href="keywords.html#SCRMODEL">SCRMODEL</a>).</li>
</ul>
It should be noted that the typical combinations here will be setting
ELECMODEL to 1 and <a href="keywords.html#INTERMODEL">INTERMODEL</a> to 2(3) (the standard
molecular mechanics force field paradigm) versus
setting ELECMODEL to 2 and <a href="keywords.html#INTERMODEL">INTERMODEL</a>
to 1 (the ABSINTH paradigm). In particular,
the combination of both being set to 1 will not be particularly
meaningful. This is because the interactions isolated
via <a href="keywords.html#INTERMODEL">INTERMODEL</a> must always
remain a superset of those isolated here.<br/>
<h4><a class="NoHi" id="AMIDEPOL"><b>AMIDEPOL</b></a></h4>
One "flaw" in the biotype setup in CAMPARI (see <a
 href="parameters.html#S1_Biotypes">PARAMETERS</a>) is the fact
that the two polar hydrogens on primary amides are treated as
chemically equivalent which - on a typical
simulation timescale - they are not. Instead of creating yet more
biotypes, this keyword simply
allows to add a small polarization term for partial charges on those
hydrogens. The value specified will
be added to the hydrogen <i>cis</i> to the oxygen (the electronegative
atom nearby increase the partial positive charge) and subtracted from the <i>trans</i>-H to
keep them both at the same total charge. For example, if both hydrogens
have a charge of +0.36, a specification of 0.05 here will yield charges
of 0.41 (<i>cis</i>-O) and 0.31 (<i>trans</i>-O). It will be useful to
track these changes using <a href="keywords.html#ELECREPORT">ELECREPORT</a>.
It is very
important to note, however, that fundamentally a sampling algorithm may
isomerize the amide bond and hence render the correction
incorrect and - moreover - that reading in a structure may flip the two
hydrogens to start out with (because of inconsistent numbering between two software packages).
Hence, this keyword should be used only when absolutely necessary (and its sign may 
have to be flipped to achieve the desired effect).<br/>
This correction to primary amides is a specific example for the occasional
need to overwrite partial charge parameters for atoms due to "biotype splitting".
The more general approach provided CAMPARI for this explicit purpose is 
to "patch" the partial charge set by a <a href="inputfiles.html#FMCSC_CPATCHFILE">dedicated input file</a>.
<br/>
<h4><a class="NoHi" id="CPATCHFILE"><b>CPATCHFILE</b></a></h4>
If the <a href="keywords.html#SC_POLAR">polar potential</a> is in use,
this keyword can be used to provide the location and name of an<a href="inputfiles.html#FMCSC_CPATCHFILE">
input file</a> that allows overriding some or all of the partial charge parameters
CAMPARI obtains from the parameter file (see <a href="parameters.html#S3_Charge_types">elsewhere</a>).
This can be required to match the exact standard given by a force field with
a finer biotype parsing. Note that - by default - such corrections are 
error-prone and should only be used when absolutely needed. In any case,
the user is recommended to use <a href="keywords.html#ELECREPORT">ELECREPORT</a> for
a detailed summary of final partial charges in the system.<br/>
<h4><a class="NoHi" id="DIPREPORT"><b>DIPREPORT</b></a></h4>
This simple logical will - when turned on by the user - produce two
summary files (see <a href="outputfiles.html#DIPOLE_GROUPS.vmd">DIPOLE_GROUPS.vmd</a> and 
<a href="outputfiles.html#MONOPOLES.vmd">MONOPOLES.vmd</a>),
which allow to graphically assess the automatically determined charge groups.
The former will visualize <b>all</b> charge groups in the system (not just the net neutral ones)
by highlighting all atoms belonging to each group. The second will visualize the 
"center" atom of all groups carrying a net charge (the meaning of this is defined by the value
for <a href="keywords.html#POLTOL">POLTOL</a>). Note that - naturally - this option is not
available if <a href="keywords.html#SC_POLAR">SC_POLAR</a> is zero.<br/>
<h4><a class="NoHi" id="NCPATCHFILE"><b>NCPATCHFILE</b></a></h4>
If the <a href="keywords.html#SC_POLAR">polar potential</a> is in use, CAMPARI
automatically determines charge groups, <i>i.e.</i>, groups of atoms within a 
residue that are topologically close and whose partial charges sum up to zero or 
to an integer net charge. If <a href="keywords.html#LREL_MD">LREL_MD</a> is 4 or 5
and/or <a href="keywords.html#LREL_MC">LREL_MC</a> is 1, 2, or 3, this information
is used to flag residues as carrying ionic groups, which leads to the computation
of additional interactions even if residues are not in each others'
<a href="keywords.html#CUTOFFMODE">neighbor lists</a>. A residue is flagged if it contains
at least one charge group with a total, absolute charge greater than
a <a href="keywords.html#POLTOL">tolerance</a>
that is zero by default (and there should be very good reasons for increasing this tolerance).<br/>
This keyword allows the user to specify location and name of an optional
input file that can perform two important tasks:<br/>
<ul>
<li>It allows removal of the net charge flag for specific residues, thereby altering
the overall interaction model (if the corresponding options for <a href="keywords.html#LREL_MD">LREL_MD</a>
and/or <a href="keywords.html#LREL_MC">LREL_MC</a> are selected).</li>
<li>It allows the manual specification of sequential target values for the total charges of
charge groups to be identified. This is currently the only way to manually alter the
charge group partitioning, and can be crucial when simulating unsupported residues
and/or when dealing with charge sets that do not group naturally (such as those within
the AMBER family of force fields).</li>
</ul> 
The details of the input and an example application are described <a href="inputfiles.html#FMCSC_NCPATCHFILE">elsewhere</a>.
<br/>
<h4><a class="NoHi" id="POLTOL"><b>POLTOL</b></a></h4>
If the <a href="keywords.html#SC_POLAR">polar potential</a> is in use, CAMPARI
automatically determines charge groups, <i>i.e.</i>, groups of atoms within a 
residue that are topologically close and whose partial charges sum up to zero or 
to an integer net charge. As described <a href="keywords.html#NCPATCHFILE">above</a>,
these net charge values can be patched. This may, for example, be used to 
obtain a grouping into <i>approximately neutral</i> groups for partial charge sets
that include complex polarization patterns. In order to avoid having the resultant
groups cause CAMPARI to flag the corresponding residue as carrying a net charge
(<i>i.e.</i>, they are treated like ions), this keyword allows the user to
defined an increased tolerance for what is considered "approximately neutral".
This is relevant because treatment of residues as ions can have substantial
implications for the interaction model in particular in terms of computational
efficiency (see <a href="keywords.html#LREL_MC">LREL_MC</a> and <a href="keywords.html#LREL_MD">LREL_MD</a>).
Note that this keyword operates at the charge group level, whereas patches via
<a href="keywords.html#NCPATCHFILE">NCPATCHFILE</a> can (also) disable the ionic flag 
status of residues. Therefore, both offer different levels of control. The numerical value
specified here (in units of e) is compared to the total charge of a given charge group.<br/>
As an example, consider a terminal nucleotide residue carrying a 5'-phosphate with an integer
negative charge. Suppose that the partial charges on the phosphate linker to the next residue
are such that - in addition to the terminal phosphate - this leaves a charge group
with a small, fractional charge. In this case, the residue-level patch could only 
remove the net charge flag for the entire residue (probably undesirable), whereas the tolerance
setting described here could specifically eliminate the group with the fractional
charge from the list of ionic groups.
The default tolerance is set to be zero within reasonable numerical precision.
Note that this keyword has no impact on the charge group partitioning itself and
is relevant only if <a href="keywords.html#LREL_MD">LREL_MD</a> is 4 or 5
and/or <a href="keywords.html#LREL_MC">LREL_MC</a> is 1, 2, or 3.<br/>
<h4><a class="NoHi" id="FUDGE_ST_14"><b>FUDGE_ST_14</b></a></h4>
This keyword provides a flat 1-4 scaling factor for interatomic,
non-bonded interactions of
specific types. 1-4 interactions are defined according to the choice
for <a href="keywords.html#MODE_14">MODE_14</a>
and depend on the setting for <a href="keywords.html#INTERMODEL">INTERMODEL</a>
as well.
The value for FUDGE_ST_14 is applied to all steric and dispersion
potentials,
<i>i.e.</i>, the potentials turned on by <a
 href="keywords.html#SC_IPP">SC_IPP</a>, <a
 href="keywords.html#SC_ATTLJ">SC_ATTLJ</a>, and <a
 href="keywords.html#SC_WCA">SC_WCA</a>. The only other
1-4-scaled interaction potential is the electrostatic one for which a
separate 1-4-scaling factor is in use (see <a
 href="keywords.html#FUDGE_EL_14">FUDGE_EL_14</a>).
All other pairwise, non-bonded potentials are never subjected to
1-4-corrections (see for example <a href="keywords.html#SC_TABUL">SC_TABUL</a> or
<a href="keywords.html#SC_DREST">SC_DREST</a>). Note that the value
for FUDGE_ST_14 is applied <i>in addition</i> to corrections applied
at the parameter
level by providing 1-4-specific σ- and ε-parameters in the parameter
file
(see <a href="parameters.html#S2_LJ-types">PARAMETERS</a>).<br/>
<h4><a class="NoHi" id="FUDGE_EL_14"><b>FUDGE_EL_14</b></a></h4>
Similar to <a href="keywords.html#FUDGE_ST_14">FUDGE_ST_14</a>, this
keyword specifies a scale factor for 1-4-interactions.
Here, the provided value will be applied specifically to electrostatic
interactions (see <a href="keywords.html#SC_POLAR">SC_POLAR</a>)
only.
If <a href="keywords.html#ELECMODEL">ELECMODEL</a> is set to 2,
any charge group interaction will be scaled as a whole by this factor,
as soon as any of the possible atom pairs fulfill the 1-4-criterion
(see <a href="keywords.html#MODE_14">MODE_14</a>). <br/>
<h4><a class="NoHi" id="MODE_14"><b>MODE_14</b></a></h4>
This keyword's relevance is limited to the case in which <a
 href="keywords.html#INTERMODEL">INTERMODEL</a> is 1.
Then, this essentially defines what a 1-4-interaction is, specifically
whether anything separated by
exactly three bonds or by exactly one relevant rotatable bond should be
considered 1-4:<br/>
<ol>
  <li>Only two interacting atoms separated by exactly three bonds are
treated as 1-4.</li>
  <li>Two interacting atoms separated by exactly one relevant, freely
rotatable bond are always treated as 1-4.</li>
</ol>
The difference only matters for rigid systems and is best illustrated
in an example:<br/>
Take a phenylalanine residue and consider the
CA-CB-CG-CD1 stretch (from C<sub>α</sub> to one of the C<sub>δ</sub>).
This is
exactly three bonds and the bond CB-CG is the only
relevant rotatable one (CA-CB is also rotatable but irrelevant, since
CA lies on the axis, while CG-CD1 is not
rotatable). CA and CD1 are treated as 1-4 in both modes. Now consider
the CA-CB-CG-CD1-CE1 stretch. These are
four bonds and CA and CE1 are not considered 1-4 in mode 1. However,
there is still only one relevant rotatable bond in
between (CB-CG, since CG-CD1 is rigid), so CA and CE1 are in fact
treated as 1-4 in mode 2.<br/>
Note that CAMPARI allows specific modifications of 1-4-interactions,
either through the use
of fudge factors (see <a href="keywords.html#FUDGE_ST_14">FUDGE_ST_14</a>
and
<a href="keywords.html#FUDGE_EL_14">FUDGE_EL_14</a>) or through
specific parameters
provided in the parameter file. If neither of those indicates a
deviation from normal
interaction rules, then this keyword becomes irrelevant as well.<br/>
<h4><a class="NoHi" id="ELECREPORT"><b>ELECREPORT</b></a></h4>
If the <a href="keywords.html#SC_POLAR">polar potential</a> is in use,
this simple logical allows the user to request a summary for the
close-range electrostatic interactions in the system. Similarly to <a
 href="keywords.html#INTERREPORT">INTERREPORT</a>,
this keyword mostly serves debugging purposes and should only be
needed/required to understand
the details of the short-range interaction setup.<br/>
<h4><a class="NoHi" id="SC_IMPSOLV"><b>SC_IMPSOLV</b></a></h4>
This keyword serves two functions. First, as a logical it enables the
ABSINTH
implicit solvent model, <i>i.e.</i>, it will compute the direct
mean-field interaction (DMFI) of each solute with the continuum and
enable
screening of polar interactions (if turned on → <a
 href="keywords.html#SC_POLAR">SC_POLAR</a>).
For the former (the DMFI) it simultaneously serves as the linear
scaling
factor. Note that the <i>amount</i> of screening of polar interactions
is
not dependent on this keyword and solely determined by other parameters
(in particular <a href="keywords.html#IMPDIEL">IMPDIEL</a>). The DMFI
is defined as:<br/>
<br/>
E<sub>DMFI</sub> = c<sub>DMFI</sub>·Σ<sub>k</sub> ΔG<sub>FES,k</sub> [Σ<sub>i</sub>
ζ<sub>i</sub><sup>k</sup>·υ<sub>i</sub><sup>k</sup>]<br/>
<br/>
Here, υ<sub>i</sub><sup>k</sup> is the solvation state of the i<sup>th</sup>
atom in the
k<sup>th</sup> solvation group and ζ<sub>i</sub><sup>k</sup> is its
weight factor. The
solvation states are computed by CAMPARI and vary throughout the
simulation whereas the
weight factors are constant. The reference free energies of solvation for each
solvation group (ΔG<sub>FES,k</sub>) are provided through the parameter
file and are constant
as well (for the latter see <a href="parameters.html#S4_Free_energies_of_solvation">PARAMETERS</a>).
Note
that the computation of the DMFI given the υ<sub>i</sub><sup>k</sup> is
a computation of negligible cost and that CAMPARI obtains the υ<sub>i</sub><sup>k</sup>
while computing short-range non-bonded interactions at a moderate
additional
cost. This implies that the ABSINTH implicit solvation model is
speed-limited almost exclusively by the complications incurred by the
screening
of polar interactions. The user is referred to Vitalis and Pappu for
further details (<a href="references.html#ref19_1">reference</a>).<br/>
To employ the ABSINTH implicit solvent model as published use:<br/>
<br/>
<tt>
<a href="keywords.html#FOSFUNC">FMCSC_FOSFUNC</a> 1<br/>
<a href="keywords.html#FOSMID">FMCSC_FOSMID</a> 0.1<br/>
<a href="keywords.html#FOSTAU">FMCSC_FOSTAU</a> 0.25<br/>
<a href="keywords.html#SCRFUNC">FMCSC_SCRFUNC</a> 1<br/>
<a href="keywords.html#SCRMID">FMCSC_SCRMID</a> 0.9<br/>
<a href="keywords.html#SCRTAU">FMCSC_SCRTAU</a> 0.5<br/>
<a href="keywords.html#SAVMODE">FMCSC_SAVMODE</a> 1<br/>
<a href="keywords.html#SAVPROBE">FMCSC_SAVPROBE</a> 2.5<br/>
<a href="keywords.html#IMPDIEL">FMCSC_IMPDIEL</a> 78.2<br/>
<a href="keywords.html#SCRMODEL">FMCSC_SCRMODEL</a> 2 # (or 1)<br/>
</tt>
<br/>
Note that as of 2013 the more rigorous <a href="keywords.html#SCRMODEL">screening model</a> (option 1) appears
in published literature only for the work on arginine-rich peptides (<a href="references.html#ref24_8">Mao <i>et al.</i></a>).
Many other screening models are fully implemented but without any published data available (as of 04/2016). Similarly,
it is possible to switch the functional forms for mapping from solvent-accessible volume fractions 
to solvation states using keywords <a href="keywords.html#FOSFUNC">FOSFUNC</a> and 
<a href="keywords.html#SCRFUNC">SCRFUNC</a> and to change the way overlap volumes are computed
(&rarr; <a href="keywords.html#SAVMODE">SAVMODE</a>).
Finally, note that the DMFI can be made temperature-dependent by additions to the
<a href="parameters.html#S4_Free_energies_of_solvation">parameter file</a> and use of keyword 
<a href="keywords.html#FOSMODE">FOSMODE</a>.<br/>
<h4><a class="NoHi" id="SAVPATCHFILE"><b>SAVPATCHFILE</b></a></h4>
This keyword can be used to provide the location and name of an<a href="inputfiles.html#FMCSC_SAVPATCHFILE">
input file</a> that allows overriding the default, topology-derived values
for the maximum fractions of the solvent-accessible volume, &eta;<sub>i,max</sub>.
Because values depend on hard-coded parameters (geometry) and user-level settings
(choice of <a href="parameters.html#S2_LJ-types">parameters</a> and keyword <a href="keywords.html#SAVPROBE">FMCSC_SAVPROBE</a>),
CAMPARI (re)computes these values at the beginning of each run. This utilizes
the default local geometries (not input structures) and works by decomposing the molecule into suitably
small model compound units. The patch prints a summary of all successful changes,
and results can also be assessed via column 4 in output file <a href="outputfiles.html#SAV_BY_ATOM.dat">SAV_BY_ATOM.dat</a>.
Note that these values rely on other patchable quantities, most notably atomic radii.
Patches follow a hierarchy, and a patched value for the &eta;<sub>i,max</sub> overrides
values derived from radii that could be patched themselves (here, <a href="keywords.html#RPATCHFILE">RPATCHFILE</a>
overrides indirect reassignment via <a href="keywords.html#LJPATCHFILE">LJPATCHFILE</a>) without touching
the atomic radii. This means that it possible for the patched values of &eta;<sub>i,max</sub> to be grossly inconsistent with
the underlying set of radii.<br/>
<h4><a class="NoHi" id="ASRPATCHFILE"><b>ASRPATCHFILE</b></a></h4>
This keyword can be used to provide the location and name of an <a href="inputfiles.html#FMCSC_SAVPATCHFILE">
input file</a> that allows overriding the default, topology-derived values
for the pairwise reduction factor for atomic volumes used in most computations using the atomic volume,
most prominently the <a href="keywords.html#SC_IMPSOLV">ABSINTH implicit solvation model</a>.
Reduction factors are needed, because the exclusion volumes of covalently bound atoms
overlap. The reduction factors are computed in linear approximation, and - by default - the overlap
volume is subtracted evenly from the remaining atomic volume of each partner.
These values depend on various parameters (<a href="parameters.html#S2_LJ-types">parameters</a> and hard-coded geometry), and
CAMPARI (re)computes them at the beginning of each run. The patch prints a summary of all successful changes,
and results can also be assessed via column 7 in output file <a href="outputfiles.html#SAV_BY_ATOM.dat">SAV_BY_ATOM.dat</a>.
See <a href="keywords.html#SAVPATCHFILE">SAVPATCHFILE</a> for remarks on the hierarchy of patches
of atomic parameters.<br/>
<h4><a class="NoHi" id="FOSPATCHFILE"><b>FOSPATCHFILE</b></a></h4>
Since there is no external way to control details of the solvation group assignments
relevant to the computation of the DMFI (&rarr; <a href="keywords.html#SC_IMPSOLV">SC_IMPSOLV</a>) through
the <a href="parameters.html#S4_Free_energies_of_solvation">parameter file</a>,
CAMPARI offers users to alter the default group partitioning and to control reference free energies
of solvation on a per-moiety basis through a dedicated input file. This also supports
alterations to transfer enthalpies and heat capacities at the patch level if a
<a href="keywords.html#FOSMODE">temperature-dependent DMFI</a> is in use.
This keyword is used to provide the location and name of this <a href="inputfiles.html#FMCSC_FOSPATCHFILE">input file</a>.
There are some underlying restrictions to the freedom of choices, but
in principle it is possible to completely redesign the underlying DMFI model using this facility.
Restrictions and formatting are explained <a href="inputfiles.html#FMCSC_FOSPATCHFILE">
elsewhere</a>. The applied patch implies that CAMPARI will keep the built-in default partitioning along
with the default reference values from the parameter file (see <a href="parameters.html#S4_Free_energies_of_solvation">elsewhere</a>)
for unpatched residues and molecules. As with other force field patches, these corrections are 
error-prone and CAMPARI output should always be double-checked against the intended input.
For this purpose, keyword <a href="keywords.html#FOSREPORT">FOSREPORT</a> and associated output file
<a href="outputfiles.html#FOS_GROUPS.vmd">FOS_GROUPS.vmd</a> will be of particular use.<br/>
<h4><a class="NoHi" id="FOSMODE"><b>FOSMODE</b></a></h4>
<a href="keywords.html#TEMP">Simulation temperature</a> is used frequently in biomolecular sampling both to explicitly
probe temperature-dependent behavior and to enhance sampling. For the former, the 
correctness of fixed force field parameters becomes questionable. If the 
<a href="keywords.html#SC_IMPSOLV">DMFI of the ABSINTH implicit solvation model</a> is in use,
this keyword allows the user to make <i>some</i> of the parameters of the model temperature-dependent themselves. 
There are currently two options:
<ol start='0'>
<li>All values for &Delta;G<sub>FES</sub> in the equation <a href="keywords.html#SC_IMPSOLV">above</a> are fixed to
the reference values specified in the <a href="parameters.html#S4_Free_energies_of_solvation">parameter file</a>
 independent of temperature or any other environmental parameters. This is the default.</li>
<li>CAMPARI tries to extract values for temperature-independent enthalpies and heat capacities of the transfer
process of a given model compound from a fixed conformation in the gas phase into water from the 
 <a href="parameters.html#S4_Free_energies_of_solvation">parameter file</a>. By default, all CAMPARI
parameter files <b>do not contain these parameters</b>. The temperature-dependent values are computed as:<br/>
<br/>
&Delta;G<sub>FES</sub>(T) = (&Delta;G<sub>FES</sub>(T<sub>0</sub>) - &Delta;H<sub>FES</sub>)T/T<sub>0</sub> + &Delta;H<sub>FES</sub> + &Delta;C<sub>p,FES</sub>[T[1 - ln(T/T<sub>0</sub>)] - T<sub>0</sub>]<br/>
<br/>
Here, &Delta;H<sub>FES</sub> and &Delta;C<sub>p,FES</sub> are the aforementioned enthalpies and heat capacities of transfer,
whereas T denotes the <a href="keywords.html#TEMP">simulation temperature</a> and T<sub>0</sub> denotes the reference
temperature for the listed free energy value. T<sub>0</sub> is set by keyword <a href="keywords.html#FOSREFT">FOSREFT</a>.</li>
</ol>
Note that this keyword is irrelevant unless the parameter file actually contains entries at least for the 
solvation enthalpies. If no parameters are present, the values are adjusted such that &Delta;G<sub>FES</sub>(T)
equals &Delta;G<sub>FES</sub>(T<sub>0</sub>) for all temperatures. Furthermore, it is important to keep in mind
that a temperature-dependent model may not be more meaningful if other parameters remain fixed. For the
screened ABSINTH part, it is at least possible to adjust the <a href="keywords.html#IMPDIEL">reference dielectric</a>
for water in a temperature-dependent manner.<br/>
<h4><a class="NoHi" id="FOSREFT"><b>FOSREFT</b></a></h4>
If the <a href="keywords.html#SC_IMPSOLV">DMFI of the ABSINTH implicit solvation model</a> is in use, and if 
a <a href="keywords.html#FOSMODE">temperature-dependent model</a> has been requested, this keyword
sets the assumed reference temperature for transfer free energies of solvation listed in the
<a href="parameters.html#S4_Free_energies_of_solvation">corresponding section of the parameter file</a>.
It defaults to 298K.<br/>
<h4><a class="NoHi" id="FOSREPORT"><b>FOSREPORT</b></a></h4>
This simple logical allows the user to request CAMPARI to print a
summary of the group-based reference free energies, enthalpies, and heat capacities 
of solvation read from the parameter file. The latter two terms are only
relevant if a <a href="keywords.html#FOSMODE">temperature-dependent model</a> has been selected.
In general, the reference free energies will correspond exactly to the terms &Delta;G<sub>FES,k</sub>
<a href="keywords.html#SC_IMPSOLV">above</a>. Note, however, that this initial output is not a summary of the
system but rather of the parameters, <i>i.e.</i>, it is more
like <a href="keywords.html#VDWREPORT">VDWREPORT</a> and unlike <a
 href="keywords.html#ELECREPORT">ELECREPORT</a> or <a
 href="keywords.html#INTERREPORT">INTERREPORT</a>. If some solvation group
assignments and parameters are changed via a corresponding <a href="keywords.html#FOSPATCHFILE">patch file</a>,
this keyword will also ensure that the applied patch is documented in detail in CAMPARI's
log output. The actual group partitioning for the system at hand (but not the associated 
numerical parameters) is available from 
output file <a href="outputfiles.html#FOS_GROUPS.vmd">FOS_GROUPS.vmd</a>.<br/>
<h4><a class="NoHi" id="SAVPROBE"><b>SAVPROBE</b></a></h4>
This keyword is crucial for the ABSINTH implicit solvent model and
specifies the size of the solvation shell around individual atoms. The
input value is interpreted to be the radius in Å of a solvent sphere
rolled around each atom and consequently twice the value
of SAVPROBE will yield the thickness of the assumed first solvation
layer.
The resultant solvation shell volume is the starting point for
determining solvent-accessible
volume fractions (η<sub>i</sub>) which are then mapped to yield
atomic solvation states (υ<sub>i</sub>) which are relevant for
the <a href="keywords.html#SC_IMPSOLV">DMFI</a> and screened
electrostatic interactions
(→ <a href="keywords.html#SCRMODEL">SCRMODEL</a>).
In order to compute solvent-accessible volumes, overlap volumes of spheres
need to be calculated or estimated, and how to do that is controlled by keyword
<a href="keywords.html#SAVMODE">SAVMODE</a>. 
It is important to note that SAVPROBE is the only keyword other than
<a href="keywords.html#SAVMODE">SAVMODE</a> directly
controlling the η<sub>i</sub>
which are otherwise purely functions of atomic parameters (see <a
 href="parameters.html#S2_LJ-types">PARAMETERS</a>).
Lastly, note that this keyword is still relevant for SAV analysis
even though the implicit solvent model might not be used (→ <a
 href="keywords.html#SAVCALC">SAVCALC</a>).<br/>
<h4><a class="NoHi" id="SAVMODE"><b>SAVMODE</b></a></h4>
This keyword controls how CAMPARI calculates solvent-accessible volumes. The size of the solvation shell
is defined by atomic radius and the setting for <a href="keywords.html#SAVPROBE">SAVPROBE</a>.
There are currently two options:<br/>
<ol>
<li>Linear approximations are used to calculate pairwise overlap volumes. Individual atomic
volumes are scaled by reduction factors given by molecular topology.</li>
<li>Pairwise overlap volumes are calculated exactly (polynomial equation). Individual atomic
volumes are scaled by reduction factors given by molecular topology.</li>
</ol>
Note that none of the supported options account for the fact that more than two spheres can
overlap at once or that the use of volume reduction factors can become misleading for cases
of fractional overlap. The relevant parameters underlying the calculation can all be 
patched (see <a href="keywords.html#RPATCHFILE">RPATCHFILE</a>, <a href="keywords.html#ASRPATCHFILE">ASRPATCHFILE</a>, and 
<a href="keywords.html#SAVPATCHFILE">SAVPATCHFILE</a>).<br/>
<h4><a class="NoHi" id="FOSFUNC"><b>FOSFUNC</b></a></h4>
If the <a href="keywords.html#SC_IMPSOLV">DMFI of the ABSINTH implicit solvation model</a> is in use,
this keyword controls which functional form is used to map the solvent-accessible volume
to the DMFI solvation state.
<ol>
<li>The published smoothed and stretched sigmoidal function is used, which relies on 2 parameters,
<i>viz.</i>, <a href="keywords.html#FOSMID">&chi;<sub>f</sub></a> and <a href="keywords.html#FOSTAU">&tau;<sub>f</sub></a>.
The functional form is:<br/>
υ<sub>i,f</sub> ~ [ 1.0 + exp[ - (η<sub>i</sub>-h(χ<sub>f</sub>))/τ<sub>f</sub>
] <sup>-1</sup><br/><br/>
Here, υ<sub>i,f</sub> is the DMFI solvation state for atom <i>i</i>, η<sub>i</sub> is the solvent-accessible volume
fraction for atom <i>i</i>, and h(...) is a linear function shifting
the mid-point parameter χ<sub>f</sub> (set by <a href="keywords.html#FOSMID">FOSMID</a>)
such that symmetry between the two natural limits of η<sub>i</sub> is obtained. The normalizer is not shown
in the equation. The function is smooth over the interval over which it applies.</li>
<li>A stair-stepped, stretched sigmoidal function is used, which relies on 5 parameters,
<i>viz.</i>, <a href="keywords.html#FOSMID">&chi;<sub>f</sub></a>, <a href="keywords.html#FOSTAU">&tau;<sub>f</sub></a>,
<a href="keywords.html#FOSGRANULE"><i>g</i><sub>f</sub></a>, <a href="keywords.html#FOSTIGHT">&zeta;<sub>f</sub></a>, and 
<a href="keywords.html#FOSSHIFT">FOSSHIFT</a>. This is a piecewise-defined function. The width in solvent-accessible
volume space is set directly by <a href="keywords.html#FOSGRANULE"><i>g</i><sub>f</sub></a> starting from the lower natural limit.
Within each piece, the fractional interval <i>g</i><sub>f</sub>&zeta;<sub>f</sub> is flat with values set by
functional form 1 above (thus relying on <a href="keywords.html#FOSMID">&chi;<sub>f</sub></a> and
<a href="keywords.html#FOSTAU">&tau;<sub>f</sub></a>). If we term two neighboring plateau values as υ<sub>1</sub> and
υ<sub>2</sub>, then the functional form for the interval of width <i>g</i><sub>f</sub>(1-&zeta;<sub>f</sub>) is:<br/>
υ<sub>i,f</sub> = 0.5(υ<sub>2</sub> - υ<sub>1</sub>)·(1 - cos( (η<sub>i</sub> - η<sub>1</sub>)·&pi;(1-&zeta;<sub>f</sub>)<sup>-1</sup>/&Delta;&eta;))<br/>
Here, η<sub>1</sub> corresponds to the left boundary of the interval in question, and &Delta;&eta; is the equivalent
of <i>g</i><sub>f</sub> in solvent-accessible volume fraction space. The position of the interpolation interval within the
total interval of width &Delta;&eta; is defined by keyword <a href="keywords.html#FOSSHIFT">FOSSHIFT</a>. Note that
functional form 1 is theoretically recovered if <a href="keywords.html#FOSGRANULE"><i>g</i><sub>f</sub></a> approaches
0.0. Note also that <a href="keywords.html#FOSSHIFT">FOSSHIFT</a> becomes irrelevant as <a href="keywords.html#FOSTIGHT">&zeta;<sub>f</sub></a>
approaches 0.0 and that the limit of <a href="keywords.html#FOSTIGHT">&zeta;<sub>f</sub></a> reaching 1 (true step function)
is numerically forbidden.</li>
</ol>
Note that the additional parameters for the second functional form are not independent and that 
the coarse shape of the function is preserved, especially if <a href="keywords.html#FOSGRANULE">FOSGRANULE</a>
is small (left near the default).<br/> 
<h4><a class="NoHi" id="FOSTAU"><b>FOSTAU</b></a></h4>
The atomic solvent-accessible volumes, η<sub>i</sub>, are mapped to
solvation
states by two different sets of parameters, the first being responsible
for obtaining
υ<sub>i,f</sub> which are the solvation states describing the change in
<a href="keywords.html#SC_IMPSOLV">DMFI</a> with changes in
conformation (the second set is responsible for obtaining υ<sub>i,s</sub>
which describe the change in dielectric response with change in
conformation). The details of the <a href="keywords.html#FOSFUNC">mapping function</a> are complicated by the requirement
to normalize the
υ<sub>i,f</sub> to the well-defined interval [0:1] but in essence it
holds:<br/>
<br/>
υ<sub>i,f</sub> ~ [ 1.0 + exp[ - (η<sub>i</sub>-h(χ<sub>f</sub>))/τ<sub>f</sub>
] <sup>-1</sup><br/>
<br/>
Here, τ<sub>f</sub> is the parameter determining the steepness of the
sigmoidal interpolation and this is the
parameter determined by this keyword. Large values will yield an
approximately linear re-mapping between the natural
limits of η<sub>i</sub> which are derived from closest packing of
spheres (lower limit) and model compound
topology (upper limit). This case is not obvious from the above
equation but is obtained via τ<sub>f</sub>-dependent re-scaling to
match the target interval. Conversely, very small values yield a
step-function like interpolation. h(x) is a linear function shifting
the mid-point parameter χ<sub>f</sub> (set by <a
 href="keywords.html#FOSMID">FOSMID</a>)
such that symmetry between the two natural limits of η<sub>i</sub> is
obtained.<br/>
<h4><a class="NoHi" id="FOSMID"><b>FOSMID</b></a></h4>
As explained for <a href="keywords.html#FOSTAU">FOSTAU</a>, the
mapping from solvent-accessible
volumes η<sub>i</sub> to solvation states υ<sub>i,f</sub> relies on a
mid-point
parameter, χ<sub>f</sub>. In the functional form given above, the
mid-point of the sigmoidal function (<i>i.e.,</i> the point of maximal
slope) can be shifted toward either one of the natural
limits of η<sub>i</sub> by varying this keyword between zero and unity.
Since the sigmoidal nature of the interpolation disappears in the limit
of large
values chosen for <a href="keywords.html#FOSTAU">FOSTAU</a>, FOSMID is
only relevant for sufficiently small values of <a
 href="keywords.html#FOSTAU">FOSTAU</a> and its impact
deteriorates progressively with growing <a href="keywords.html#FOSTAU">FOSTAU</a>.
Note
that the default is 0.5 but that it is easily possible to generate
fairly asymmetric interpolation
functions in the process (<i>i.e.</i>, at values close to zero atoms
are considered solvated at almost all
times while at values close to unity the opposite is true). There is a
Matlab script
in the tools-directory (<a href="../tools/sigmainterpol.m">sigmainterpol.m</a>) that helps assess the effect <a
 href="keywords.html#FOSTAU">FOSTAU</a> and <a
 href="keywords.html#FOSMID">FOSMID</a> have given values for the
natural limits of η<sub>i</sub>.<br/>
<h4><a class="NoHi" id="FOSGRANULE"><b>FOSGRANULE</b></a></h4>
As explained <a href="keywords.html#FOSFUNC">above</a>, this keyword applies
only to the case of a stair-stepped interpolation function from solvent-accessible volume fraction
to DMFI solvation state. It sets the volume increment to assume for each step (in &#8491;<sup>3</sup>).
The solvation shell volume of each atom is then discretized by this increment and 
a step-like function is applied to each resulting interval in &eta;-space. 
The default is set to the volume available to a single water molecule when assuming 
liquid water with a density of 1g/cm<sup>3</sup>.<br/>
<h4><a class="NoHi" id="FOSTIGHT"><b>FOSTIGHT</b></a></h4>
As explained <a href="keywords.html#FOSFUNC">above</a>, this keyword applies
only to the case of a stair-stepped interpolation function from solvent-accessible volume fraction
to DMFI solvation state. It sets the narrowness of the cosine-based step interpolation within
each interval defined by <a href="keywords.html#FOSGRANULE">FOSGRANULE</a> and
<a href="keywords.html#FOSTIGHT">FOSTIGHT</a>. A value of 0.0 gives a smooth piecewise
function without any plateau regions whereas smaller values intersperse plateau regions
by making the transition narrower (function remains smooth, however). The theoretical
limit of 1.0 gives a true step function, but this is numerically forbidden.<br/>
<h4><a class="NoHi" id="FOSSHIFT"><b>FOSSHIFT</b></a></h4>
As explained <a href="keywords.html#FOSFUNC">above</a>, this keyword applies
only to the case of a stair-stepped interpolation function from solvent-accessible volume fraction
to DMFI solvation state. It sets the position of the step interpolation within
an interval defined by <a href="keywords.html#FOSGRANULE">FOSGRANULE</a> and
<a href="keywords.html#FOSTIGHT">FOSTIGHT</a>, and values from 0.0 (left) to 1.0 (right) are possible.
The keyword is irrelevant if <a href="keywords.html#FOSTIGHT">FOSTIGHT</a> (&zeta;<sub>f</sub> above)
is zero.<br/>
<h4><a class="NoHi" id="IMPDIEL"><b>IMPDIEL</b></a></h4>
This keyword lets the user set the assumed continuum dielectric.
Primarily, this is used in the ABSINTH solvation model to treat the
screening
of electrostatic interactions. The dielectric constant enters the
equation for the modified Coulomb sum in different ways depending on the
choice for <a href="keywords.html#SCRMODEL">SCRMODEL</a>.
In general, the solvent-accessible volumes, &eta;<sub>i</sub> will be mapped to yield
solvation states
υ<sub>i,s</sub> for dielectric screening. The mapping process is
equivalent to the <a href="keywords.html#FOSFUNC">one described for the DMFI</a> but relies
on a separate set of parameters (see <a href="keywords.html#SCRFUNC">SCRFUNC</a>). In the
published ABSINTH model, the screening factor for the polar interaction is given as:<br/>
<br/>
s<sub>ij</sub> = [ 1 - aυ<sub>i,s</sub> ]·[ 1 - aυ<sub>j,s</sub> ]<br/>
a = (1 - ε<sub>r</sub><sup>-1/2</sup>)<br/>
<br/>
Here, ε<sub>r</sub> is the relative dielectric constant set by this
keyword.
The above equation corresponds rigorously only to using screening model
2. Note how the functional form ensures an interpolation between the
vacuum (υ<sub>i,j</sub> = 0.0 → ε<sub>eff</sub> = 1.0) and the fully
screened cases
(υ<sub>i,j</sub> = 1.0 → ε<sub>eff</sub> = ε<sub>r</sub>).<br/>
In a completely different context, this keyword also sets the assumed continuum dielectric outside the
cutoff sphere when treating
electrostatics interactions with reaction-field methods (→ <a
 href="keywords.html#LREL_MD">LREL_MD</a>). For this latter purpose,
it may be advantageous to set a very large value.<br/>
<h4><a class="NoHi" id="SCRMODEL"><b>SCRMODEL</b></a></h4>
This keyword has several options which allow the user to control how
dielectric screening of charges is done,
specifically what functional form is used for the pairwise screening
factor s<sub>ij</sub> for a pair of interacting atoms i and j. The
electrostatic framework within ABSINTH aims specifically
at ensuring that only moieties with well-defined net charges interact (this is discussed
in a different context for <a href="keywords.html#ELECMODEL">ELECMODEL</a>). This
means that for every base
functional form of s<sub>ij</sub> there will be two variants, one in
which the υ<sub>i,s</sub> are used
directly (atom-based) and one in which a charge group-based υ<sub>k,s</sub>
is pre-computed for each group k out of its constituent atoms'
solvation states υ<sub>i,s</sub><sup>k</sup>.
Only the latter ensures rigorously that two formally neutral charge
groups interacting will not create
effective charge imbalances by atom-specific screening. The downside of
those models (and the reason
we generally do not recommend using them) is the higher computational
cost associated and the dependence
on the local neutrality in the partial charge set (<i>i.e.,</i> should
the base parameters not
yield any locally neutral subgroups within a residue, the relevant
charge group may be as large as an entire
polynucleotide residue and dielectric responses of fairly distant
moieties may become coupled which
suggests a length scale to the solvent response vastly inconsistent
with the setting for
<a href="keywords.html#SAVPROBE">SAVPROBE</a>). In the latter case,
it may be necessary to attempt to <a href="keywords.html#NCPATCHFILE">patch</a>
the charge groups so that an approximate grouping is obtained.<br/>
<ol>
  <li>For every charge group, the solvation states for the
individual sites are averaged in charge-weighted fashion (group-based →
see above).
The resultant group solvation state υ<sub>k,s</sub> is used to screen
all the charges belonging to this
group:<br/>
s<sub>ij</sub> = [ 1 - aυ<sub>k,s</sub> ]·[ 1 - aυ<sub>l,s</sub> ]<br/>
a = (1 - ε<sub>r</sub><sup>-1/2</sup>)<br/>
Here, we assume atom i is part of the k<sup>th</sup> charge group and
atom j is part of the l<sup>th</sup> charge
group. ε<sub>r</sub> is provided by <a href="keywords.html#IMPDIEL">IMPDIEL</a>.</li>
  <li>This is the published atom-based model and explained above (→ <a
 href="keywords.html#IMPDIEL">IMPDIEL</a>).
The atom-specific screening via atomic solvation states υ<sub>i,s</sub>
will break the neutral paradigm somewhat
but localizes and strengthens specific interactions.</li>
  <li>Since electrostatic interactions tend to be somewhat weak with
the aforementioned options, this model
extends the default model (1) by an important change. If the distance
of atoms i and j, r<sub>ij</sub> approaches
the length-scale of the first solvation shell, the dielectric is
augmented by a distance-dependent contribution
intended to strengthen specific interactions. This yields a very
complicated (although computationally not much more
expensive) model:<br/>
s<sub>ij</sub> = s<sub>env,ij</sub> if r<sub>ij</sub> ≥ (r<sub>0,ij</sub>+d<sub>W</sub>)
    <i>or</i> s<sub>env,ij</sub> &gt; [ &epsilon;<sub>c</sub>·r<sub>0,ij</sub> ]<sup>-1</sup><br/>
s<sub>ij</sub> = [ 1 - f<sub>MIX</sub>·[1 - d<sub>w</sub><sup>-1</sup>(r<sub>ij</sub>-r<sub>0,ij</sub>)]
]·s<sub>env,ij</sub> + f<sub>MIX</sub>·[1 - d<sub>w</sub><sup>-1</sup>(r<sub>ij</sub>-r<sub>0,ij</sub>)]·[
&epsilon;<sub>c</sub>·r<sub>0,ij</sub> ]<sup>-1</sup> if r<sub>ij</sub> &lt; (r<sub>0,ij</sub>+d<sub>W</sub>)
    <i>and</i> r<sub>ij</sub> &gt; r<sub>0,ij</sub><br/>
s<sub>ij</sub> = (1 - f<sub>MIX</sub>)·s<sub>env,ij</sub> + f<sub>MIX</sub>·[
&epsilon;<sub>c</sub>·r<sub>0,ij</sub> ]<sup>-1</sup> if r<sub>ij</sub> &lt; r<sub>0,ij</sub><br/>
s<sub>env,ij</sub> = [ 1 - aυ<sub>k,s</sub> ]·[ 1 - aυ<sub>l,s</sub> ]<br/>
a = (1 - ε<sub>r</sub><sup>-1/2</sup>)<br/>
Here, d<sub>W</sub> is the thickness of the solvation shell (2·<a
 href="keywords.html#SAVPROBE">SAVPROBE</a>) and r<sub>0,ij</sub>
is given by the sum of the atomic radii of atoms i and j. f<sub>MIX</sub>
is the impact of the distance-dependent contribution
and set by keyword <a href="keywords.html#SCRMIX">SCRMIX</a>. &epsilon;<sub>c</sub> is set
by <a href="keywords.html#CONTACTDIEL">CONTACTDIEL</a> (compare
model 4). Note that the distance-dependence is achieved by the
interpolation performed in the distance regime r<sub>0,ij</sub> &lt; r<sub>ij</sub>
&lt;
(r<sub>0,ij</sub>+d<sub>W</sub>) but that no explicit
distance-dependence is introduced otherwise. Furthermore, the contact
dielectric &epsilon;<sub>c</sub>·r<sub>0,ij</sub> is generally overridden if the
environmental dielectric s<sub>env,ij</sub> would
lead to a stronger interaction (less screening). Importantly, model 3 operates on the
group-consistent solvation states (as model 1 does). The atom-specific modification corresponds to model 9. It should be noted
that these models are largely untested and
were part of initial calibration studies with the ABSINTH implicit
solvent model. They are fully supported by CAMPARI, however.</li>
  <li>This model implements a (more or less) pure distance-dependent
dielectric:<br/>
s<sub>ij</sub> = [ &epsilon;<sub>c</sub>·r<sub>ij</sub> ]<sup>-1</sup> if r<sub>ij</sub>
&gt; r<sub>0,ij</sub><br/>
s<sub>ij</sub> = [ &epsilon;<sub>c</sub>·r<sub>0,ij</sub> ]<sup>-1</sup> else<br/>
Here, &epsilon;<sub>c</sub> is the strength of the distance increase of the dielectric
constant and r<sub>0,ij</sub> is the
contact distance below which no further distance dependence to s<sub>ij</sub>
is applied.
The resultant effective dielectric constant is &epsilon;<sub>c</sub>·r<sub>0,ij</sub> which
should never be less than unity.
&epsilon;<sub>c</sub> is set by <a href="keywords.html#CONTACTDIEL">CONTACTDIEL</a> and r<sub>0,ij</sub>
is defined
by the sum of the atomic radii of atoms i and j. This means that the
derivative of the potential is discontinuous
at the contact point. Note that distance-dependent dielectric models
break for a variety of limiting
cases, in particular for anything involving net charged species. They
also rely on a cutoff criterion
since they otherwise do not converge upon a meaningful limiting
dielectric. In this way, distance-dependent
dielectrics may be seen as somewhat analogous to reaction-field
treatments (see <a href="keywords.html#LREL_MD">LREL_MD</a>).</li>
  <li>This model is a group-based variant and therefore similar to
option 1). It attempts to take a different route
toward computing an effective dielectric. Whereas models 1, 2, 3, and 9
use an effective charge approach, this model
(just like models 6, 7, and 8) employs an effective dielectric
approach. The former implies that the solvation
state enters the potential energy for Coulombic interactions as υ<sub>i,s</sub>·υ<sub>j,s</sub>,
    <i>i.e.</i>,
E<sub>POLAR</sub> will scale with changes in the υ<sub>i,s</sub>
differently than the <a href="keywords.html#SC_IMPSOLV">DMFI</a>.
Consequently, screening model 5 implies:<br/>
s<sub>ij</sub> = M( [1 - a·υ<sub>k,s</sub>], [1 - a·υ<sub>l,s</sub>] )<br/>
a = (1 - ε<sub>r</sub><sup>-1</sup>)<br/>
Here, we assume atom i is part of the k<sup>th</sup> charge group and
atom j is part of the l<sup>th</sup> charge
group and M is a function corresponding to a generalized mean whose
exact form is determined by the choice for <a href="keywords.html#ISQM">ISQM</a>.
The latter will be able to give rise to fundamentally different
scaling behavior of E<sub>POLAR</sub> with the υ<sub>i,s</sub>
illustrated for example by taking the
arithmetic mean. This can more closely approximate the behavior seen
for the <a href="keywords.html#SC_IMPSOLV">DMFI</a> and
may allow using much more similar parameter sets τ<sub>s</sub> and χ<sub>s</sub>
compared to τ<sub>f</sub> and χ<sub>f</sub>
than is the case with models 1 or 2. </li>
  <li>This model is the atom-based variant of model 5:<br/>
s<sub>ij</sub> = M( [ 1 - a·υ<sub>i,s</sub>], [ 1 - a·υ<sub>j,s</sub>] )<br/>
a = (1 - ε<sub>r</sub><sup>-1</sup>)<br/>
  </li>
  <li>This model is an equivalent modification to model 5 as model 3 is
to model 1.</li>
  <li>This model is an equivalent modification to model 6 as model 3 is
to model 1.</li>
  <li>This model is an equivalent modification to model 2 as model 3 is
to model 1.</li>
</ol>
<!---
<div style="margin-left: 40px;">&nbsp;<img
 style="width: 240px; height: 20px;"
 alt="V(r) = sum_ij const/r * (si*qi) * (sj*qj)"
 src="website_equations/keywords_SCRMODEL1.gif"><br/>
<br/>
&nbsp;&nbsp;&nbsp; Where&nbsp;<img style="width: 11px; height: 10px;"
 alt="s_i" src="../../Desktop/website%20equations/s_i.gif">,&nbsp;<img
 style="width: 12px; height: 12px;" alt="s_j"
 src="../../Desktop/website%20equations/s_j.gif"> are the reduction
factors and
the effective dielectric is 1/(si*sj). this, however,
delinearizes the mapping between energy and solvation states, <i>i.e.</i>,
SoSi = SoSj = 0.5 does not imply&nbsp;<img
 style="width: 11px; height: 10px;" alt="s_i"
 src="website_equations/s_i.gif">*<img
 style="width: 12px; height: 12px;" alt="s_j"
 src="website_equations/s_j.gif">~ 0.5 (it should
never be quite 1:1 because of: SoSi = SoSj = 0.0 &rarr; <img
 style="width: 11px; height: 10px;" alt="s_i"
 src="website_equations/s_i.gif">*<img
 style="width: 12px; height: 12px;" alt="s_j"
 src="website_equations/s_j.gif"> = 1/78.0)
in other words, while the reference cases (full solvation
or desolvation) are covered, there is a weakening of the electrostatic
energy for partially solvated states. This is why models 5,6 adopts the
following paradigm:<br/>
</div>
<br/>
<div style="margin-left: 40px;"><img style="width: 259px; height: 20px;"
 alt="V(r) = sum_ij const/r * mean(si,sj) *qi*qj"
 src="website_equations/keywords_SCRMODEL2.gif">,<br/>
<br/>
<br/>
</div>
<ol start="6" style="list-style-type: decimal;">
  <li>Like 5), only analogous to 2)</li>
  <li>Like 3), only built on 5)</li>
  <li>Like 3), only built on 6)</li>
  <li>Like 3), only built on 2)</li>
</ol>
-->
<h4><a class="NoHi" id="CONTACTDIEL"><b>CONTACTDIEL</b></a></h4>
For certain screening models, (<a href="keywords.html#SCRMODEL">SCRMODEL</a>
= 3, 4, 7, 8, or 9) a value for the effective dielectric at an
interatomic distance matching the sum
of the two atomic radii exactly is postulated to have the limiting
value of &epsilon;<sub>c</sub>·r<sub>0,ij</sub> (see <a href="keywords.html#SCRMODEL">equations</a>
above).
This keyword provides the value for the parameter &epsilon;<sub>c</sub>.<br/>
<h4><a class="NoHi" id="SCRFUNC"><b>SCRFUNC</b></a></h4>
If the <a href="keywords.html#SC_IMPSOLV">ABSINTH implicit solvation model</a> is in use and
<a href="keywords.html#SC_POLAR">Coulombic interactions</a> are enabled,
this keyword controls which functional form is used to map the solvent-accessible volume
to the solvation state for charge screening (&upsilon;<sub>i,s</sub> for atom <i>i</i>
<a href="keywords.html#SCRMODEL">above</a>). As explained before (see <a href="keywords.html#IMPDIEL">IMPDIEL</a>), the
ABSINTH implicit solvent model employs two sets of solvation states, υ<sub>i,f</sub>
and υ<sub>i,s</sub>. The υ<sub>i,s</sub> determine the effective dielectric acting between
polar atoms (see <a href="keywords.html#SCRMODEL">equations above</a>).<br/>
The text below is basically the same
as that for keyword <a href="keywords.html#FOSFUNC">FOSFUNC</a>.
<ol>
<li>The published smoothed and stretched sigmoidal function is used, which relies on 2 parameters,
<i>viz.</i>, <a href="keywords.html#SCRMID">&chi;<sub>s</sub></a> and <a href="keywords.html#SCRTAU">&tau;<sub>s</sub></a>.
The functional form is:<br/>
υ<sub>i,s</sub> ~ [ 1.0 + exp[ - (η<sub>i</sub>-h(χ<sub>s</sub>))/τ<sub>s</sub>
] <sup>-1</sup><br/><br/>
Here, υ<sub>i,s</sub> is the charge screening solvation state for atom <i>i</i>, η<sub>i</sub> is the solvent-accessible volume
fraction for atom <i>i</i>, and h(...) is a linear function shifting
the mid-point parameter χ<sub>s</sub> (set by <a href="keywords.html#SCRMID">SCRMID</a>)
such that symmetry between the two natural limits of η<sub>i</sub> is obtained. The normalizer is not shown
in the equation. The function is smooth over the interval over which it applies.</li>
<li>A stair-stepped, stretched sigmoidal function is used, which relies on 5 parameters,
<i>viz.</i>, <a href="keywords.html#SCRMID">&chi;<sub>s</sub></a>, <a href="keywords.html#SCRTAU">&tau;<sub>s</sub></a>,
<a href="keywords.html#SCRGRANULE"><i>g</i><sub>s</sub></a>, <a href="keywords.html#SCRTIGHT">&zeta;<sub>s</sub></a>, and 
<a href="keywords.html#SCRSHIFT">SCRSHIFT</a>. This is a piecewise-defined function. The width in solvent-accessible
volume space is set directly by <a href="keywords.html#SCRGRANULE"><i>g</i><sub>s</sub></a> starting from the lower natural limit.
Within each piece, the fractional interval <i>g</i><sub>s</sub>&zeta;<sub>s</sub> is flat with values set by
functional form 1 above (thus relying on <a href="keywords.html#SCRMID">&chi;<sub>s</sub></a> and
<a href="keywords.html#SCRTAU">&tau;<sub>s</sub></a>). If we term two neighboring plateau values as υ<sub>1</sub> and
υ<sub>2</sub>, then the functional form for the interval of width <i>g</i><sub>s</sub>(1-&zeta;<sub>s</sub>) is:<br/>
υ<sub>i,s</sub> = 0.5(υ<sub>2</sub> - υ<sub>1</sub>)·(1 - cos( (η<sub>i</sub> - η<sub>1</sub>)·&pi;(1-&zeta;<sub>s</sub>)<sup>-1</sup>/&Delta;&eta;))<br/>
Here, η<sub>1</sub> corresponds to the left boundary of the interval in question, and &Delta;&eta; is the equivalent
of <i>g</i><sub>s</sub> in solvent-accessible volume fraction space. The position of the interpolation interval within the
total interval of width &Delta;&eta; is defined by keyword <a href="keywords.html#SCRSHIFT">SCRSHIFT</a>. Note that
functional form 1 is theoretically recovered if <a href="keywords.html#SCRGRANULE"><i>g</i><sub>s</sub></a> approaches
0.0. Note also that <a href="keywords.html#SCRSHIFT">SCRSHIFT</a> becomes irrelevant as <a href="keywords.html#SCRTIGHT">&zeta;<sub>s</sub></a>
approaches 0.0 and that the limit of <a href="keywords.html#SCRTIGHT">&zeta;<sub>s</sub></a> reaching 1 (true step function)
is numerically forbidden.</li>
</ol>
Note that the additional parameters for the second functional form are not independent and that 
the coarse shape of the function is preserved, especially if <a href="keywords.html#SCRGRANULE">SCRGRANULE</a>
is small (left near the default).<br/>
<h4><a class="NoHi" id="SCRTAU"><b>SCRTAU</b></a></h4>
This is the specification analogous to <a href="keywords.html#FOSTAU">FOSTAU</a>
for the charge screening solvation state and provides &tau;<sub>s</sub> rather than &tau;<sub>f</sub>.<br/>
<h4><a class="NoHi" id="SCRMID"><b>SCRMID</b></a></h4>
This is the specification analogous to <a href="keywords.html#FOSMID">FOSMID</a>
for the charge screening solvation state and provides χ<sub>s</sub> rather than χ<sub>f</sub>.<br/>
<h4><a class="NoHi" id="SCRGRANULE"><b>SCRGRANULE</b></a></h4>
This is the specification analogous to <a href="keywords.html#FOSGRANULE">FOSGRANULE</a>
for the charge screening solvation state and provides <i>g</i><sub>s</sub> rather than <i>g</i><sub>f</sub>.<br/>
<h4><a class="NoHi" id="SCRTIGHT"><b>SCRTIGHT</b></a></h4>
This is the specification analogous to <a href="keywords.html#FOSTIGHT">FOSTIGHT</a>
for the charge screening solvation state and provides &zeta;<sub>s</sub> rather than &zeta;<sub>f</sub>.<br/>
<h4><a class="NoHi" id="SCRSHIFT"><b>SCRSHIFT</b></a></h4>
This is the specification analogous to <a href="keywords.html#FOSSHIFT">FOSSHIFT</a>
for the charge screening solvation state.<br/>
<h4><a class="NoHi" id="SCRMIX"><b>SCRMIX</b></a></h4>
Several of the screening models (choice of 3, 7, 8, or 9 for <a
 href="keywords.html#SCRMODEL">SCRMODEL</a>)
splice a distance-dependent term into the environmental
charge-screening over a well-defined length scale. The impact of this
contribution is set by this keyword
which corresponds to the parameter f<sub>MIX</sub> in the <a
 href="keywords.html#SCRMODEL">equations</a> above.
If set to values close to zero, the model approaches its unmodified
base model, <i>e.g.</i> model 3 essentially converges to
model 1. Conversely, a value close to 1.0 would yield maximum impact
and let - for example - model 3 approximate model 4 for distances close
to the contact distance r<sub>0,ij</sub>. The choice here is naturally
tightly coupled to that for <a href="keywords.html#CONTACTDIEL">CONTACTDIEL</a>.<br/>
<h4><a class="NoHi" id="ISQM"><b>ISQM</b></a></h4>
In those screening models postulating an effective dielectric rather
than effective charges, the generalized
mean function M(x,y) was introduced (see <a
 href="keywords.html#SCRMODEL">equations</a> above).
This can be an integer from -10 to 10, but large absolute values slow
down the
computation drastically and are not recommended. The
specification here defines the order m for the generalized mean:<br/>
<br/>
M(x,y) = [0.5·( x<sup>m</sup> + y<sup>m</sup> ) ]<sup>1/m</sup> if m ≠ 0<br/>
<br/>
With the limiting case of:<br/>
<br/>
M(x,y) = (x·y)<sup>1/2</sup> if m = 0<br/>
<br/>
Common cases aside from the geometric (m=0) are the arithmetic
(m=1) or the harmonic (m=-1) mean. Any m&gt;1 will favor large values
in an asymmetric pair, <i>i.e.</i>, let both participating atoms
appear desolvated leading to stronger interactions, while
any m&lt;1 will favor small values in an asymmetric pair, <i>i.e.</i>,
let both participating atoms appear solvated and weaken such
interactions (it is the derived screening factors and not the solvation states that
enter the mean). The former scenario (m&gt;1) would rarely seem desirable as it means
that - for instance in solutions of small, polar molecules - the cooperativity
for converting between fully dissociated and fully associated states becomes
overly pronounced on account of the positive coupling between adding more and
more species to a growing cluster and the enthalpic benefit offered by that process.<br/>
<!--
&nbsp;&nbsp;&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img style="width: 253px; height: 20px;"
 alt="mean(si,sj,m) = [0.5*( si^m + sj^m )]^(1./m)"
 src="website_equations/keywords_ISGM.gif"><br/>
With the limiting case of:<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img style="width: 179px; height: 18px;"
 alt="mean(si,sj,0) = sqrt(si*sj)"
 src="website_equations/keywords_ISQM2.gif"><br/>
-->
<h4><a class="NoHi" id="SC_TOR"><b>SC_TOR</b></a></h4>
This keyword specifies the linear scaling factor controlling the
"outside"
scaling of torsional bias terms, V<sub>TOR</sub>. Such a potential
allows to either
harmonically restrain virtually all freely rotatable dihedral angles to
specific target
values or to softly bias them toward such target values. The setup for
these is handled through an input
file (details of the format are described <a href="inputfiles.html#FMCSC_TORFILE">elsewhere</a>). Note
that a particularly useful application of E<sub>TOR</sub> is to apply
torsional restraints
according to structural input which is useful for equilibrating molecules
meant to remain in a specific, internal arrangement.<br/>
<h4><a class="NoHi" id="TORFILE"><b>TORFILE</b></a></h4>
This keyword specifies the location and name (absolute paths
preferable) of the input file for individual backbone <a href="keywords.html#SC_TOR">torsional bias potentials</a>, V<sub>TOR</sub>
(see <a href="inputfiles.html#FMCSC_TORFILE">elsewhere</a> for
description).<br/>
<h4><a class="NoHi" id="TORREPORT"><b>TORREPORT</b></a></h4>
This is a simple logical allowing the user to instruct CAMPARI to write
out a complete summary of
the torsional bias terms contributing to V<sub>TOR</sub> (naturally
parsed by residue) in the system. In addition to the annotated log-output, this
will also create the output file <a href="outputfiles.html#SAMPLE_TORFILE.dat">SAMPLE_TORFILE.dat</a>,
which is a rewriting of the current input specifications to a fully explicit and
residue-based version. This is useful primarily in preserving input to the definition of 
torsional bias potentials that comes from <a href="keywords.html#PDBFILE">structural input</a>.
It is recommended to utilize this option.<br/>
<h4><a class="NoHi" id="SC_ZSEC"><b>SC_ZSEC</b></a></h4>
This keyword gives the linear scaling factor for a global secondary
structure bias
term. For values larger than zero, a harmonic bias is applied on two
order
parameters, f<sub>α</sub> and f<sub>β</sub> which measure the secondary
structure content of the chain. f<sub>α</sub> and f<sub>β</sub> are
calculated as the
sequence-averaged (excluded termini)
values of a mapping function defined for each residue:<br/>
z<sub>α</sub> = e<sup>-τ<sub>α</sub>·(d<sub>α</sub>-r<sub>α</sub>)<sup>2</sup></sup>
if d<sub>α</sub> &lt; r<sub>α</sub><br/>
z<sub>α</sub> = 1.0 else <br/>
The radius of the (spherical) α-region, r<sub>α</sub>, is provided by <a
 href="keywords.html#ZS_RAD_A">ZS_RAD_A</a> and its center φ/ψ-position
by keyword <a href="keywords.html#ZS_POS_A">ZS_POS_A</a>. The distance
d<sub>α</sub> is taken from the center of the circle and
corrected for periodic wraparounds in φ/ψ-space. z<sub>β</sub> is
defined analogously. This function represents a smooth "top
hat" function which is continuous and differentiable. By tuning the
parameter τ<sub>α</sub> through keywords <a
 href="keywords.html#ZS_STP_A">ZS_STP_A</a> and <a
 href="keywords.html#ZS_STP_B">ZS_STP_B</a>, the Gaussian decay beyond
the limits of the spherical plateau region can be turned from very
shallow to step function-like.
The default definitions (all of which can be overridden) are:<br/>
<b>α</b><br/>
Center: φ/ψ=(-60.0,-50.0)°; r<sub>α</sub> = 35.0°; 1.0/τ<sub>α</sub><sup>1/2</sup>
≅22.36°<br/>
<b>β</b><br/>
Center: φ/ψ=(-155.0,160.0)°; r<sub>β</sub> = 35.0°; 1.0/τ<sub>β</sub><sup>1/2</sup>
≅ 22.36°<br/>
<br/>
The global values (if there are multiple polypeptide chains in the
system, the average is over all of them) are then restrained:<br/>
<br/>
V<sub>ZSEC</sub> = c<sub>ZSEC</sub>·(k<sub>α</sub>·(f<sub>α</sub> - f<sub>α</sub><sup>0</sup>)<sup>2</sup>
+ k<sub>β</sub>·(f<sub>β</sub> - f<sub>β</sub><sup>0</sup>)<sup>2</sup>)<br/>
<br/>
Here, c<sub>ZSEC</sub> is the linear scaling factor specified by this
keyword. The other parameters are explained below.
Note that it may not be a good idea to use such a residue-based
restraint potential for very short
sequences. Here, the net content idea breaks down and (for typical
choices of τ<sub>α/β</sub>) the chain will have access only to
values in the vicinity of those given by a discrete residue content.
This may lead to a specific sampling of the ring regions around the
plateaus
to satisfy intermediate target values which runs counterintuitive to
the intent of the potential.<br/>
When CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
the calculation of V<sub>ZSEC</sub> is currently executed by a single thread,
possibly in concurrence with another thread addressing the <a href="keywords.html#SC_DSSP">complementary DSSP term</a> but not
with anything else. This is a scaling limitation, and a corresponding warning is produced.<br/>
<h4><a class="NoHi" id="ZS_FR_A"><b>ZS_FR_A</b></a></h4>
This keyword specifies the target α-content for the <a href="keywords.html#SC_ZSEC">global secondary
structure bias</a> (f<sub>α</sub><sup>0</sup>)
potential (values [0.0:1.0]).<br/>
<h4><a class="NoHi" id="ZS_FR_B"><b>ZS_FR_B</b></a></h4>
This keyword specifies the target β-content for the <a href="keywords.html#SC_ZSEC">global secondary
structure bias</a> (f<sub>β</sub><sup>0</sup>)
potential (values [0.0:1.0]). Note that the sum of f<sub>β</sub><sup>0</sup>
and f<sub>α</sub><sup>0</sup> (see <a href="keywords.html#ZS_FR_B">ZS_FR_B</a>)
should usually not exceed unity, especially in conjunction with stiff
spring constants.
Doing so would generate a frustrated system for which results will
often be irrelevant.<br/>
<h4><a class="NoHi" id="ZS_FR_KA"><b>ZS_FR_KA</b></a></h4>
Through this keyword, (twice) the spring constant (in kcal/mol)
operating on f<sub>α</sub> is provided (k<sub>α</sub>) if the <a href="keywords.html#SC_ZSEC">global secondary
structure bias potential</a> is in use.<br/>
<h4><a class="NoHi" id="ZS_FR_KB"><b>ZS_FR_KB</b></a></h4>
Analogous to <a href="keywords.html#ZS_FR_KA">ZS_FR_KA</a>, this
keyword lets the user specify the spring constant (in kcal/mol)
operating
on f<sub>β</sub> (k<sub>β</sub>) if the <a href="keywords.html#SC_ZSEC">global secondary
structure bias potential</a> is in use. If both parameters are meant to be
restrained, it usually would not seem
meaningful to choose very different values for the two spring
constants. In doing so, one would essentially create
a primary bias (stiffer term) and a secondary bias (softer term)
operating "within" the primary restraint.<br/>
<h4><a class="NoHi" id="ZS_POS_A"><b>ZS_POS_A</b></a></h4>
This is one of the few keywords that requires <b>two</b> floating
point numbers as input.
It allows the user to override the default location of the α-basin (see
<a href="keywords.html#SC_ZSEC">SC_ZSEC</a>).
The two numbers are interpreted to be the φ- and ψ-values (in degrees)
for the center of the (spherical) basin. The setting is relevant for the <a href="keywords.html#SC_ZSEC">corresponding restraint potential</a>
and the output in <a href="outputfiles.html#ZSEC_HIST.dat">ZSEC_HIST.dat</a>, 
<a href="outputfiles.html#ZAB_2DHIST.dat">ZAB_2DHIST.dat</a>, and <a href="outputfiles.html#ZBETA_RG.dat">ZBETA_RG.dat</a>.<br/>
<h4><a class="NoHi" id="ZS_POS_B"><b>ZS_POS_B</b></a></h4>
See <a href="keywords.html#ZS_POS_A">ZS_POS_A</a>, only for the
β-basin.<br/>
<h4><a class="NoHi" id="ZS_RAD_A"><b>ZS_RAD_A</b></a></h4>
This keyword requires one floating point number to be specified. It
allows overriding the default
radius of the α-basin (see <a href="keywords.html#SC_ZSEC">SC_ZSEC</a>)
and is assumed to be
given in degrees. The setting is relevant for the <a href="keywords.html#SC_ZSEC">corresponding restraint potential</a>
and the output in <a href="outputfiles.html#ZSEC_HIST.dat">ZSEC_HIST.dat</a>, 
<a href="outputfiles.html#ZAB_2DHIST.dat">ZAB_2DHIST.dat</a>, and <a href="outputfiles.html#ZBETA_RG.dat">ZBETA_RG.dat</a>.<br/>
<h4><a class="NoHi" id="ZS_RAD_B"><b>ZS_RAD_B</b></a></h4>
See <a href="keywords.html#ZS_RAD_A">ZS_RAD_A</a>, only for the
β-basin.<br/>
<h4><a class="NoHi" id="ZS_STP_A"><b>ZS_STP_A</b></a></h4>
This keyword requires one floating point number. It allows overriding
the default
steepness of the decay (τ<sub>α</sub>) of the order parameter value
beyond the spherical plateau region defining
the α-basin (see <a href="keywords.html#SC_ZSEC">SC_ZSEC</a>). It is
assumed to be provided
in inverse degrees squared. The setting is relevant for the <a href="keywords.html#SC_ZSEC">corresponding restraint potential</a>
and the output in <a href="outputfiles.html#ZSEC_HIST.dat">ZSEC_HIST.dat</a>, 
<a href="outputfiles.html#ZAB_2DHIST.dat">ZAB_2DHIST.dat</a>, and <a href="outputfiles.html#ZBETA_RG.dat">ZBETA_RG.dat</a>.<br/>
<h4><a class="NoHi" id="ZS_STP_B"><b>ZS_STP_B</b></a></h4>
See <a href="keywords.html#ZS_STP_A">ZS_STP_A</a>, only for the
β-basin.<br/>
<h4><a class="NoHi" id="SC_DSSP"><b>SC_DSSP</b></a></h4>
This keyword provides the outside scaling factor, c<sub>DSSP</sub>, on
biasing potential acting on order parameters derived from the secondary
structure
annotation of polypeptides in the simulation system using the <a href="references.html#ref20_1">DSSP alogrithm</a>.
In essence, this allows to bias the system to
populate more
and stronger hydrogen bonds characteristic for either α-helices (H) or
β-sheets - whether parallel, antiparallel, multi-pleated or hairpins
(E). Since secondary
structure annotation is essentially a discretized and on/off variable,
it may seem surprising
that a restraint potential can be applied in meaningful fashion.<br/>
<br/>
V<sub>DSSP</sub> = c<sub>DSSP</sub>·(k<sub>H</sub>·(f<sub>H</sub> - f<sub>H</sub><sup>0</sup>)<sup>2</sup>
+ k<sub>E</sub>·(f<sub>E</sub> - f<sub>E</sub><sup>0</sup>)<sup>2</sup>)<br/>
<br/>
Here, the k<sub>H</sub> and k<sub>E</sub> are (twice) the spring
constants for the harmonic restraints applied to the secondary
structure
scores, f<sub>H</sub> and f<sub>E</sub>. The spring constants are set
by keywords <a href="keywords.html#DSSP_HSC_K">DSSP_HSC_K</a> and <a
 href="keywords.html#DSSP_ESC_K">DSSP_ESC_K</a> for H-score and
E-score, respectively. f<sub>H</sub> and f<sub>E</sub> are exactly
identical to the H-score and E-score defined below and rely on the same
base parameters (→ <a href="keywords.html#DSSP_MODE">DSSP_MODE</a>).
Essentially, they correspond to a multiplicative function of the
assignment and the quality of the hydrogen bonds giving rise to the
assignment. They can - depending on system and DSSP settings - be
continuous and approximately smooth order parameters over a large
part of the accessible regime. The target values f<sub>H</sub><sup>0</sup>
and f<sub>E</sub><sup>0</sup> are set via keywords
<a href="keywords.html#DSSP_HSC">DSSP_HSC</a> and <a
 href="keywords.html#DSSP_ESC">DSSP_ESC</a>.
There are a few noteworthy peculiarities which the user should keep in
mind:
<ol>
  <li>DSSP E-assignments can rely both on intra- and intermolecular
hydrogen bonds rendering the DSSP term a true system-wide potential.
Currently,
CAMPARI only allows restraining global E- and H-scores which may make
calculations with multiple polypeptides more difficult to interpret.</li>
  <li>In the limit of no hydrogen bonds, the order parameters will
always be discontinuous since the discrete assignment score has to be
non-zero
for the quality score to matter.</li>
  <li>Due to the potential discontinuities, dynamics calculations
utilizing the DSSP biasing potential may suffer from substantial noise,
in
particular for stiff restraints and small systems.</li>
  <li>Again, due to the functional form, there is no direct driving
force to form new hydrogen bonds of the right type. The potential
relies
on random encounters and the cooperativity of secondary structure
elements.</li>
  <li>Lastly, in case some proper hydrogen bonds are formed, the
resultant energy landscape is often very rugged and sampling may be
severely hampered by the presence of the restraints. It is therefore
advisable - at the very least - to perform multiple independent
simulations when using DSSP restraints.
  </li>
</ol>
As mentioned above, the parameters determining criteria for hydrogen
bonds are explained further below
(see <a href="keywords.html#DSSP_MODE">DSSP_MODE</a>). It is easy to
see that these types of restraints
complement the ones introduced above (→ <a href="keywords.html#SC_ZSEC">SC_ZSEC</a>).<br/>
When CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
the DSSP restraint potential is currently calculated by a single thread,
possibly in concurrence with another thread addressing the <a href="keywords.html#SC_ZSEC">complementary ZSEC term</a> but not
with anything else. This is a scaling limitation, and a corresponding warning is produced.<br/>
<h4><a class="NoHi" id="DSSP_HSC"><b>DSSP_HSC</b></a></h4>
In case DSSP restraints are used (→ <a href="keywords.html#SC_DSSP">SC_DSSP</a>),
this keyword allows
the user to set the target H-score (α-content, f<sub>H</sub><sup>0</sup>
above). Its value is limited
to the interval from zero to unity. A large value will steer the system
toward forming
many i→i+4 hydrogen bonds.
<h4><a class="NoHi" id="DSSP_ESC"><b>DSSP_ESC</b></a></h4>
In case DSSP restraints are used (→ <a href="keywords.html#SC_DSSP">SC_DSSP</a>),
this keyword lets the user set the target E-score (β-content, f<sub>E</sub><sup>0</sup>
above).
Just like for <a href="keywords.html#DSSP_HSC">DSSP_HSC</a>, values
are restricted to the interval [0.0:1.0].
A large value will bias the system toward forming characteristic
β-hydrogen bonds but does not
distinguish between parallel or anti-parallel arrangements.
Note that the sum of <a href="keywords.html#DSSP_HSC">DSSP_HSC</a> and
<a href="keywords.html#DSSP_ESC">DSSP_ESC</a> should probably
never approach unity. Also note that the E-score can never be exactly
unity for a monomeric, finite length polypeptide even when discarding
termini (turn requirement).<br/>
<h4><a class="NoHi" id="DSSP_HSC_K"><b>DSSP_HSC_K</b></a></h4>
If DSSP restraints are in use (→ <a href="keywords.html#SC_DSSP">SC_DSSP</a>),
this keywords sets (twice) the spring constant (in kcal/mol) operating
on the DSSP H-score, <i>i.e.</i>,
it sets the value of k<sub>H</sub> above.
<h4><a class="NoHi" id="DSSP_ESC_K"><b>DSSP_ESC_K</b></a></h4>
If DSSP restraints are in use (→ <a href="keywords.html#SC_DSSP">SC_DSSP</a>),
this keywords sets (twice) the spring constant (in kcal/mol) operating
on the DSSP E-score, <i>i.e.</i>,
it sets the value of k<sub>E</sub> above.
<h4><a class="NoHi" id="SC_POLY"><b>SC_POLY</b></a></h4>
In studies of generic polymers coarse descriptors like size and shape
of the macromolecule may be more relevant than structural characteristics tailored specifically to
polypeptides. CAMPARI supports restraint potentials on such coarse descriptors, specifically the
parameters t and δ (see <a href="outputfiles.html#POLYAVG.dat">description of output file POLYAVG.dat</a>) which measure
size and shape asymmetry, respectively. Two-dimensional histograms of these quantities
can be computed and written by CAMPARI (see output file <a href="outputfiles.html#RDHIST.dat">RDHIST.dat</a>).
These molecule-based restraint potentials yield a bias term to the total potential energy, V<sub>POLY</sub>,
and this keyword provides its "outside" scaling factor c<sub>POLY</sub>. Note
that with the exception of the scaling factor, requests are generally handled through a
dedicated input file (see <a href="inputfiles.html#FMCSC_POLYFILE">elsewhere for details</a>).
As mentioned above, when CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
all threads contribute to calculating V<sub>POLY</sub> synchronously.<br/>
<h4><a class="NoHi" id="POLYFILE"><b>POLYFILE</b></a></h4>
This keyword should point to the location of the input file for
individual molecular <a href="keywords.html#SC_POLY">polymeric biasing potentials</a> (→ <a href="inputfiles.html#FMCSC_POLYFILE">elsewhere</a>
for description).<br/>
<h4><a class="NoHi" id="POLYREPORT"><b>POLYREPORT</b></a></h4>
Like other report flags, this keyword is a simple logical which allows
the user to obtain a complete summary of the polymeric bias terms (by molecule) in
the system. It is only meaningful if polymeric biasing terms are in use (→ <a href="keywords.html#SC_POLY">SC_POLY</a>).<br/>
<h4><a class="NoHi" id="SC_TABUL"><b>SC_TABUL</b></a></h4>
CAMPARI has an extensive facility to supply tabulated non-bonded
potentials which are then applied to the system. This keyword specifies
the "outside"
linear scaling factor c<sub>TABUL</sub> according to:<br/>
<br/>
E<sub>TABUL</sub> = c<sub>TABUL</sub> ·ΣΣ<sub>i,j</sub> I(V<sub>ij</sub><sup>k</sup>,V<sub>ij</sub><sup>k+1</sup>,m<sub>ij</sub><sup>k</sup>,m<sub>ij</sub><sup>k+1</sup>,d<sub>ij</sub>)<br/>
<br/>
Here, the sum runs over all atom pairs i,j which have a tabulated
potential specified for them, V<sub>ij</sub><sup>k</sup> is the
k<sup>th</sup> tabulated value of the acting potential and d<sub>ij</sub>
is the interatomic distance. d<sub>ij</sub> is located
uniquely within the interval given by the k<sup>th</sup> and k+1<sup>th</sup>
tabulated value. I(...) is the interpolation function, and CAMPARI currently performs
only cubic interpolation with cubic Hermite splines:<br/>
<br/>
I(V<sub>ij</sub><sup>k</sup>,V<sub>ij</sub><sup>k+1</sup>,m<sub>ij</sub><sup>k</sup>,m<sub>ij</sub><sup>k+1</sup>,d<sub>ij</sub>) = 
(2t<sup>3</sup> - 3t<sup>2</sup> + 1)·V<sub>ij</sub><sup>k</sup> + (3t<sup>2</sup> - 2t<sup>3</sup>)·V<sub>ij</sub><sup>k+1</sup> +
(d<sub>k+1</sub>-d<sub>k</sub>)·[(t<sup>3</sup> - 2t<sup>2</sup> + t)·m<sub>ij</sub><sup>k</sup> + (t<sup>3</sup> - t<sup>2</sup>)·m<sub>ij</sub><sup>k+1</sup>] <br/>
t = (d<sub>ij</sub> - d<sub>k</sub>)/(d<sub>k+1</sub>-d<sub>k</sub>)<br/>
<br/>
Here, t is the relative position in the interval from k to k+1 normalized to unit length. The m<sub>ij</sub><sup>k</sup> are the 
tangents to (slopes at) the control points (tabulated values) of the potentials. The spline is set up
to recover both values and tangents at the control points. This means that the resultant function is continuously 
differentiable regardless of the values used for the tangents. Tangents are either read from file
(without error checks &rarr; <a href="inputfiles.html#FMCSC_TABTANGFILE">description of dedicated input file</a>) or 
estimated numerically via finite differences from the potential input
(see <a href="inputfiles.html#FMCSC_TABPOTFILE">description of dedicated input file</a>). In the latter case,
some options are available to tune the spline (see <a href="keywords.html#TABIBIAS">TABIBIAS</a>
and <a href="keywords.html#TABITIGHT">TABITIGHT</a>).<br/>
There are a few additional characteristics of the implementation of tabulated
potentials in CAMPARI:<br/>
<ol>
  <li>Aside from <a href="keywords.html#SC_POLAR">Coulombic terms</a>,
these potentials are the only ones
captured by the longer of the non-bonded cutoffs in MC runs (→ <a
 href="keywords.html#ELCUTOFF">ELCUTOFF</a>).</li>
  <li>When used concurrently with other non-bonded potentials, a lot of
wasteful distance calculation may be performed.
This is since tabulated potentials have to use their own data structure
to be able to function efficiently both for
cases with universal use and for very sparse use.</li>
  <li>Atom pairs that are in close proximity and are excluded from all
other non-bonded potentials are <i>not</i> excluded from tabulated
potentials.</li>
</ol>
All further implementation details are provided in the description of
the corresponding input files
(<a href="inputfiles.html#FMCSC_TABCODEFILE">index input</a>, <a
 href="inputfiles.html#FMCSC_TABPOTFILE">potential input</a>, and optional
<a href="inputfiles.html#FMCSC_TABTANGFILE">tangent input</a>).
As an example for the utility of this facility, consider
knowledge-based (effective) potentials acting
on solutes in an implicit solvent. The potentials themselves may have
been derived from binned distance
distributions and are practically defined in the form of tabulated
potentials. The possibilities are such
that - in theory - each individual atom pair could interact via its own
unique potential.<br/>
<h4><a class="NoHi" id="TABCODEFILE"><b>TABCODEFILE</b></a></h4>
This keyword provides the index input file which determines which
tabulated potential to use for which atom pair (see <a href="inputfiles.html#FMCSC_TABCODEFILE">elsewhere for format description</a>).
Naturally, this is only relevant if the <a href="keywords.html#SC_TABUL">tabulated potential is in use</a>.<br/>
<h4><a class="NoHi" id="TABPOTFILE"><b>TABPOTFILE</b></a></h4>
This keyword should give the name and location of the actual input file
for the tabulated potentials (see <a href="inputfiles.html#FMCSC_TABPOTFILE">elsewhere for format description</a>).
Naturally, this is only relevant if the <a href="keywords.html#SC_TABUL">tabulated potential is in use</a>.<br/>
<h4><a class="NoHi" id="TABTANGFILE"><b>TABTANGFILE</b></a></h4>
This keyword should give the name and location of the optional input file
for providing derivatives of the tabulated potentials specified via <a href="keywords.html#TABPOTFILE">another keyword</a>.
If this file is not provided, the derivatives are estimated numerically to generate
the necessary tangents for the cubic interpolation scheme. If the file <i>is</i> provided, however,
no checks are performed on the supplied values (see <a href="inputfiles.html#FMCSC_TABTANGFILE">elsewhere for format description</a>).
Naturally, this is only relevant if the <a href="keywords.html#SC_TABUL">tabulated potential is in use</a>.<br/>
<h4><a class="NoHi" id="TABITIGHT"><b>TABITIGHT</b></a></h4>
If <a href="keywords.html#SC_TABUL">tabulated potentials</a> are in use, and if the <a href="inputfiles.html#FMCSC_TABTANGFILE">
input file providing derivatives of the potentials</a> is either missing or incomplete, the cubic interpolation scheme
applied to the discrete input data (using cubic Hermite splines) utilizes numerical estimates of the tangents
(slopes) at the nodes (control points). The shape and nature
of the resulting spline can be varied somewhat with two control parameters, the first controlling the "tightness",
 and the second (see <a href="keywords.html#TABIBIAS">below</a>) controlling a left/right-sided bias with respect to
the control points. The control parameters are used in the construction of the tangents as follows:<br/>
<br/>
m<sub>ij</sub><sup>k</sup> = [ (1-t<sub>t</sub>)·(1+t<sub>b</sub>)·(V<sub>ij</sub><sup>k</sup> - V<sub>ij</sub><sup>k-1</sup>) + (1-t<sub>t</sub>)·(1-t<sub>b</sub>)·(V<sub>ij</sub><sup>k+1</sup> - V<sub>ij</sub><sup>k</sup>) ] / (d<sub>k+1</sub> - d<sub>k-1</sub>)<br/>
<br/>
This is essentially a simplified Kochanek-Bartels spline scheme skipping the discontinuity parameter and assuming 
identical distance spacings. The V<sub>j</sub> are the potential values at the specified distances, d<sub>k</sub>, supplied
via <a href="inputfiles.html#FMCSC_TABPOTFILE">the required input file</a>. t<sub>t</sub> is the tightness parameter controlled
by this keyword, and t<sub>b</sub> is the bias parameter controlled by <a href="keywords.html#TABIBIAS">TABIBIAS</a>.
For both parameters being zero, the well-known Catmull-Rom spline is obtained. Regardless of the choices for t<sub>t</sub> and
t<sub>b</sub> (allowed values span the interval from -1 to 1), the resultant interpolation scheme will yield a
function that is continuous and smooth (<i>i.e.</i>, continuously differentiable). However, unless the control points
are very sparse with respect to the features of the potentials, any non-zero settings for t<sub>t</sub> and/or t<sub>b</sub>
will most likely lead to undesirable effects, in particular at the level of derivatives.<br/>
<h4><a class="NoHi" id="TABIBIAS"><b>TABIBIAS</b></a></h4>
If <a href="keywords.html#SC_TABUL">tabulated potentials</a> are in use, and if the <a href="inputfiles.html#FMCSC_TABTANGFILE">
input file providing derivatives of the potentials</a> is either missing or incomplete, the cubic interpolation scheme
applied to the discrete input data (using cubic Hermite splines) utilizes numerical estimates of the tangents
(slopes) at the nodes (control points). The shape of the resulting spline utilizes a bias parameter, t<sub>b</sub>, that is
specified by this keyword. Its exact interpretation is explained <a href="keywords.html#TABITIGHT">above</a>. Simply speaking,
positive values lead to a lag (along the distance axis) in the interpolated, piecewise polynomial compared to the control
points, whereas negative values do the opposite.<br/>
<h4><a class="NoHi" id="TABREPORT"><b>TABREPORT</b></a></h4>
If tabulated potentials are in use (see <a href="keywords.html#SC_TABUL">SC_TABUL</a>), this keyword
lets the user instruct CAMPARI to print out a report of all the
tabulated interactions in the system.
This output can be quite large and is written to a separate output file
(see <a href="outputfiles.html#TABULATED_POT.idx">TABULATED_POT.idx</a>).<br/>
<h4><a class="NoHi" id="SC_DREST"><b>SC_DREST</b></a></h4>
This keyword controls the "outside" scaling factor for quadratic potentials acting on either
interatomic distances between any pair of selected atoms or on absolute coordinates
of individual atoms. Such requests are handled and processed through a dedicated input file
(see <a href="inputfiles.html#FMCSC_DRESTFILE">FMCSC_DRESTFILE</a>). Details regarding functional
forms and available choices and parameters are in the input file documentation. 
SC_DREST simply controls the "outside" scaling factor c<sub>DREST</sub> for the individual V<sub>DREST</sub> terms,
<i>i.e.</i>, E<sub>DREST</sub> = c<sub>DREST</sub>&#183;&Sigma;<sub>m</sub>V<sub>DREST</sub>(m). A summary
of the requested terms can be obtained with keyword <a href="keywords.html#DRESTREPORT">DRESTREPORT</a>.<br/>
One prominent role of using such restraints would be to allow a restrained
relaxation of parts of a system (<i>e.g.</i>, it is common to restrain protein atoms and 
relax water molecules in the presence of these restraints before starting a simulation of a protein
in a crystallographic conformation in explicit solvent). The second and more important
role lies in the fact that several experimental techniques (in particular NMR or FRET) can derive
distance restraints on the relative position of two sites in a
biomolecule. Hence, computational techniques are able to utilize this experimental information as restraints
(prominent for example in the computational determination of protein structures via NMR). CAMPARI
offers the simple facility to harmonically restrain atoms which
otherwise need not have any particular relationship.
These restraints can be made one-sided, <i>i.e.</i> they can also restrain a distance
to simply be within or beyond a certain threshold, which is usually a more appropriate treatment
for incorporating experimental results.<br/>
As mentioned above, when CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
all threads contribute to calculating E<sub>DREST</sub> synchronously. Note that there
is no incremental treatment of this term in <a href="keywords.html#DYNAMICS">Monte Carlo</a> calculations,
which is a limitation.<br/>
<h4><a class="NoHi" id="DRESTFILE"><b>DRESTFILE</b></a></h4>
This keyword should give the location and name of the input file
containing specific requests for specific interatomic distance and/or
specific atom position restraints (see <a href="inputfiles.html#FMCSC_DRESTFILE">elsewhere for format description</a>).
Naturally, this is only relevant if <a href="keywords.html#SC_DREST">custom distance/position restraints are in use</a>.<br/>
<h4><a class="NoHi" id="DRESTREPORT"><b>DRESTREPORT</b></a></h4>
If distance or absolute position restraint potentials are in use (see <a  href="keywords.html#SC_DREST">SC_DREST</a>),
this keyword allows the user to request a summary of the active restraint terms in the system.<br/>
<h4><a class="NoHi" id="SC_OSMO"><b>SC_OSMO</b></a></h4>
This keyword controls the outside scaling factor of a simple bias potential that allows
the separation of the <a href="keywords.html#SHAPE">simulation container</a> (irrespective of shape) into
two or more compartments and to apply a compartment-specific restraint potential to 
specific residues in the system. In essence, this creates a set of soft, semi- or impermeable 
membranes.<br/>
Specifically, keyword <a href="keywords.html#OSMO_MODE">OSMO_MODE</a> selects the number
of planar boundaries to be introduced. Each boundary is parallel to one of the cardinal axes
of the system and passes through the simulation container's geometric center.
The first boundary to be added is that orthogonal to the z-axis (xy-plane) followed by the
xz- and yz-planes.
Once an assignment of residues to compartments has been made (via a mandatory input
file &rarr; <a href="keywords.html#OSMOFILE">OSMOFILE</a>), the boundaries required to define the compartment
exert a restoring force if atoms in a residue assigned to it tries to leave the compartment:<br/>
<br/>
V<sub>OSMO</sub> = c<sub>OSMO</sub>k<sub>BND</sub>&#183;d<sub>i,BND</sub><br/>
<br/>
Here, c<sub>OSMO</sub> is the outside scaling factor defined by SC_OSMO, k<sub>BND</sub>
is the rigidity of the compartmental membrane (controlled by <a href="keywords.html#SOFTWALL">SOFTWALL</a>),
and d<sub>i,BND</sub> is a shorthand notation for the effective distance of atom <i>i</i> from the boundary,
which is always 0.0 inside the compartment. This treatment is exactly the same as 
that for an <a href="keywords.html#BOUNDARY">atom-based soft-wall boundary condition</a>.
Note that in finite systems with external boundaries, the relative strengths of inner 
compartment and external boundaries can be made different by choosing a value for SC_OSMO
different from 1.0. The compartmental boundaries that do not coincide with an external
boundary are a little more tricky to understand in periodic systems. For example, in a 3D periodic  
box with a single inner boundary in the yz-plane passing through the origin, an additional
boundary is required at the xy-border of the box to avoid connecting the compartments via
periodic images. This boundary is felt differently by particles assigned to different
compartments. Periodic dimensions that are not parallel to an added inner boundary 
are not (and must not be) corrected in the same way.<br/>
With the help of keyword <a href="keywords.html#OSMOREPORT">OSMOREPORT</a>, CAMPARI will report the expected bulk densities
per compartment. Because the boundaries are soft they respond to the internal pressure of each compartment.
Thus, choosing compartments with dramatically different internal pressures will tend to change the effective
volumes and densities per partition. In general, it is of course difficult to assert how meaningful
a compartmentalization of this type can be if the compartments contain non-mixing phases (<i>e.g.</i>
an hydrophobic gas <i>vs</i> liquid water or two immiscible liquids). In many cases, results
from such a simulation will not be straightforwardly interpretable.<br/>
<h4><a class="NoHi" id="OSMO_MODE"><b>OSMO_MODE</b></a></h4>
If compartmentalization potentials are in use (see <a  href="keywords.html#SC_OSMO">SC_OSMO</a>),
this keyword specifies the number and type of inner compartment boundaries to be added.
Currently, the available options are:<br/>
<ol>
<li>A single planar boundary is added in the xy-plane and passing through the origin of the system (split in z).
This creates exactly <b>2</b> compartments.</li>
<li>Two planar boundaries are added: one in the xy-plane and one in the xz-plane, and both passing through the
origin of the system (split in y and z). This creates exactly <b>4</b> compartments.</li>
<li>Three planar boundaries are added: one in the xy-plane, one in the xz-plane, and one in the yz-plane, and all are
passing through the origin of the system (split in x, y and z). This creates exactly <b>8</b> compartments.</li>
</ol>
There are currently no options to induce multiple splits in a single cardinal direction, to
have planes that are not orthogonal to a cardinal direction, or to change the relative sizes of 
the partitions. The added boundaries are the same irrespective of the
<a href="keywords.html#SHAPE">shape of the simulation container</a>. Note that the
compartmentalization potential is observed during initial
<a href="keywords.html#RANDOMIZE">structure randomization</a>.<br/>
<h4><a class="NoHi" id="OSMOFILE"><b>OSMOFILE</b></a></h4>
If compartmentalization potentials are in use (see <a  href="keywords.html#SC_OSMO">SC_OSMO</a>),
this keyword should give the location and name of the input file
containing the assignment of residues to individual compartments. Different input modes
exist (by residue, by molecule, or by molecule type). This is a mandatory input file for this
bias potential. The user is referred <a href="inputfiles.html#FMCSC_OSMOFILE">elsewhere</a> for a
detailed description of the input format. The details of the assignment can be printed to
log-output by means of keyword <a href="keywords.html#OSMOREPORT">OSMOREPORT</a>.<br/>
<h4><a class="NoHi" id="OSMOREPORT"><b>OSMOREPORT</b></a></h4>
If compartmentalization potentials are in use (see <a  href="keywords.html#SC_OSMO">SC_OSMO</a>),
this keyword allows the user to request a summary of the assignment of
all residues in the system to compartments. The report will also list the
formal bulk densities for the individual compartments.<br/>
<h4><a class="NoHi" id="SC_EMICRO"><b>SC_EMICRO</b></a></h4>
This keyword sets the global scaling factor for a spatial density restraint potential.
The method was introduced recently (<a href="references.html#ref2_16">Vitalis and Caflisch</a>), and the
user is referred there for additional details.
The potential relies on reading and quantitatively interpreting an <a href="keywords.html#EMMAPFILE">input density map</a>.
The interpreted density for a given lattice cell with indices l, m, and n is denoted &Xi;<sub>lmn</sub> and is meant
to correspond to some atomic property such as mass (&rarr; <a href="keywords.html#EMPROPERTY">EMPROPERTY</a>).
The potential itself is as follows:<br/>
<br/>
E<sub>EMICRO</sub> = f<sub>EMICRO</sub> &Sigma;<sub>ijk</sub> (&rho;<sub>ijk</sub> - &Xi;<sub>ijk</sub> )<sup>2</sup><br/>
<br/>
The value of f<sub>EMICRO</sub> is set by this keyword. The potential is extensive with the number
of grid cells. If it is the dominant contribution in terms of CPU time to energy evaluations,
the use of <a href="keywords.html#DYNAMICS">Monte Carlo sampling</a> is currently quite wasteful
since the values for &Delta;E<sub>EMICRO</sub> are not actually incremental.
The sum implied in the above equation is over all
lattice cells of an evaluation grid reduced in resolution to exactly that of the input density map.
Note that the dimensions of the evaluation grid are controlled by <a href="keywords.html#SIZE">system size</a> and 
<a href="keywords.html#SHAPE">shape</a>, and that its formal resolution is either assumed to be that
of the input map or set explicitly by keyword <a href="keywords.html#EMDELTAS">EMDELTAS</a> (although the resultant
lattice is required to have cell boundaries that align exactly with those of the input map). If the 
resolution of the evaluation grid is finer, the values for its cells are summed up to give the coarser
resolution. Furthermore, the evaluation grid may extend beyond the input map, and in such a case the
summation also includes (coarse) cells where the input is assumed to be exactly the
<a href="keywords.html#EMBGDENSITY">background density</a>. Taken together, these caveats
mean that it is rarely useful not to match the input lattice exactly. Importantly, the spatial density
restraint provides an absolute reference in space, which means that it is most likely incorrect to
use <a href="keywords.html#SYSFRZ">drift removal techniques</a>. Another unusual aspect about this potential
is that it only applies to physically present molecules
in simulations in <a href="keywords.html#ENSEMBLE">ensembles with fluctuating particle numbers</a>. This
is despite it not being a pairwise interaction term, and distinguishes it from potentials affecting the bath
particles as well (such as <a href="keywords.html#SC_BONDED_T">bonded potentials</a>). Because the potential
is strictly a penalty term, this creates an effective mismatch that must be lumped manually into the
<a href="inputfiles.html#PARTICLEFLUCFILE">excess chemical potential</a>. This is neither pretty nor clean
meaning that concurrent use of this techniques should be accompanied by the appropriate skepticism.<br/>
Depending on the choice for <a href="keywords.html#EMMODE">EMMODE</a>, E<sub>EMICRO</sub> can also
be written using an average of the simulation density that is typically not equivalent to the 
canonical ensemble average:<br/>
<br/>
E<sub>EMICRO</sub> = f<sub>EMICRO</sub> &Sigma;<sub>ijk</sub> ( &lang; &rho;<sub>ijk</sub> &rang; - &Xi;<sub>ijk</sub> )<sup>2</sup><br/>
<br/>
Here, the angular brackets indicate an average that depends on keyword <a href="keywords.html#EMIWEIGHT">EMIWEIGHT</a>
and is explained there. Further details as to why the canonical average is not used are <a href="keywords.html#EMMODE">below</a>.
Note that the potential utilizing this average no longer corresponds to a unique Hamiltonian, <i>i.e.</i>, every time 
the average is updated the energy landscape changes. This means that the ensembles generated are no longer
straightforward to interpret. The obvious benefits of using an ensemble-averaged restraint are twofold. First,
explicit heterogeneity can explain data that would be inconsistent with a unique structure. Second, sampling
is aided by the fact that "stuck" conformations will tend to become unstable in terms of E<sub>EMICRO</sub>
over time. As a final remark, users should keep in mind that the actual ensemble average generated may not
agree with input given that this quantity was never actually restrained during the simulation.<br/>
As mentioned above, when CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
all threads contribute to calculating E<sub>EMICRO</sub> synchronously. However, the parallel efficiency is
generally poor if either the lattices are large (in number of grid cells) relative to the number of atoms
or if the solutes in a dilute system change absolute positions rapidly.<br/> 
<h4><a class="NoHi" id="EMMODE"><b>EMMODE</b></a></h4>
If the <a href="keywords.html#SC_EMICRO">density restraint potential</a> is in use, this keyword allows the user
to choose between two options. Setting this keyword to 1 computes the restraint term by comparing the instantaneous
simulation density to the <a href="keywords.html#EMMAPFILE">input density map</a>, whereas a choice of 2 computes
the restraint term by comparing an ensemble-averaged simulation density to the <a href="keywords.html#EMMAPFILE">input density map</a>.<br/>
While the first option is straightforward, the second one requires some additional considerations as follows.
Irrespective of whether a run is in parallel or not, the ensemble average is currently obtained over the previous
sampling history (beyond <a href="keywords.html#EQUIL">equilibration</a>) of the exact trajectory in question.
Note that any average is created in terms of numbers of steps, which may cause inconsistencies in 
<a href="keywords.html#DYNAMICS">hybrid sampling runs</a> due to the different average phase space increments.
Choosing an appropriate type of 
average is not trivial (see, <i>e.g.</i>, <a href="references.html#ref2_11">this reference</a>), because the naive approach
of including the entire sampling history leads to a continuously decreasing impact of the restraint term.
There are currently two ways to address this. First, the accumulation frequency for the ensemble average can be reduced
by keyword <a href="keywords.html#EMCALC">EMCALC</a>. This slows down the reduction in impact and effectively gives
the system more time to explore, because it results in concatenated runs of length <a href="keywords.html#EMCALC">EMCALC</a>,
during which the potential is in fact constant. Second, CAMPARI uses a fixed weight for the instantaneous
component of the average while evaluating the potential. This fixed weight is set by keyword 
<a href="keywords.html#EMIWEIGHT">EMIWEIGHT</a> and provides a way to utilize the entire 
history without degrading the impact of the restraint potential. A third route would be to use an appropriate kernel function
in the time averaging, but this is inconvenient and potentially inefficient for spatial density analysis due to the large
number of terms that would have to be stored and processed to recompute the kernel-based average.<br/>
A third option for this keyword may be added in the future that allows a lateral ensemble average to be restrained in 
<a href="keywords.html#MPIAVG">MPI averaging calculations</a>.<br/>
<h4><a class="NoHi" id="EMIWEIGHT"><b>EMIWEIGHT</b></a></h4>
If the <a href="keywords.html#SC_EMICRO">density restraint potential</a> is in use, and if the potential
acts on some <a href="keywords.html#EMMODE">ensemble-averaged</a> simulation density, this keyword allows the user
to set a fixed weight for the constructed average:<br/>
<br/>
&lang; &rho;<sub>ijk</sub> &rang; = (1-<i>w<sub>inst</sub></i>) N<sub>steps</sub><sup>-1</sup> &Sigma;<sub>i</sub> &rho;<sub>ijk</sub>(i) ) + 
<i>w<sub>inst</sub></i> &rho;<sub>ijk</sub>(current)<br/>
<br/>
Here, the factor <i>w<sub>inst</sub></i> is set by this keyword and bound to the interval from 0 to 1. The &rho;<sub>ijk</sub>(i)
are the N<sub>steps</sub> values contributing to the running, canonical average of the density, and &rho;<sub>ijk</sub>(current) is the 
density produced by the current conformation at that given lattice cell. The limiting case of <i>w<sub>inst</sub></i> being
1.0 recovers the instantaneous treatment (&rarr; <a href="keywords.html#EMMODE">EMMODE</a>). The limiting case of <i>w<sub>inst</sub></i>
being 0.0 does not, however, produce a meaningful restraint (since it is independent of the current conformation). Both
limiting cases are therefore forbidden. Note that it is currently not possible to recover the naive approach of
a restraint that continuously decreases in relevance.<br/>
<h4><a class="NoHi" id="EMMAPFILE"><b>EMMAPFILE</b></a></h4>
This keyword provides the location and name of the mandatory density input file 
when using the <a href="keywords.html#SC_EMICRO">density restraint potential</a>.
The file format is described in detail <a href="inputfiles.html#FMCSC_EMMAPFILE">elsewhere</a>,
and here it suffices to say that the external <a href="references.html#ref16_1">NetCDF</a> library is needed, and
that currently no other common density file formats (.ccp4, .mrc, ...) are
read directly by CAMPARI. <a href="references.html#ref23_10">UCSF Chimera</a>
is able to convert between various density-based file formats, and does read and write NetCDF files.<br/>
The most common application is likely that of a simulation with <a href="keywords.html#BOUNDARY">3D periodic boundary conditions</a>
 and a <a href="keywords.html#SHAPE">rectangular cuboid simulation volume</a>.
Here, the cells of the input lattice should align exactly with those of the analysis and evaluation
lattice CAMPARI uses, and generally it will be easiest to match both origin and dimensions exactly.
By default, CAMPARI will obtain the lattice cell dimensions from the input map.
For nonperiodic boundaries (including simulation systems with curved boundaries), it will be required, however,
to deviate from such an exact match. Here, keyword <a href="keywords.html#EMBUFFER">EMBUFFER</a> can be used to
define the buffer in size for the evaluation grid at any nonperiodic boundaries. Furthermore,
keyword <a href="keywords.html#EMDELTAS">EMDELTAS</a> can always be used to request the analysis
and evaluation lattice to have cells of a smaller size, which, with the 
restraint potential in place, has to yield the exact input cell size by integer
multiplication for all three dimensions. Lastly, keyword <a href="keywords.html#EMREDUCE">EMREDUCE</a> 
can be used to average the input map to a lower resolution by re-binning.<br/>
Assuming no further transformations are applied (&rarr; keywords
<a href="keywords.html#EMREDUCE">EMREDUCE</a>, <a href="keywords.html#EMTRUNCATE">EMTRUNCATE</a>,
<a href="keywords.html#EMFLATTEN">EMFLATTEN</a>), the interpreted density based on the input
file is as follows:<br/>
<br/>
&Xi;<sub>ijk</sub> = &rho;<sub>sol</sub> + <i>c</i>(&omega;<sub>ijk</sub> - &omega;<sub>bg</sub>)<br/>
<br/>
Here,the final density for a given lattice cell, &Xi;<sub>ijk</sub>, has units of physical density, <i>c</i> is a scale factor explained below,
&omega;<sub>ijk</sub> is the original input density for the same lattice cell, and &rho;<sub>sol</sub> and &omega;<sub>bg</sub>
are the assumed physical and input background signals, respectively. &rho;<sub>sol</sub> is set by keyword 
<a href="keywords.html#EMBGDENSITY">EMBGDENSITY</a>, and &omega;<sub>bg</sub> can be set by keyword
<a href="keywords.html#EMBACKGROUND">EMBACKGROUND</a> if the value determined automatically from the histogram
of input densities is not appropriate. Factor <i>c</i> is given as follows:<br/>
<br/>
<i>c</i> =  [ <i>M<sub>M</sub></i> - &rho;<sub>sol</sub> &Sigma;<sub>ijk</sub> V<sub>ijk</sub> H(&omega;<sub>ijk</sub>-&omega;<sub>t</sub>) ] &#183;
[&Sigma;<sub>ijk</sub> (&omega;<sub>ijk</sub>-&omega;<sub>bg</sub>)V<sub>ijk</sub> H(&omega;<sub>ijk</sub>-&omega;<sub>t</sub>) ]<sup>-1</sup><br/>
<br/>
Here, the first term in square brackets is a hypothetical excess signal (mass) using the apparent macromolecular volume (the sum of the volume
of all lattice cells with signals exceeding the threshold, <a href="keywords.html#EMTHRESHOLD">&omega;<sub>t</sub></a>)
and the <a href="keywords.html#EMTOTMASS">assumed total mass</a>. The V<sub>ijk</sub> are the volumes of individual lattice
cells and currently have to be all equal, and H(x) denotes the Heaviside step function. The second term in square
brackets is the actual excess signal (mass) derived from the input map obtained by analogous summation.
Factor <i>c</i> has units that convert optical density (input) to physical density.
It is important to note the crucial impact of keywords <a href="keywords.html#EMTHRESHOLD">EMTHRESHOLD</a> and
 <a href="keywords.html#EMTOTMASS">EMTOTMASS</a> on the quantitative interpretation of the map. In particular,
many combinations of values will be rejected by CAMPARI, because they cannot produce an excess signal larger than
the background. The resultant interpreted map is written to a
<a href="outputfiles.html#DENSITY_INPUT_PHYS.nc">dedicated output file</a> at the beginning of
each run. Note that this includes all optional transformations controlled by keywords
<a href="keywords.html#EMREDUCE">EMREDUCE</a>, <a href="keywords.html#EMTRUNCATE">EMTRUNCATE</a>,
and <a href="keywords.html#EMFLATTEN">EMFLATTEN</a>.<br/>
<h4><a class="NoHi" id="EMREDUCE"><b>EMREDUCE</b></a></h4>
If the <a href="keywords.html#SC_EMICRO">density restraint potential</a> is in use, this keyword
can be used to change the formal resolution of the <a href="keywords.html#EMMAPFILE">input density map</a>.
This is accomplished by simple re-binning, <i>i.e.</i>, the target and original lattices are aligned
at the origin, and the original signal for each cell is distributed to the target cells by simple overlap. Because
the input is assumed to be a density, volume renormalization is performed. Note that it is generally meaningless
to create a finer grid this way, because no new information is available, and CAMPARI distributes
signal assuming a flat distribution inside each original input cell.  
Similar to keyword <a href="keywords.html#EMDELTAS">EMDELTAS</a>, this keyword
requires the specification of three floating point numbers that set the
target lattice cell sizes of the re-binned input map in &#8491; for the x, y, and z dimensions, respectively.
Note that the exact values will generally be slightly different because of the requirement to
have the outer dimensions of both grids align exactly. Finally, users should keep in mind that
physical resolution and formal resolution of the lattice used to represent the data are two distinct quantities.<br/>
<h4><a class="NoHi" id="EMBACKGROUND"><b>EMBACKGROUND</b></a></h4>
If the <a href="keywords.html#SC_EMICRO">density restraint potential</a> is in use, this optional keyword
can be used to override the value determined to correspond to background in the <a href="keywords.html#EMMAPFILE">input density map</a>
(&omega;<sub>bg</sub> in the equation <a href="keywords.html#EMMAPFILE">above</a>).
This value is commonly set by binning the densities in all cells, and identifying a well-resolved peak in the histogram.
If the map does not contain encode much background signal, the histogram-based determination may be inappropriate,
and this is when this keyword is useful. Note that values
refer to the original <a href="keywords.html#EMMAPFILE">input density map</a>.<br/>
<h4><a class="NoHi" id="EMTHRESHOLD"><b>EMTHRESHOLD</b></a></h4>
If the <a href="keywords.html#SC_EMICRO">density restraint potential</a> is in use, this important keyword
controls the linear transform used to interpret the <a href="keywords.html#EMMAPFILE">input density map</a>
in terms of a physical mass density. Specifically, it sets a threshold level in units and numbers
of the (<a href="keywords.html#EMREDUCE">potentially re-binned</a>) input that distinguishes signal
from background. Since measurements often have low contrast, the threshold is not an obvious property
of the input map. The threshold set here corresponds to parameter &omega;<sub>t</sub> in the equation
<a href="keywords.html#EMMAPFILE">above</a>. It is primarily responsible for the overall scaling factor, <i>i.e.</i>,
larger threshold values will generally produce interpreted maps with a wider spectrum of physical density values.
Using the apparent molecular volume and the <a href="keywords.html#EMTOTMASS">total mass</a>,
the chosen threshold directly determines the apparent physical density (reported in log-output).
This quantity poses constraints on the chosen value, because the integrated signal must be yielding a density larger than the
<a href="keywords.html#EMBGDENSITY">assumed physical background density</a>.<br/>
<h4><a class="NoHi" id="EMTOTMASS"><b>EMTOTMASS</b></a></h4>
If the <a href="keywords.html#SC_EMICRO">density restraint potential</a> is in use, this keyword
sets the mass in g/mol to be assumed to correspond to the signal in the <a href="keywords.html#EMMAPFILE">input density map</a>
exceeding the <a href="keywords.html#EMTHRESHOLD">threshold</a>. In general, this can be set to 
correspond exactly to the explicitly represented matter in the simulation (this is the default), but exceptions
may desire an override, <i>e.g.</i>, when simulating only a part of the system without wanting
to distort the interpretation of the map. The parameter corresponds to <i>M<sub>M</sub></i> in the 
equation <a href="keywords.html#EMMAPFILE">above</a>.<br/>
<h4><a class="NoHi" id="EMTRUNCATE"><b>EMTRUNCATE</b></a></h4>
If the <a href="keywords.html#SC_EMICRO">density restraint potential</a> is in use, this keyword 
enables truncation of the input map below the chosen value as long as it is higher than the minimum
and lower than the <a href="keywords.html#EMTHRESHOLD">assumed threshold level</a>
(&omega;<sub>t</sub> in the equation <a href="keywords.html#EMMAPFILE">above</a>). Truncation implies that
the spectrum of values for the interpreted density is completed depleted below the specified level,
because all values are simply assigned the <a href="keywords.html#EMBACKGROUND">background level</a>, &omega;<sub>bg</sub>.
This technique can be used to eliminate noise from the input that may hamper sampling. Note that values
refer to the original <a href="keywords.html#EMMAPFILE">input density map</a>. This keyword is the
exact complement to <a href="keywords.html#EMFLATTEN">EMFLATTEN</a>.<br/>
<h4><a class="NoHi" id="EMFLATTEN"><b>EMFLATTEN</b></a></h4>
Depending on how a density map is generated, the signal may cover a wide spectrum of values. This is particularly
true if the contrast to the background is generally low, and the lack of contrast is compensated for by
averaging over similar, but heterogeneous conformations. In such cases, the ratio of peak to barely detectable signals
may be impossible to describe by physical densities of instantaneous conformations. If the
<a href="keywords.html#SC_EMICRO">density restraint potential</a> is in use, this keyword therefore
allows the user to flatten an <a href="keywords.html#EMMAPFILE">input density map</a> at a given level
specified by this keyword. The requirement is that the value be larger than the <a href="keywords.html#EMTHRESHOLD">assumed threshold level</a>.
This keyword is the exact complement to <a href="keywords.html#EMTRUNCATE">EMTRUNCATE</a>, and using both
concurrently can produce an interpreted map that is purely an envelope of homogeneous density.<br/>
<h4><a class="NoHi" id="EMHEURISTIC"><b>EMHEURISTIC</b></a></h4>
The evaluation of the <a href="keywords.html#SC_EMICRO">density restraint potential</a> involves the summation
of contributions from all the grid cells. Each cell contributes a squared difference of the input density
and the actual density for the current conformation of explicit matter in the system. If the formal
resolution is high, the evaluation of the potential can be costly. Occasionally, it may be
possible to save some CPU time by applying dedicated heuristics, and this is what is controlled
by this keyword. Choices are as follows:<br/>
<ol start='0'>
<li>No heuristic is used. At each global evaluation of the <a href="keywords.html#SC_EMICRO">density restraint potential</a>, all
grid cells are recomputed and summed up.</li>
<li>When spreading the atomic masses in the system onto the analysis and evaluation grid, CAMPARI keeps track of whether
any given xz-slice of the input map actually received a contribution from any atom. If not, the cells constituting this
xz-slice are not recomputed, but instead a precomputed value for the entire slice is used. This is possible because the
simulation densities in all the cells of the slice will be equivalent to the
<a href="keywords.html#EMBGDENSITY">assumed background density</a>. Efficacy of this heuristic obviously depends
on the details of the system.</li>
<li>This works identically to the previous option, except that x-lines are considered rather than xz-slices.</li>
<li>This works identically to the previous options, except that local rectangular supercells are used rather than xz-slices or x-lines.
Here, the algorithm will try to combine existing grid cells to yield approximately 1000 supercells. This option is probably
the most successful in general, because it can match arbitrary arrangements of explicit matter best.</li>
</ol>
Note that heuristics of the above type offer only moderate savings if on average the explicit matter does in fact cover the
evaluation and analysis grid to a large fraction.<br/>
<h4><a class="NoHi" id="GHOST"><b>GHOST</b></a></h4>
This keyword is a simple logical that determines whether or not to
(partially)
"ghost" the interactions of selected particles (see <a
 href="keywords.html#FEGFILE">FEGFILE</a>)
with the rest of the system (and eventually amongst themselves →
<a href="keywords.html#FEG_MODE">FEG_MODE</a>). Such scaling of
interactions
creates artificial systems which can be used to interpolate between two
well-defined end states. The most common need for such an application
arises in cases where the two end states are significantly different
and one is interested in the free energy difference.
For example, to calculate the aqueous free energy of solvation of a
small molecule
in water, one could scale the interactions of the small molecule with
water from zero to their full value. Such growth-based calculations are
usually complicated to set up and perform since i) trajectories evolved
at a given Hamiltonian have to be evaluated (on-the-fly usually)
assuming
different Hamiltonians, and ii) it is difficult to maintain an
internally consistent system of interactions such that all changes
induced by the ghosting can
be mapped to atomic parameters of the ghosted species.
In CAMPARI, FEG (free energy growth/ghosting) calculations are
therefore
supported in conjunction with limited Hamiltonians only: the only
potentials allowed are <a href="keywords.html#SC_IPP">IPP</a>, <a
 href="keywords.html#SC_ATTLJ">ATTLJ</a>,
<a href="keywords.html#SC_POLAR">POLAR</a>, and the bonded
interactions.
In other cases, it may be possible to extract the same or related
quantities
through other techniques realizable in CAMPARI. As an example, the free
energy
of solvation for a flexible (single) solute immersed in the ABSINTH
continuum
solvation model can be obtained by simultaneously scaling the
<a href="keywords.html#IMPDIEL">dielectric</a> from 1.0 to 78.0 and the
<a href="keywords.html#SC_IMPSOLV">DMFI</a>
from 0.0 to 1.0.
The default settings for the auxiliary keywords to GHOST are such that
the molecules or residues listed in <a href="keywords.html#FEGFILE">FEGFILE</a>
will be completely ghosted (<i>i.e.,</i> invisible to the system).<br/>
<h4><a class="NoHi" id="FEG_MODE"><b>FEG_MODE</b></a></h4>
In FEG calculations interactions (see <a href="keywords.html#GHOST">GHOST</a>)
are
always scaled between the ghosted species and the rest of the system.
A natural question arises as to what happens to interactions between or
within ghosted
species (if any are present)? If they are not scaled but instead use
the background Hamiltonian it will be impossible
to map the effect of the scaling to a change in atomic parameters which
is
desirable from the viewpoint of rigor. As an example, consider polar
interactions between a single ghosted
butane molecule and a bath of non-ghosted water. A scaling of the
atomic charges on the ghost
butane by a factor <i>f</i> would give rise to interactions with the
bath scaled by <i>f</i>
and self-interactions scaled by <i>f</i><sup>2</sup>. This type of
scaling is enforced
in CAMPARI if a method requires it such as treating electrostatics with
the
reaction-field method (see <a href="keywords.html#LREL_MD">LREL_MD</a>).
In general, however, it is impossible to find a unique mapping while
leaving
the background Hamiltonian intact. It is therefore left to the user to
determine which of two options to choose:<br/>
&nbsp;1) Interactions between/within ghosted species use the full
background Hamiltonian.<br/>
&nbsp;2) Interactions between/within ghosted species use the scaled
Hamiltonian.<br/>
The choice made here is important only if such interactions are present
in the system. If so, however,
the raw results will usually depend strongly on it and corrections may
have to be applied.
As an example, consider the butane-water example from above. The fact
that intramolecular interactions
are scaled will contribute toward the apparent free energy obtained
when interpolating between the fully ghosted and the fully present
states. Hence, gas phase corrections have to be applied.
They are obtained by repeating the calculation in the absence of water
to compute the thermodynamic
cycle which then allows isolating the free energy of solvation.
Additional complications may arise if molecules are constrained (see <a
 href="keywords.html#FRZFILE">FRZFILE</a>).<br/>
<h4><a class="NoHi" id="FEG_IPP"><b>FEG_IPP</b></a></h4>
This keyword specifies the "outside" scaling factor for the ghosted
inverse power potential. Note that
depending on the choice for <a href="keywords.html#FEG_LJMODE">FEG_LJMODE</a>
this is not as simple
as <a href="keywords.html#SC_IPP">SC_IPP</a> and that additional
parameters
may determine the impact this keyword has. The setting here corresponds
to the parameter s<sub>gIPP</sub> below. Note as well that the inverse
power potential supported in calculations with ghosted interactions
always
uses an exponent of 12 (<i>i.e.</i>, setting <a
 href="keywords.html#IPPEXP">IPPEXP</a> to anything but the default of
12 will cause CAMPARI to abort). This keyword is only relevant if <a href="keywords.html#GHOST">GHOST</a> is true.<br/>
<h4><a class="NoHi" id="FEG_ATTLJ"><b>FEG_ATTLJ</b></a></h4>
This keyword is analogous to <a href="keywords.html#FEG_IPP">FEG_IPP</a>
but controls
the "outside" scaling of the attractive r<sup>-6</sup> dispersive term.
The setting here corresponds to the parameter s<sub>gattLJ</sub> below.
Note that scaling this up while <a href="keywords.html#FEG_IPP">FEG_IPP</a>
is set to zero (or - depending on the mode - even set to something
smaller) will
potentially lead to numerical instabilities.<br/>
<h4><a class="NoHi" id="FEG_LJMODE"><b>FEG_LJMODE</b></a></h4>
The exact functional form of the scaled (ghosted) Lennard-Jones
potential is as follows:<br/>
<br/>
E<sub>gLJ</sub> = 4.0·ΣΣ<sub>i,j</sub> ε<sub>ij</sub>f<sub>1-4,ij</sub>·[
g(s<sub>gIPP</sub>)·[α·h(s<sub>gIPP</sub>) + (r<sub>ij</sub>/σ<sub>ij</sub>)<sup>6</sup>]<sup>-2</sup>
- g(s<sub>gattLJ</sub>)·[α·h(s<sub>gattLJ</sub>) + (r<sub>ij</sub>/σ<sub>ij</sub>)<sup>6</sup>]<sup>-1</sup>
]<br/>
<br/>
Here, the ε<sub>ij</sub> and σ<sub>ij</sub> are the standard pairwise
Lennard-Jones parameters (see
<a href="parameters.html#S2_LJ-types">PARAMETERS</a>), the f<sub>1-4,ij</sub>
are potential 1-4 fudge
factors (see <a href="keywords.html#FUDGE_ST_14">FUDGE_ST_14</a>) that
generally will be unity, g(s) and h(s) are auxiliary functions whose
functional form depends on the choice for this keyword, and α is the
so-called soft-core radius (unitless).
The two scaling factors s<sub>gIPP</sub> and s<sub>gattLJ</sub> are
provided by keywords <a href="keywords.html#FEG_IPP">FEG_IPP</a> and <a
 href="keywords.html#FEG_ATTLJ">FEG_ATTLJ</a>). There are three
possible choices determining g(s) and h(s):<br/>
<ol>
  <li>g(s) = s<br/>
h(s) = 0</li>
  <li>g(s) = s<sup>f<sub>1</sub></sup><br/>
h(s) = 1.0 - s<sup>f<sub>2</sub></sup></li>
  <li>g(s) = (1.0 - e<sup>-sf<sub>1</sub></sup>)/(1.0 - e<sup>-f<sub>1</sub></sup>)<br/>
h(s) = (1.0 - s)<sup>f<sub>2</sub></sup></li>
</ol>
Option 1 corresponds to a simple linear scaling which is unsuitable for
most purposes since it does not remove the
singularity at r<sub>ij</sub>→0. Mode 2 is the most common workaround
which introduces polynomial scaling via additional parameters f<sub>1</sub>
(→ <a href="keywords.html#FEG_LJEXP">FEG_LJEXP</a>) and f<sub>2</sub>
(→ <a href="keywords.html#FEG_LJSCEXP">FEG_LJSCEXP</a>). The non-zero
values of h(s) will also make the
soft-core radius α a relevant parameter. The latter is specified
through keyword <a href="keywords.html#FEG_LJRAD">FEG_LJRAD</a>.
Essentially, interpolation between the singularity-containing native
potential and a zero
potential is obtained by successively ramping up a barrier proportional
to (h(s)·α)<sup>-1</sup>, which for tiny values of h(s) (s→1)
approaches the singularity. Mode 3 is very similar but uses exponential
rather than polynomial scaling for g(s) and a slightly different
functional form for h(s). The parameters
are reinterpreted accordingly. In all cases, setting s to zero will
eliminate
the potential entirely, while setting it to unity will recover the
native Lennard-Jones potential. This keyword is only relevant if <a href="keywords.html#GHOST">GHOST</a> is true.
<!--
<br/>
<img style="width: 334px; height: 23px;"
 alt="U_ij = 4*eps_ij*g(s)*( 1.0/((alpha*h(s) + (r_ij/sig_ij)**6)**2) - 1.0/(alpha*h(s) + (r_ij/sig_ij)**6) )"
 src="website_equations/keywords_FEG_LJMODE.gif"><br/>
<br/>
&nbsp;mode 1) <br/>
&nbsp;&nbsp;&nbsp;&nbsp; g(s) = s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h(s) = 0.0<br/>
&nbsp;mode 2) <br/>
&nbsp;&nbsp;&nbsp;&nbsp; <img id="equationview" id="equationview"
 onload="processEquationChange()"
 title="This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program."
 src="http://latex.codecogs.com/gif.latex?%5Cbg_white%20%5Cinline%20g%28s%29%20=%20s%5E%7B%28f_1%29%7D"><br/>
&nbsp;&nbsp;&nbsp;&nbsp; <img id="equationview" id="equationview"
 onload="processEquationChange()"
 title="This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program."
 src="http://latex.codecogs.com/gif.latex?%5Cbg_white%20%5Cinline%20h%28s%29%20=%201.0%20-%20s%5E%7B%28f_2%29%7D"><br/>
&nbsp;mode 3) <br/>
&nbsp;&nbsp;&nbsp;&nbsp; <img id="equationview" id="equationview"
 onload="processEquationChange()"
 title="This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program."
 src="http://latex.codecogs.com/gif.latex?%5Cbg_white%20%5Cinline%20g%28s%29%20=%201.0-e%5E%7B%28-f_1%20s%29%7D/%281.0-e%5E%7B%28-f_1%29%7D%29"><br/>
&nbsp;&nbsp;&nbsp;&nbsp; <img id="equationview" id="equationview"
 onload="processEquationChange()"
 title="This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program."
 src="http://latex.codecogs.com/gif.latex?%5Cbg_white%20%5Cinline%20h%28s%29%20=%20%281.0%20-%20s%29%5E%7B%28f_2%29%7D"><br/>
--><br/>
<h4><a class="NoHi" id="FEG_LJRAD"><b>FEG_LJRAD</b></a></h4>
This keyword allows the user to specify the parameter α in the above
equations
(see <a href="keywords.html#FEG_LJMODE">FEG_LJMODE</a>), <i>i.e.</i>,
the soft-core "radius" for the modified Lennard-Jones potential. It is
generally
of limited utility to set this to zero since in that case the scaled
potential could as well be created by setting <a href="keywords.html#FEG_LJMODE">FEG_LJMODE</a> to 1
in which case this parameters becomes meaningless. Conversely, for
large soft-core radii, the potential is modified for large distances
which
generally represents unnecessary modification which may slow down
convergence in free energy calculations relying on interpolation via
ghosting. Generally speaking, values around 0.5 are recommended
for either mode 2 or 3. This keyword is only relevant if <a href="keywords.html#GHOST">GHOST</a> is true.<br/>
<h4><a class="NoHi" id="FEG_LJEXP"><b>FEG_LJEXP</b></a></h4>
This keyword sets the parameter f<sub>1</sub> in the above equations
(see <a href="keywords.html#FEG_LJMODE">FEG_LJMODE</a>). It represents
a way to - in a simple way - alter the weight
of change experienced by the system depending on the choices of <a
 href="keywords.html#FEG_IPP">FEG_IPP</a>
and <a href="keywords.html#FEG_ATTLJ">FEG_ATTLJ</a>. In that sense, it
is very closely tied to the design of the interpolation schedule (<i>i.e.,</i>
both address the exact same issue). There are no gold standard rules
for picking this and the user is referred to the literature for further
details. In case of free energy calculations, it will be best to
inspect the schedule
empirically by metrics such as the statistical precision of the
pairwise estimates or overlap metrics such as (theoretical) swap
probabilities and to then refine
either the schedule itself or the global settings accordingly. This keyword is only relevant if <a href="keywords.html#GHOST">GHOST</a> is true.<br/>
<h4><a class="NoHi" id="FEG_LJSCEXP"><b>FEG_LJSCEXP</b></a></h4>
This keyword sets the parameter f<sub>2</sub> in the above equations
(see <a href="keywords.html#FEG_LJMODE">FEG_LJMODE</a>). Much of the
same discussion
applies here as already mentioned for keywords <a
 href="keywords.html#FEG_LJRAD">FEG_LJRAD</a> and <a
 href="keywords.html#FEG_LJEXP">FEG_LJEXP</a>. This keyword is only relevant if <a href="keywords.html#GHOST">GHOST</a> is true.<br/>
<h4><a class="NoHi" id="FEG_POLAR"><b>FEG_POLAR</b></a></h4>
The only other non-bonded potential besides Lennard-Jones supported in
<a href="keywords.html#GHOST">FEG calculations</a> is the polar potential (see <a href="keywords.html#SC_POLAR">SC_POLAR</a>).
This keyword provides a scaling factor (s<sub>gPOLAR</sub>) for the
soft-core Coulomb
potential. Much similar to the case for scaled LJ interactions (see
above), this
may involve three additional parameters (see <a
 href="keywords.html#FEG_CBMODE">FEG_CBMODE</a>).
Note that it would be most common to only scale this up while <a href="keywords.html#FEG_IPP">FEG_IPP</a> is set to unity so as to
avoid potential numerical instabilities.<br/>
<h4><a class="NoHi" id="FEG_CBMODE"><b>FEG_CBMODE</b></a></h4>
In analogy to <a href="keywords.html#FEG_LJMODE">FEG_LJMODE</a>, this
keyword
determines what exact functional form CAMPARI uses for the scaled
(ghosted) Coulomb
potential with the "outside" scaling factor s<sub>gPOLAR</sub> set by\
<a href="keywords.html#FEG_POLAR">FEG_POLAR</a>):<br/>
<br/>
E<sub>gLJ</sub> = (4.0πε<sub>0</sub>)<sup>-1</sup>·ΣΣ<sub>i,j</sub> g(s<sub>POLAR</sub>)·q<sub>i</sub>q<sub>j</sub>·f<sub>1-4,C,ij</sub>·[α<sub>C</sub>·h(s<sub>gPOLAR</sub>)
+ r<sub>ij</sub>]<sup>-1</sup><br/>
<br/>
Here, the atomic partial charges are represented as q<sub>i,j</sub>, ε<sub>0</sub>
is the vacuum permittivity, and r<sub>ij</sub> is the interatomic
distance. f<sub>1-4,C,ij</sub> denotes potential fudge factors acting
on
1-4-separated atom pairs (see <a href="keywords.html#FUDGE_EL_14">FUDGE_EL_14</a>)
but will generally assume
a value of unity. g(s) and h(s) are the same auxiliary functions
defined above for the Lennard-Jones
potential (→ <a href="keywords.html#FEG_LJMODE">FEG_LJMODE</a>) and α<sub>C</sub>
is the
soft-core radius (unitless) specific to the Coulomb potential
(controlled by keyword
<a href="keywords.html#FEG_CBRAD">FEG_CBRAD</a>). For completeness the
options are listed again in detail:<br/>
<ol>
  <li>g(s) = s<br/>
h(s) = 0</li>
  <li>g(s) = s<sup>f<sub>C,1</sub></sup><br/>
h(s) = 1.0 - s<sup>f<sub>C,2</sub></sup></li>
</ol>
The "outside" scaling factor s<sub>POLAR</sub> is controlled through
keyword <a href="keywords.html#FEG_POLAR">FEG_POLAR</a>. Additional
parameters in mode 2 are f<sub>C,1</sub> (→ <a href="keywords.html#FEG_CBEXP">FEG_CBEXP</a>) and
f<sub>C,2</sub> (→ <a  href="keywords.html#FEG_CBSCEXP">FEG_CBSCEXP</a>).
<!--
&nbsp;<img style="width: 225px; height: 17px;"
 alt="U_ij = g(s) * a * sij * qi*qj / (alpha*h(s) + rij)"
 src="website_equations/keywords_FEG_CBMODE.gif"><br/>
<br/>
&nbsp;mode 1) <br/>
&nbsp;&nbsp;&nbsp;&nbsp; g(s) = s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h(s) = 0.0<br/>
&nbsp;mode 2) <br/>
&nbsp;&nbsp;&nbsp;&nbsp; <img id="equationview" id="equationview"
 onload="processEquationChange()"
 title="This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program."
 src="http://latex.codecogs.com/gif.latex?%5Cbg_white%20%5Cinline%20g%28s%29%20=%20s%5E%7B%28f_1%29%7D"><br/>
&nbsp;&nbsp;&nbsp;&nbsp; <img id="equationview" id="equationview"
 onload="processEquationChange()"
 title="This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program."
 src="http://latex.codecogs.com/gif.latex?%5Cbg_white%20%5Cinline%20h%28s%29%20=%201.0%20-%20s%5E%7B%28f_2%29%7D"><br/>
<br/>
Here, the sij is the optional charge-screening term, A is a
simple unit conversion factor, qi/j are atomic charges, and rij is the
interatomic distance. For alpha see keyword <a
 href="keywords.html#FEG_CBRAD">FEG_CBRAD</a>,
for f_1 see keyword <a href="keywords.html#FEG_CBEXP">FEG_CBEXP</a>,
and for f_2 see keyword <a href="keywords.html#FEG_CBSCEXP">FEG_CBSCEXP</a>.<br/>
-->
<h4><a class="NoHi" id="FEG_CBRAD"><b>FEG_CBRAD</b></a></h4>
This keyword is analogous to <a href="keywords.html#FEG_LJRAD">FEG_LJRAD</a>
and allows the user to choose the value for the soft-core radius
specific
to the Coulomb potential (α<sub>C</sub> in the equations under
<a href="keywords.html#FEG_CBMODE">FEG_CBMODE</a>). The specification
is meaningless
if <a href="keywords.html#FEG_CBMODE">FEG_CBMODE</a> is set to 1.
<br/>
<h4><a class="NoHi" id="FEG_CBEXP"><b>FEG_CBEXP</b></a></h4>
This keyword is analogous to <a href="keywords.html#FEG_LJEXP">FEG_LJEXP</a>
and allows the user to choose the value for the polynomial scaling
exponent
to the Coulomb potential (f<sub>C,1</sub> in the equations under
<a href="keywords.html#FEG_CBMODE">FEG_CBMODE</a>). The specification
is meaningless
if <a href="keywords.html#FEG_CBMODE">FEG_CBMODE</a> is set to 1.
<h4><a class="NoHi" id="FEG_CBSCEXP"><b>FEG_CBSCEXP</b></a></h4>
This keyword is analogous to <a href="keywords.html#FEG_LJSCEXP">FEG_LJSCEXP</a>
and allows the user to choose the value for the soft-core scaling
exponent
to the Coulomb potential (f<sub>C,2</sub> in the equations under
<a href="keywords.html#FEG_CBMODE">FEG_CBMODE</a>). The specification
is meaningless
if <a href="keywords.html#FEG_CBMODE">FEG_CBMODE</a> is set to 1.
<h4><a class="NoHi" id="FEG_BONDED_B"><b>FEG_BONDED_B</b></a></h4>
Non-bonded interactions provide a straightforward interpretation for
parsing the energetics of the system into solute-solvent,
solute-solute, and solute-solvent
contributions. This is used in a thermodynamic cycle argument when
computing
- for instance - the free energy of solvation of a solute in solvent
via
<a href="keywords.html#GHOST">FEG methods</a>. Sometimes (as alluded to under <a
 href="keywords.html#FEG_MODE">FEG_MODE</a>),
it may be desirable to scale intramolecular non-bonded interactions as
well.
But what about intramolecular bonded interactions? This keyword allows
the FEG-like scaling of bonded terms associated with a ghosted species
but not of those associated with non-ghosted particles. Beyond that
this keywords operates just like <a href="keywords.html#SC_BONDED_B">SC_BONDED_B</a>.
Note
that this almost certainly creates a pathological situation if bond
length
potentials are allowed to approach zero and naturally relies on bond
lengths
being allowed to vary (see <a href="keywords.html#CARTINT">CARTINT</a>)
to be
meaningful. Note that for all bonded parameters the assignment of terms
to individual residues in a multi-residue molecule is somewhat
arbitrary
if atoms from two different residues participate.<br/>
<h4><a class="NoHi" id="FEG_BONDED_A"><b>FEG_BONDED_A</b></a></h4>
This is analogous to <a href="keywords.html#FEG_BONDED_B">FEG_BONDED_B</a>
only for bond angle potentials. Note that this may lead to a pathological
simulation if bond angle potentials are allowed to approach 0&deg; or 180&deg; and - again -
relies on bond angles actually being varied throughout the simulation to be
meaningful.<br/>
<h4><a class="NoHi" id="FEG_BONDED_I"><b>FEG_BONDED_I</b></a></h4>
This is analogous to <a href="keywords.html#FEG_BONDED_B">FEG_BONDED_B</a>
only
for improper dihedral angle potentials. Note that this may lead to a
pathological simulation
if improper dihedral angle potentials are allowed to approach zero and
- again - relies
on these degrees of freedom actually being varied throughout the simulation to be
meaningful.
<br/>
<h4><a class="NoHi" id="FEG_BONDED_T"><b>FEG_BONDED_T</b></a></h4>
This is analogous to <a href="keywords.html#FEG_BONDED_B">FEG_BONDED_B</a>
only
for proper dihedral angle potentials. Note that this relies
on torsional angles actually being varied throughout the simulation to
be meaningful
(there may be subsets).<br/>
<h4><a class="NoHi" id="FEGREPORT"><b>FEGREPORT</b></a></h4>
This simple logical keyword lets the user instruct CAMPARI to write out
a summary of the ghosted particles (residues or molecules) in 
<a href="keywords.html#GHOST">free energy growth/ghosting</a> calculations.<br/>
<!--<h4><a class="NoHi" id="SC_LCTOR"><b>SC_LCTOR</b></a></h4>
A linear scaling factor for the following:&nbsp; Through a tabulated
potential (see INPUTFILES: <a href="keywords.html#LCTPOTFILE">LCTPOTFILE</a>),
a set of potentials
is applied over linear combinations of torsions (LCTs) or to be more
precise, over their cosine- and
sine-terms. so instead of applying a potential directly on an
individual torsion (as with the TOR-potential), here the
Hamiltonian is written over LCTs:&nbsp;<img
 style="width: 269px; height: 19px;"
 alt="f_k = Sum_i(g_k|i*cos(a_i)+h_k|i*sin(a-i))"
 src="website_equations/keywords_SC_LECTOR.gif">, where i runs through
all the torsions and k runs through all the LCTs. The coefficient
matrices G,H are setup through another input file
(see INPUTFILES: <a href="keywords.html#TORLCFILE">TORLCFILE</a>),
which also contains a column for internal weights of the various LCTs.
the number of LCTs is
provided through a keyword as well (see <a href="keywords.html#NRTORLC">NRTORLC</a>).<br/>
<h4><a class="NoHi" id="LCTPOTFILE"><b>LCTPOTFILE</b></a></h4>
The potential input file for the LCT potential (see <a
 href="inputfiles.html#INPUTFILES">INPUTFILES</a>) - this is currently
not supported<br/>
<h4><a class="NoHi" id="LCTBINS"><b>LCTBINS</b></a></h4>
The number of bins in the potential input file (<a
 href="keywords.html#LCTPOTFILE">LCTPOTFILE</a>) to be read in and used<br/>
<h4><a class="NoHi" id="TORLCFILE"><b>TORLCFILE</b></a></h4>
The coefficient file for the LCTs (see <a
 href="inputfiles.html#INPUTFILES">INPUTFILES</a>)<br/>
<h4><a class="NoHi" id="TORLCFILE2"><b>TORLCFILE2</b></a></h4>
The coefficients for the inverse transformation, <i>i.e.</i>,
torsion_vec = coeff_matrix * lct_vec (see <a
 href="inputfiles.html#INPUTFILES">INPUTFILES</a>). This keyword turns
on LCT moves, which eliminate ALL other moves. LCT moves are sampling
steps directly in the transformed space
and the reverse transform is exclusively used for analysis purposes.
Usage of this feature is currently not supported.<br/>
<h4><a class="NoHi" id="LCTTHRESHOLD"><b>LCTTHRESHOLD</b></a></h4>
If LCT moves are used, this is used to determine the range that
is going to be sampled. the range shouldn't matter as all "outside"
moves are expected to be rejected, so
this primarily increases efficiency.<br/>
-->
<h4><a class="NoHi" id="SCULPT"><b>SCULPT</b></a></h4>
The accelerated molecular dynamics method of <a href="references.html#ref2_21">Hamelberg <i>et al.</i></a>
offers a general (parameter-dependent) way to modify the potential energy landscape or individual terms thereof (torsional potentials
and 1-4 interactions have been used most often). The idea is that a controlled modification of the landscape
that leads to reduced barrier heights is capable of massively accelerating the effective dynamics without reducing
the ensemble overlap dramatically. CAMPARI offers a generalization of this approach as follows:<br/>
<br/>
E<sub>ELS</sub> = &Sigma;i E<sub>i</sub> + &Delta;E<sub>i,ELS</sub><br/>
<table style="width:300px">
<tr>
  <td>&Delta;E<sub>i,ELS</sub> = </td>
  <td>0</td>
  <td>if V<sub>i</sub><sup>f</sup> &lt; E<sub>i</sub> &lt; V<sub>i</sub><sup>s</sup></td>
</tr>
<tr>
  <td></td>
  <td>(V<sub>i</sub><sup>f</sup> - E<sub>i</sub>)<sup>2</sup>/(V<sub>i</sub><sup>f</sup> - E<sub>i</sub> + &alpha;<sub>i</sub><sup>f</sup>)</td>
  <td>if V<sub>i</sub><sup>f</sup> &gt; E<sub>i</sub></td>
</tr>
<tr>
  <td></td>
  <td>(V<sub>i</sub><sup>s</sup> - E<sub>i</sub>)<sup>2</sup>/(V<sub>i</sub><sup>s</sup> - E<sub>i</sub> - &alpha;<sub>i</sub><sup>s</sup>)</td>
  <td>if E<sub>i</sub> &gt; V<sub>i</sub><sup>s</sup></td>
</tr>
</table> 
<br/>
Here, the sum runs over all active terms of the Hamiltonian. These are generally the terms CAMPARI offers a global scaling factor
for, <i>e.g.</i>, the <a href="keywords.html#SC_IMPSOLV">total DMFI of the ABSINTH model</a>, E<sub>DMFI</sub>, the
total sum of <a href="keywords.html#SC_BONDED_I">improper torsional potentials</a>, E<sub>BONDED_I</sub>, <i>etc</i>. Limitations are
discussed below. By default, the threshold energy parameters for every energy term, V<sub>i</sub><sup>f</sup> and V<sub>i</sub><sup>s</sup>, 
are initialized such that E<sub>i,ELS</sub> is always zero, <i>i.e.</i>, no sculpting occurs. They can be modified with the auxiliary
keywords <a href="keywords.html#ELS_FILLS">ELS_FILLS</a> and <a href="keywords.html#ELS_SHAVES">ELS_SHAVES</a>.
Naturally, V<sub>i</sub><sup>f</sup> must always be less than or equal to V<sub>i</sub><sup>s</sup>. The parameters &alpha;<sub>i</sub><sup>f</sup>
and &alpha;<sub>i</sub><sup>s</sup> must always be greater than or equal to zero. They serve as buffer parameters. The modified energy landscape
for a given term has two possible modifications. First, its low energy states (local minima) can be filled up. Using &alpha;<sub>i</sub><sup>f</sup>
as zero flattens all low energy states to the specified threshold, V<sub>i</sub><sup>f</sup>. Larger values for &alpha;<sub>i</sub><sup>f</sup>
preserve the unbiased shape of the landscape more and more, and the limit of &alpha;<sub>i</sub><sup>f</sup> reaching infinity recovers
the unbiased potential exactly. Second, its high energy states (barrier regions) can be shaved off and the use of &alpha;<sub>i</sub><sup>s</sup>
as zero flattens all barrier regions to the value of V<sub>i</sub><sup>s</sup> exactly. The effect of larger values is exactly analogous.
Note, however, that potentials allowing for large positive energy values must be treated with caution
(notably <a href="keywords.html#SC_IPP">inverse power potentials</a>). The value of &Delta;E<sub>i,ELS</sub> for large negative values of
(V<sub>i</sub><sup>s</sup> - E<sub>i</sub>) obviously approaches (V<sub>i</sub><sup>s</sup> - E<sub>i</sub>) itself, which means that
the barriers are more or less completely eliminated. This can be dangerous in conjunction with attractive nonbonded interactions
(numerically speaking) and also lead to poor behavior during reweighting (see <a href="keywords.html#ELS_PRINT_WEIGHTS">below</a>).<br/>
This keyword (SCULPT) allows the user to specify one or more terms to be sculpted (list of integers).
The choices available correspond exactly to the columns of output file <a href="outputfiles.html#ENERGY.dat">ENERGY.dat</a> (click
the link for a list). It includes the total energy (choice 2), which is mutually exclusive with any other term. There are further 
limitations as follows:<br/>
<ul>
<li>In <a href="keywords.html#DYNAMICS">gradient-based simulations</a> (including hybrid runs), nonbonded interactions can only be controlled
as a single joint term (sum), <i>viz.</i>, the sum of all active short-range steric interactions (see <a href="keywords.html#SC_IPP">SC_IPP</a>,
 <a href="keywords.html#SC_ATTLJ">SC_ATTLJ</a>, and <a href="keywords.html#SC_WCA">SC_WCA</a>) as well as polar and tabulated interactions
(see <a href="keywords.html#SC_POLAR">SC_POLAR</a> and <a href="keywords.html#SC_TABUL">SC_TABUL</a>). The correct code to use
for this joint term is 15.</li>
<li>The use of the (quasi-obsolete) <a href="keywords.html#SC_EXTRA">correction potential</a> is not supported when using any
energy landscape sculpting.</li>
</ul>
These caveats apply to the specific sculpting of nonbonded energy terms in gradient-based simulations. Note that the standard nonbonded
potentials diverge at small distances, which means that the energy range is unbound. This will result in vanishing weights for the majority
of conformations even for very small systems. Similarly, while the total energy (option 2) can always
be sculpted (but must be the only term as mentioned above), this is rarely useful for anything but toy models for exactly the same reason. 
Extensions in the future may allow the specific targeting of small subsets of nonbonded and bonded interactions to 
circumvent this problem. Note that any energy term will be completely disabled by choosing 
both buffer parameters as zero (keywords <a href="keywords.html#ELS_ALPHA_F">ELS_ALPHA_F</a> and
<a href="keywords.html#ELS_ALPHA_S">ELS_ALPHA_S</a>) and by setting the threshold energies to the same value (keywords
<a href="keywords.html#ELS_FILLS">ELS_FILLS</a> and <a href="keywords.html#ELS_SHAVES">ELS_SHAVES</a>). Lastly, note
that the energy output in <a href="outputfiles.html#ENERGY.dat">ENERGY.dat</a> will continue to report unperturbed
energies, whereas all other files with energies (<i>e.g.</i>, <a href="outputfiles.html#ENSEMBLE.dat">ENSEMBLE.dat</a>) will
give the sculpted values.<br/>
<h4><a class="NoHi" id="ELS_FILLS"><b>ELS_FILLS</b></a></h4>
If the <a href="keywords.html#SCULPT">energy landscape sculpting</a> method is in use, this keyword supplies the parameters
V<sub>i</sub><sup>f</sup> described <a href="keywords.html#SCULPT">above</a>. Values are to be provided in kcal/mol.
For example, if the choices for <a href="keywords.html#SCULPT">SCULPT</a> are "20 22", then a choice for ELS_FILLS of "5.0 5.0"
would provide lower threshold energies of kcal/mol each to both <a href="keywords.html#SC_BONDED_T">proper dihedral angle potentials</a>
 and to <a href="keywords.html#SC_BONDED_M">CMAP potentials</a>. It is not possible to skip values, <i>i.e.</i>, the length
of the list supplied here should be identical to that for <a href="keywords.html#SCULPT">SCULPT</a>.
To disable the basin filling aspect of sculpting, it is generally safe to supply a very large negative energy here.<br/>
<h4><a class="NoHi" id="ELS_SHAVES"><b>ELS_SHAVES</b></a></h4>
If the <a href="keywords.html#SCULPT">energy landscape sculpting</a> method is in use, this keyword supplies the parameters
V<sub>i</sub><sup>s</sup> described <a href="keywords.html#SCULPT">above</a>. Values are to be provided in kcal/mol.
The interpretation is identical to keyword <a href="keywords.html#ELS_FILLS">ELS_FILLS</a> above. To disable the barrier
shaving aspect of sculpting, it is generally safe to supply a very large positive energy here.<br/>
<h4><a class="NoHi" id="ELS_ALPHA_F"><b>ELS_ALPHA_F</b></a></h4>
If the <a href="keywords.html#SCULPT">energy landscape sculpting</a> method is in use, this keyword supplies the parameters
&alpha;<sub>i</sub><sup>f</sup> described <a href="keywords.html#SCULPT">above</a>. Values are to be provided in kcal/mol and must be 
zero or positive. Note that a choice of zero inevitably leads to force discontinuities. In addition, the absence of any force
(flat surface) will lead to the natural shape of the landscape being completely forgotten, which can deteriorate the 
statistical significance of the reweighted results.<br/>
<h4><a class="NoHi" id="ELS_ALPHA_S"><b>ELS_ALPHA_S</b></a></h4>
If the <a href="keywords.html#SCULPT">energy landscape sculpting</a> method is in use, this keyword supplies the parameters
&alpha;<sub>i</sub><sup>s</sup> described <a href="keywords.html#SCULPT">above</a>. Values are to be provided in kcal/mol and must be 
zero or positive. The keyword is interpreted identically to <a href="keywords.html#ELS_ALPHA_F">ELS_ALPHA_F</a> above
and applies to the barrier shaving aspect.<br/>
 <h4><a class="NoHi" id="ELS_PRINT_WEIGHTS"><b>ELS_PRINT_WEIGHTS</b></a></h4>
If the <a href="keywords.html#SCULPT">energy landscape sculpting</a> method is in use, this keyword controls the output
frequency for output file <a href="outputfiles.html#ELS_WFRAMES.dat">ELS_WFRAMES.dat</a>, which contains
the corresponding simulation step numbers (that will of course increase in steps of ELS_PRINT_WEIGHTS)
and the associated weights. These weights are derived from knowledge of the applied net sculpting potential
for each snapshot as w<sub>i</sub> = exp(&beta; E<sub>ELS</sub>). They can be used in a <a href="keywords.html#PDB_ANALYZE">trajectory analysis</a>
run with <a href="keywords.html#FRAMESFILE">user-supplied frame weights</a>. Note that large positive values 
of the sculpting potential will make the reweighting susceptible to shot-like noise (due to few conformations receiving very large weights).<br/>
<h4><a class="NoHi" id="EWALD"><b>EWALD</b></a></h4>
CAMPARI supports using the Ewald decomposition technique to compute
long-range electrostatic interactions in periodic systems
(see <a href="keywords.html#LREL_MD">LREL_MD</a>).
There are two supported approaches to computing the reciprocal space
sums
in the Ewald formalism:<br/>
<ol>
  <li>Particle-Mesh Ewald (PME): This elegant and vastly popular method
introduced by <a href="references.html#ref9_1">Darden <i>et al.</i></a>
uses discrete Fourier transforms (DFFTs) and
cardinal B-splines to simplify the computation of the reciprocal space
sum.
Due to the DFFTs, CAMPARI needs to be linked against the free open
source-library
FFTW for this option to be available.
Briefly, PME reciprocal space sums have different scaling components,
i) the
number of charges; ii) the number of grid-points; iii) the
interpolation order
for the cardinal B-splines. It depends strongly on the system which of
these
components is the speed-limiting factor, in particular since the
accuracy of the reciprocal sum depends on the simultaneous optimization
of the spline order (see
    <a href="keywords.html#BSPLINE">BSPLINE</a>) and the grid-size (<a
 href="keywords.html#EWFSPAC">EWFSPAC</a>) given
that the real-space part co-determines the Ewald parameter (<a
 href="keywords.html#EWPRM">EWPRM</a>). Note,
however, that the fundamental scaling with the number of charges is
O(N). The performance of PME is only partially controlled
by CAMPARI as the library calls can be (and often are) the bottleneck. Coarser grids, higher
spline orders, and higher number densities of partial charges decrease the relative workload of the DFFTs.
The general performance of the DFFTs can sometimes be improved by providing or computing a better "plan".
This is supported by keywords <a href="keywords.html#EWFFTWPLANNER">EWFFTPLANNER</a> and
<a href="keywords.html#EWWISDOMFILE">EWWISDOMFILE</a>. 
If the <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization of CAMPARI</a> is in use,
this also triggers calling the threaded FFTW library. The performance of this call
is tricky to predict, however, because it is spawned from a multi-threaded execution region
to begin with (inside an OpenMP MASTER construct). This causes additional thread generation and destruction 
operations that are a cost factor, both directly and indirectly (through the kernel having to 
manage a temporarily oversubscribed machine). It implies that the performance
results become strongly dependent on the thread affinity model and respond to
environment variables such as OMP_PROC_BIND. Keyword <a href="keywords.html#THREADS_TEST">THREADS_TEST</a>
allows a quick way to test parallel FFTW performance for the system at hand. 
Irrespective of these complications, PME is the recommended (since fastest)
implementation of Ewald sums.<br/>
  </li>
  <li>Standard Ewald: A straightforward computation of the reciprocal
part
of the original decomposition introduced by Ewald is supported by
CAMPARI
as well. This method is slow and scales poorly (K<sup>3</sup>) with the
(linear) cutoff size in the reciprocal dimension. Much like PME,
the reciprocal sum fundamentally scales as O(N) with the number of
charges,
however. Standard Ewald might occasionally be a reasonably efficient alternative
should tight cutoffs in reciprocal space be permissible (or should PME be slowed
down due to a dominant cost imposed by DFFTs such as in very dilute systems using big boxes).
If the <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization of CAMPARI</a> is in use,
the standard Ewald sum is expected to scale well as long as the number of residues is reasonably large.</li>
</ol>
Note that any Ewald method is only accessible in dynamics calculations using
specialized loops at the moment. This is due to the underlying
assumptions (the real-space part uses a functional form that is different from simple Coulomb summation)
 as well as due to the lack of decomposability of the algorithm for the purpose of MC calculations
(→ <a href="keywords.html#LREL_MD">LREL_MD</a> for details). The real-space part relies on
the error function, which can be approximated by a tabulation with <a href="keywords.html#EWERFTOL">controllable
accuracy</a>.<br/>
<h4><a class="NoHi" id="EWERFTOL"><b>EWERFTOL</b></a></h4>
If the <a href="keywords.html#EWALD">Ewald method</a> is used for treating long-range electrostatic interactions,
this keyword can be used to set an accuracy tolerance for the tabulated computation of
the (complementary) error function (and its derivative). This uses additional tricks
to save operations (details omitted). Because the tabulated values can be a significant
amount, the performance of this implementation is usually cache- rather than FLOP-limited.
The tabulation can be disabled at the compilation stage by passing the variable "DISABLE_ERFTAB" (see <a href="install.html">installation instructions</a>)
as many modern compilers offer support for fast math libraries occasionally also with controllable
precision.<br/>
<h4><a class="NoHi" id="BSPLINE"><b>BSPLINE</b></a></h4>
When using the PME method (see <a href="keywords.html#LREL_MD">LREL_MD</a>
and
<a href="keywords.html#EWALD">EWALD</a>), this keyword determines the
order of
the cardinal B-splines to be used. The order can be increased at a
moderate cost, such that it is sometimes advantageous
to choose a higher interpolation order coupled to a relatively coarse
mesh (see <a href="keywords.html#EWFSPAC">EWFSPAC</a>)
instead of a lower interpolation order coupled to a finer mesh. The
default order is 6, and currently only even numbers are permitted (uneven numbers are adjusted to the default automatically).
For various reasons, it is not 
recommended to use orders below 4. In any case, it can be useful to try different settings
and study the predicted accuracy and initial energies that are reported at the beginning (summary of the calculation written
to log-output).<br/>
<h4><a class="NoHi" id="EWFSPAC"><b>EWFSPAC</b></a></h4>
When using the PME method (see <a href="keywords.html#LREL_MD">LREL_MD</a>
and
<a href="keywords.html#EWALD">EWALD</a>), this keyword determines the
grid
spacing for the mesh in Å. A smaller value yields a finer
mesh which in turn yields more accuracy. The cost
associated with finer grids easily becomes substantial (K<sup>3</sup>-scaling),
though, even
when using the DFFTs provided by FFTW. The code will occasionally
adjust too coarse a value since the interpolation order (<a
 href="keywords.html#BSPLINE">BSPLINE</a>) requires a certain minimum
for the number of available mesh points in each dimension. When
using the standard Ewald method, keyword EWFSPAC determines the
reciprocal space cutoffs to either side directly as the ratio of half the box side
length and itself. In any case, it can be useful to try different settings
and study the predicted accuracy and initial energies that are reported at the beginning (summary of the calculation written
to log-output).<br/>
<h4><a class="NoHi" id="EWPRM"><b>EWPRM</b></a></h4>
When using the Ewald method (see <a href="keywords.html#LREL_MD">LREL_MD</a>
and
<a href="keywords.html#EWALD">EWALD</a>), this can be used to overwrite
the
automatically determined value for the Ewald parameter. The Ewald
parameter is given in units of Å<sup>-1</sup> (but can
just as well be defined as a dimensionless parameter). It determines
the relative weight of the real-space and the
reciprocal sum in determining the total electrostatic energy of the
system. The larger <a href="keywords.html#EWPRM">EWPRM</a> is
the more weight shifts to the reciprocal sum. Note that the accuracy of
the Ewald method is highly sensitive to this parameter in conjunction
with the real-space and reciprocal space cutoffs and that a
catastrophic lack of accuracy can easily be realized. Therefore, the
code tries to determine a reasonable value for the Ewald parameter
based on the (hard) settings for the
real-space cutoff (<a href="keywords.html#NBCUTOFF">NBCUTOFF</a>) as
well as <a href="keywords.html#EWFSPAC">EWFSPAC</a> and - in the case
of the PME method - <a href="keywords.html#BSPLINE">BSPLINE</a>.
Unfortunately, the accuracy predictor formulas in use are currently
somewhat flawed
(they are based on the mean force error estimates presented by <a href="references.html#ref9_3">Petersen</a>).
They should be more accurate for the
standard Ewald method than for PME since in the
latter certain error contributions from the spline-based interpolation
are missing.
Hence, the automatically chosen parameter should by no means considered
an optimal
one, merely one which - given the cutoff settings - provides
comparatively small errors
in forces and energies. Should the procedure be deemed inadequate or
should there be an independent estimate of the error this keyword comes
into play. In any case, it can be useful to try different settings
and study the predicted accuracy and initial energies that are reported at the beginning (summary of the calculation written
to log-output).<br/>
<h4><a class="NoHi" id="EWFFTPLANNER"><b>EWFFTPLANNER</b></a></h4>
This keyword is only relevant if the particle-mesh Ewald is used (see 
<a href="keywords.html#LREL_MD">LREL_MD</a> and <a href="keywords.html#EWALD">EWALD</a>).
It can then be used to control how hard the linked FFTW library will try
to compute an efficient plan for the involved DFFTs <i>before</i> the start of
the simulation. The options are as follows:<br/>
<ol>
<li>A heuristic and practically cost-free estimate is used. For simple cases and geometries, this is often appropriate enough (corresponds to FFTW_ESTIMATE).</li>
<li>Explicit measurements are performed to pick a reasonable plan but the algorithmic space explored is limited (this is the default and corresponds to FFTW_MEASURE).</li>
<li>Explicit measurements are performed to pick a reasonable plan and the algorithmic space is widened relative to the previous option (corresponds to FFTW_PATIENT).</li>
<li>Many explicit measurements are performed across a wide algorithmic space to determine the best plan (this is very expensive and corresponds to FFTW_EXHAUSTIVE).</li>
<li>A previously determined plan is read in in the form of a "wisdom file" (see <a href="keywords.html#EWWISDOMFILE">EWWISDOMFILE</a>).</li>
</ol>
Since all options except 1 and 5 rely on explicit measurements, the cost of finding a plan can be significant in these cases.
Options 3 and 4 are really meant for unusual, for example very large, cases. If many simulations are to be performed
on the same system, it can be useful to reuse the planning information (option 5). For this, keywords 
<a href="keywords.html#EWWISDOMFILE">EWWISDOMFILE</a> and <a href="keywords.html#EWSAVEWISDOM">EWSAVEWISDOM</a> required.<br/>

<h4><a class="NoHi" id="EWSAVEWISDOM"><b>EWSAVEWISDOM</b></a></h4>
This keyword is only relevant if the particle-mesh Ewald is used (see 
<a href="keywords.html#LREL_MD">LREL_MD</a> and <a href="keywords.html#EWALD">EWALD</a>).
It instructs CAMPARI to save a <a href="keywords.html#EWFFTPLANNER">DFFT plan</a> generated by the FFTW library
in the form of a wisdom file. For this, the value for <a href="keywords.html#EWFFTPLANNER">EWFFTPLANNER</a> has to be 1-4. Note that
wisdom files are not compatible between the threaded and serial FFTW libraries.
The former is evoked automatically if the
<a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization of CAMPARI</a> is in use.
The name for the wisdom file is chosen by keyword <a href="keywords.html#EWWISDOMFILE">EWWISDOMFILE</a>.<br/>
<h4><a class="NoHi" id="EWWISDOMFILE"><b>EWWISDOMFILE</b></a></h4>
This keyword is only relevant if the particle-mesh Ewald is used (see 
<a href="keywords.html#LREL_MD">LREL_MD</a> and <a href="keywords.html#EWALD">EWALD</a>).
It provides the name for a FFTW wisdom file to be either read in (if <a href="keywords.html#EWFFTPLANNER">EWFFTPLANNER</a> is 5)
or written (if <a href="keywords.html#EWFFTPLANNER">EWFFTPLANNER</a> is not 5). Note that
the wisdom file is an autonomous output file of the FFTW library and not documented further
either here or in the  <a href="outputfiles.html">dedicated documentation</a>.
Users can find more information <a href="http://www.fftw.org/" target="_TOP">elsewhere</a> (links out).<br/>
<h4><a class="NoHi" id="RFMODE"><b>RFMODE</b></a></h4>
When using the Reaction-Field method (see <a
 href="keywords.html#LREL_MD">LREL_MD</a>), this keyword determines
whether the corrections include a continuum electrolyte assumption
(generalized reaction field) or not:<br/>
<ol>
  <li>The generalized reaction-field correction is used. The code
determines the concentration of net charges (including those which are
part of macromolecules) and derives an
effective ionic strength. This bulk electrolyte concentration is used
to model the dielectric response outside of the
cutoff sphere for an individual charge in a Poisson-Boltzmann sense.</li>
  <li>The standard reaction-field correction is used. Irrespective
of the existence of free, net charges in the system, the dielectric
response is simply an approximate solution to the Poisson equation.</li>
</ol>
Note that for a system void of net charges (purely polar), the
two methods are identical. Also note that the bulk dielectric of the
dipolar medium outside of the cutoff sphere is set by <a
 href="keywords.html#IMPDIEL">IMPDIEL</a>. The reaction field method produces
a force discontinuity at the <a href="keywords.html#ELCUTOFF">outer cutoff distance</a>
for all assumed dielectric constants smaller than infinity. The use of the method in conjunction
with twin-range cutoffs (<a href="keywords.html#NBCUTOFF">inner cutoff distance</a> is less than
<a href="keywords.html#ELCUTOFF">outer cutoff distance</a> and the
<a href="keywords.html#NBL_UP">neighbor list update frequency</a> is larger than one) is 
explicitly disallowed due to unpredictable and generally poor stability.<br/>
<br/>
<br/>
<br/>
<h3><a class="NoHi" id="cutoff_settings">Cutoff Settings:</a></h3>
<hr style="width: 100%; height: 2px;"></hr> (<a href="keywords.html#TOP">back to top</a>)<br/>
<h4><a class="NoHi" id="CUTOFFMODE"><b>CUTOFFMODE</b></a></h4>
If nonbonded interactions dependent on interatomic distances are in use (<a href="keywords.html#SC_IPP">IPP</a>, 
<a href="keywords.html#SC_ATTLJ">ATTLJ</a>, <a href="keywords.html#SC_WCA">WCA</a>,
<a href="keywords.html#SC_IMPSOLV">IMPSOLV</a>, <a href="keywords.html#SC_TABUL">TABUL</a>, and
<a href="keywords.html#SC_POLAR">POLAR</a>), it is often necessary to truncate 
these interactions. Historically, there have been a large number of implementations
to achieve this, both in how to to effectively determine the interactions to compute
and how to deal with the force discontinuity and truncation. CAMPARI does not implement
empirical switching functions. The <a href="keywords.html#SC_WCA">WCA</a> and <a href="keywords.html#SC_IMPSOLV">IMPSOLV</a>
potentials have exact cutoffs by virtue of their functional forms. <a href="keywords.html#SC_IPP">IPP</a>,
<a href="keywords.html#SC_ATTLJ">ATTLJ</a>, and <a href="keywords.html#SC_TABUL">TABUL</a> can only be truncated. 
Long-range electrostatics options are supported (<a href="keywords.html#LREL_MC">LREL_MC</a> and <a href="keywords.html#LREL_MD">LREL_MD</a>).
Keyword CUTOFFMODE controls whether to apply truncation at all and how to search for nearby
interaction partners. This is (currently) always done using residue-based, buffered neighbor
lists. The neighbor lists are in general not post-processed to achieve exact truncation at the chosen
distance, which means that the effective range of interactions is larger (dependent on the buffer size,
which are computed from residue radii).<br/>
All cutoff implementations are responsive to the <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> although
some particular combinations of samplers, cutoffs, and Hamiltonians may not be supported. In general,
the parallel efficiency of the neighbor lists calculations is acceptable. The major performance-limiting factor
is that relatively complex and large data structures are used in relation to relatively low number of
floating point operations, which can expose weaknesses in cache management.<br/>
The following modes are available:<br/>
<ol>
  <li>If - for whatever reason - cutoffs are undesirable, the code will
assume
that all residues are spatial neighbors and compute all
interactions at every step. Note that not all combinations of samplers and Hamiltonians
might support this option since
optimized loops relying on neighbor lists are often employed (and/or
the method may rely in its formulation on a cutoff). Limited support (or performance) may also
exist if the <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use.
It implies that most other keywords in this section become meaningless (<i>e.g.</i>,
<a href="keywords.html#NBCUTOFF">NBCUTOFF</a>, <a href="keywords.html#LREL_MD">LREL_MD</a>, <i>etc</i>.).</li>
  <li>This option is obsolete.</li>
  <li>This option instructs CAMPARI to employ grid-based cutoffs. The
grid-association
is governed at the residue level by the position of the residues'
reference atoms.
All grid-based methods (with a uniform mesh) are difficult/inefficient
for systems with very
asymmetric density (such as a single very long
extended chain in a large periodic box) since those systems would
either require too large grids
(inefficient and memory-consuming) or are so coarse
that no efficient pre-screening can occur. Grid-based cutoffs are a
good choice for
systems with homogeneous density and many small (few atoms) residues.
They are absolutely indispensable for simulations of large explicit
water systems as any
other cutoff mode supported by CAMPARI will critically slow down
simulations
in such scenarios. Like all cutoffs in CAMPARI, the grid is used with a
buffer size dependent on residue radii (in addition to the actual interaction 
cutoffs, <i>viz.</i>, <a href="keywords.html#NBCUTOFF">NBCUTOFF</a> and
<a href="keywords.html#ELCUTOFF">ELCUTOFF</a>). The parameters of the grid are controlled using a number of keywords:
<a href="keywords.html#GRIDDIM">GRIDDIM</a>, <a href="keywords.html#GRIDMAXGPNB">GRIDMAXGPNB</a>, and
 <a href="keywords.html#GRIDMAXRSNB">GRIDMAXRSNB</a>. If the <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a>
is used, the performance of grid-based cutoffs is hampered if residues are reassigned frequently,
which happens in many Monte Carlo calculations (all trial moves matter, not just the accepted ones).
This is because the global copy of the grid association must be kept in sync.<br/>
</li>
  <li>The last available option instructs CAMPARI to employ
topology-assisted cutoffs.
Here, interatomic distances are simply pre-screened by a
master value for the two reference atoms of residue pairs.
This takes advantage of molecular topology to simplify the generation
of
spatial neighbor lists since only residues which pass the pre-screen
are
assumed to be spatial neighbors. Note that the program
will compare the distance between the two reference atoms to the sum of
the cutoff and the effective radii of the two
residues in questions. These radii are currently hard-coded. This mode
is the method of choice for systems with
heterogeneous density and/or large (many atoms) but relatively few
(&lt;1000) residues.
Note that in the presence of non-bonded interactions method 3
reduces the scaling of CPU time with
system size from <i>N</i><sup>2</sup> to something considerably faster
(where <i>N</i> is the number of atoms). Method 4 does not change the scaling behavior
but reduces the constant factor for this cost dramatically (by experience, for a water box
of ~1000 molecules, mode 4 is still slightly faster). 
This option should generally perform well in conjunction with the <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a>
of CAMPARI.</li>
</ol>
Note that the structure of neighbor lists differs. In gradient-based calculations (&rarr; <a href="keywords.html#DYNAMICS">DYNAMICS</a>),
they are residue-based. In Monte Carlo calculations they reflect the incremental energy calculation
necessary and are explicit pair lists. There is always an overhead in managing interaction lists when
the <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use.<br/> 
<h4><a class="NoHi" id="NBCUTOFF"><b>NBCUTOFF</b></a></h4>
If <a href="keywords.html#CUTOFFMODE">cutoffs of nonbonded interactions</a> have been requested,
this keyword sets the interaction range for a part of the nonbonded interactions.
It is interpreted differently dependent on the type of calculation:<br/>
<ol style="list-style-type: lower-roman;">
  <li>For Monte Carlo calculations (see <a href="keywords.html#DYNAMICS">DYNAMICS</a>),
it
simply sets the non-bonded (<a href="keywords.html#SC_IPP">IPP</a>, 
<a href="keywords.html#SC_ATTLJ">ATTLJ</a>, <a href="keywords.html#SC_WCA">WCA</a>, and 
<a href="keywords.html#SC_IMPSOLV">IMPSOLV</a>) cutoff in Å. Neighbor lists are populated based on 
this value, and exact truncation is performed unless keyword
<a href="keywords.html#MCCUTMODE">MCCUTMODE</a> is set differently from the default.
All the potentials governed by NBCUTOFF
should conceptually be short-range in nature.</li>
  <li>For gradient-based calculations, it defines the short-range
regime, within which all interactions and forces are computed at <i>every</i>
time step. It never truncates said interactions at a distance of NBCUTOFF Å
(<i>i.e.</i>, there is no equivalent of keyword <a href="keywords.html#MCCUTMODE">MCCUTMODE</a> for
gradient-based calculations). These types of cutoffs are residue-based and use buffered
neighbor lists, which means that the true interaction range is larger than the value specified
(unless the simulation involves only monoatomic molecules).</li>
</ol>
Note that because of the differences in interpretation, hybrid calculations
(&rarr; <a href="keywords.html#DYNAMICS">DYNAMICS</a>) are mutually consistent only with
a subset of possible choices, <i>i.e.</i>, by setting NBCUTOFF and <a href="keywords.html#ELCUTOFF">ELCUTOFF</a>
to the same value and by letting <a href="keywords.html#MCCUTMODE">MCCUTMODE</a> be 2.<br/>
<h4><a class="NoHi" id="ELCUTOFF"><b>ELCUTOFF</b></a></h4>
If <a href="keywords.html#CUTOFFMODE">cutoffs of nonbonded interaction</a> have been requested,
this keyword sets the interaction range for the remainder of the nonbonded interactions
(not covered keyword <a href="keywords.html#NBCUTOFF">NBCUTOFF</a>).
It is interpreted differently dependent on the type of calculation:<br/>
<ol style="list-style-type: lower-roman;">
  <li>For MC calculations (see <a href="keywords.html#DYNAMICS">DYNAMICS</a>),
it
simply sets the second non-bonded (<a href="keywords.html#SC_TABUL">TABUL</a> and
<a href="keywords.html#SC_POLAR">POLAR</a>) cutoff in Å.
All the potentials governed by ELCUTOFF
are potentially long-range
in nature. Note that interactions beyond this second cutoff, which are
Coulomb terms involving moieties flagged as carrying a net charge,
are potentially still calculated (see <a href="keywords.html#LREL_MC">LREL_MC</a>).</li>
  <li>For gradient-based calculations, it defines the mid-range
regime,
within which all interactions and forces are computed accurately, but
only every <b>n</b><sup>th</sup> time step, <i>i.e.</i>, at a lower
frequency which is set
by the neighbor list update frequency (see <a
 href="keywords.html#NBL_UP">NBL_UP</a>). It truncates said
interactions at a distance of ELCUTOFF
unless they involve long-range electrostatic corrections (in particular
in cases involving Coulomb terms involving moieties flagged as carrying a net charge).
The twin-range terms (forces and energies stemming from particle pairs
with distances between <a href="keywords.html#NBCUTOFF">NBCUTOFF</a>
and ELCUTOFF Å)
are assumed to be approximately constant for the number of steps
between neighbor list
updates. Twin-range cutoffs are explicitly disallowed for the <a href="keywords.html#EWALD">Ewald</a> and
<a href="keywords.html#RFMODE">reaction-field</a> methods. 
If CAMPARI computes additional interactions, <i>i.e.,</i> if <a href="keywords.html#LREL_MD">LREL_MD</a>
is either 4 or 5,
these interactions are subjected to the same assumption for forces and
energies (particle pairs with distances beyond ELCUTOFF Å).</li>
</ol>
Note that because of the differences in interpretation, hybrid calculations
(&rarr; <a href="keywords.html#DYNAMICS">DYNAMICS</a>) are mutually consistent only with
a subset of possible choices, <i>i.e.</i>, by setting ELCUTOFF to the same value as <a href="keywords.html#NBCUTOFF">NBCUTOFF</a>.
The long-range interactions covered by this keyword are never truncated exactly (with the exception
of the <a href="keywords.html#RFMODE">reaction-field method</a> available in dynamics) but rely
on a residue-level parsing (buffered neighbor lists). This ensures that cutoff artifacts due to
breaking neutral groups (&rarr; <a href="keywords.html#SC_POLTOL">POLTOL</a>) are avoided,
but it does increase the effective interaction range (based on the buffer sizes, which are calculated
from the effective residue radii).<br/>
<h4><a class="NoHi" id="MCCUTMODE"><b>MCCUTMODE</b></a></h4>
When using nonbonded interaction potential in conjunction with <a href="keywords.html#CUTOFFMODE">cutoffs</a>,
<a href="keywords.html#DYNAMICS">Monte Carlo calculations</a> typically 
truncate short-range interactions (<a href="keywords.html#SC_IPP">IPP</a>, <a href="keywords.html#SC_ATTLJ">ATTLJ</a>,
<a href="keywords.html#SC_WCA">WCA</a>, and (usually not an issue) <a href="keywords.html#SC_IMPSOLV">DMFI</a>)
exactly at the <a href="keywords.html#NBCUTOFF">cutoff distance</a>.
Conversely, in <a href="keywords.html#DYNAMICS">gradient-based calculations</a>,
the cutoff on short-range terms is always used exclusively to populate the corresponding neighbor lists.
These two settings are not identical except for pairs of single
atom residues. Keyword MCCUTMODE can be used to switch from the default (mode 1) to the same residue-level exclusion approach
as in dynamics calculations (mode 2). This is essential for achieving exactly the same Hamiltonian in hybrid MC/MD calculations
or for <a href="keywords.html#CHECKGRAD">gradient testing</a>.<br/>
<h4><a class="NoHi" id="NBL_UP"><b>NBL_UP</b></a></h4>
This keyword provides the update frequency for neighbor lists in
<a href="keywords.html#DYNAMCS">gradient-based calculations</a>. Every NBL_UP<sup>th</sup> step, it is recalculated which
residues are within a distance of <a href="keywords.html#NBCUTOFF">NBCUTOFF</a>
Å (short-range) and which ones are within a distance of
<a href="keywords.html#ELCUTOFF">ELCUTOFF</a> Å (mid-range). Interactions with the former
are computed at every time step explicitly and those with the latter are computed only every NBL_UP<sup>th</sup>
step explicitly. For interactions outside of either cutoff, truncation
occurs unless the electrostatic model chosen provides
a long-range term (see <a href="keywords.html#LREL_MD">LREL_MD</a>).
These latter interactions will then be recomputed at the same
frequency as the mid-range ones (with the exception of the reciprocal space sum
in <a href="keywords.html#EWALD">Ewald</a> methods which is always computed
at every step). Note that this keyword is irrelevant if <a
 href="keywords.html#CUTOFFMODE">CUTOFFMODE</a>
is set to 1, a setting useful only for debugging purposes.<br/>
The assumptions made by this keyword are rather aggressive, and it is therefore
recommended to use it with caution. Specifically, the neighbor lists here 
should not be thought of as "buffered" in any way. The integrator noise
accumulating by setting this to something large can be quite substantial, and
should probably be offset by a large choice for the outer cutoff distance
(&rarr; <a href="keywords.html#ELCUTOFF">ELCUTOFF</a>). Conversely, the use of residue-level
neighbor list with large effective radii tends to bloat the effective cutoff
radius, which creates something akin to an effective buffer zone. This implementation may
be changed in the future.<br/>
<h4><a class="NoHi" id="LREL_MC"><b>LREL_MC</b></a></h4>
This keyword determines CAMPARI's method of handling long-range
electrostatic interactions in MC
calculations. There are currently several options for this with more
being added in the future. A general problem is hidden in the fact that
MC calculations have to be able to compute relative energies of
drastically different configurations at every step
such that similarity assumptions cannot be used to speed up the
calculations as is the case in MD/LD/BD.<br/>
<ol>
  <li>All monopole-dipole and monopole-monopole interactions
are computed explicitly (at full atomic resolution). By default, the governing factor is the parser for the
partial charge sets which determines the individual charge groups
(see <a href="keywords.html#ELECMODEL">option 2 for ELECMODEL</a> and 
output files <a href="outputfiles.html#DIPOLE_GROUPS.vmd">DIPOLE_GROUPS.vmd</a>
and <a href="outputfiles.html#MONOPOLES.vmd">MONOPOLES.vmd</a>). Those
with a total charge exceeding a <a href="keywords.html#POLTOL">threshold</a>
(usually zero) are considered "net charges", and those without are
considered "dipoles". The flagging is at the residue level, and can be overwritten
by a <a href="keywords.html#NCPATCHFILE">dedicated patch facility</a>.
Interactions between dipole groups are skipped even if one or both of the participating
residues are flagged. For large systems, the number of interactions can grow 
dramatically of course. Using this option also requires allocation of a potentially
large matrix if <a href="keywords.html#CUTOFFMODE">grid-based cutoffs</a> are in use,
which can hamper <a href="keywords.html#NRTHREADS">parallel performance</a>.</li>
  <li>All monopole-monopole interactions
are computed explicitly (at full atomic resolution). As in the option above,
the flagging is at the residue level, and here both residues are required to be
flagged. Dipole-dipole and dipole-monopole interactions are skipped even if both of the participating
residues are flagged. For plasmas or ionic liquids or concentrated ionic solutions,
the number of interactions can become prohibitively large of course. It also requires allocation of a potentially
large matrix if <a href="keywords.html#CUTOFFMODE">grid-based cutoffs</a> is in use,
which can hamper <a href="keywords.html#NRTHREADS">parallel performance</a>.</li>
  <li>This is identical to the previous option except that monopole-monopole
terms are computed at a reduced resolution, <i>viz.</i>, polyatomic monopole groups are represented
by collapsing the total charge onto a single atom, which is nearest to the true monopole center.
This choice is currently the default. The same caveats as for option 2 apply.</li>
  <li>No additional interactions are computed (rigorous truncation).</li>
</ol>
Note that for systems having no residues that are flagged as carrying a net charge
 this keyword is irrelevant. Note also that none of the
approaches is rigorously feasible for a system in which the dielectric response of
the system is primarily described by explicitly represented dipolar units (such as a
calculation in explicit water) if charges are present. The reason is that
dipole-dipole terms and in particular monopole-dipole
terms are crucial in modelling the dielectric response, and options
like 2 or 3 above will hence generate a dielectric
mismatch outside of the second cutoff. For straight truncation (option
4), drastic artifacts are observed in which density of like-charged species
accumulates just outside of the second cutoff
(<a href="keywords.html#ELCUTOFF">ELCUTOFF</a>). Conversely, for 1), 2)
or 3) above, inverted
artifacts are observed in which like-charged species accumulate inside
the cutoff sphere and form favorable long-range
interactions with other quasi-macroions (charge separation occurs).
Such problems usually disappear if there is no
dipolar fluid exerting a dielectric response (such as in a plasma) or
if the dielectric response is exerted through a continuum.<br/>
Note that periodic boundary
conditions are mutually inconsistent with any of the above treatments
with the exception of truncation. This is because in <a href="keywords.html#BOUNDARY">PBC</a> the largest effective cutoff value
for nonbonded interactions must not exceed half of the smallest linear dimension of the box.
In case of a <a href="keywords.html#DYNAMICS">hybrid sampler</a>, the values for LREL_MC and
<a href="keywords.html#LREL_MD">LREL_MD</a> should be matched to achieve a consistent
Hamiltonian. Compatible values are 1/5 and 3/4, and 4/1 (LREL_MC/<a href="keywords.html#LREL_MD">LREL_MD</a>).<br/>
<h4><a class="NoHi" id="LREL_MD"><b>LREL_MD</b></a></h4>
Much like <a href="keywords.html#LREL_MC">LREL_MC</a>, this keyword
controls how CAMPARI handles
long-range electrostatic interactions in gradient-based calculations
calculations. There are currently several options for this which are
generally different from those available for
Monte Carlo runs since two core assumptions are true for dynamics
calculations; i) only global energy/force
evaluations are needed; and ii) the system remains self-similar through
several integration steps. The options are as follows:<br/>
<ol>
  <li>No additional interactions are computed, <i>i.e.</i>,
everything beyond the mid-range cutoff is discarded. This
setting
can be used along with <a href="keywords.html#LREL_MC">LREL_MC</a> set
to 4
and <a href="keywords.html#ELCUTOFF">ELCUTOFF</a> being equal to <a
 href="keywords.html#NBCUTOFF">NBCUTOFF</a> to create an exact match
between
dynamics and MC Hamiltonians which may be relevant for hybrid
calculations
(→ <a href="keywords.html#DYNAMICS">DYNAMICS</a>).</li>
  <li>Ewald summation is used, which relies on periodic
boundary conditions,and (currently) cubic boxes (→ <a
 href="keywords.html#BOUNDARY">BOUNDARY</a> and
    <a href="keywords.html#SHAPE">SHAPE</a>). This technique relies
on the decomposition of an infinite sum over all periodic images into
two quickly convergent contributions, a
real-space and a reciprocal space part. The real-space part involves a
modified Coulomb interaction, which therefore
requires separate loops. Hence, support for Ewald sums is currently
limited to "gas-phase"-type calculations
with nonbonded interactions corresponding to Lennard-Jones and polar interactions only.
Even though possible in theory, there is currently no support for 
the <a href="keywords.html#GHOST">ghosting of interactions</a>, which is used in the context
of free energy calculations.
The reciprocal space part can be solved in a number of
different ways (see <a href="keywords.html#EWALD">EWALD</a> and
associated keywords). Note that the two cutoffs are collapsed into the
shorter one (there is no mid-range regime) when using Ewald techniques. Both
the real-space and the reciprocal sums are recomputed at every step.
Ewald summation replaces the standard Coulomb term and is
relevant for all polar interactions even in the absence of full charges. It
always requires the error function and a tabulated approximation exists in case the 
built-in variant is too slow (see <a href="install.html">installation instructions</a> &rarr; DISABLE_ERFTAB
and keyword <a href="keywords.html#EWERFTOL">EWERFTOL</a>).</li>
  <li>The (generalized) reaction-field correction is used. The mode is picked 
with keyword <a href="keywords.html#RFMODE">RFMODE</a>.
This involves a modified Coulomb sum and relies on the assumption that
truncation can be dealt with by assuming that
a low dielectric cutoff sphere is embedded in a high dielectric
medium, which gives rise to a reaction-field correction, which lets the
force on a charge vanish at
the cutoff distance if the difference in
dielectric constants is large. The high dielectric is set with keyword <a href="keywords.html#IMPDIEL">IMPDIEL</a>,
and the size of the cutoff sphere is given by <a href="keywords.html#ELCUTOFF">ELCUTOFF</a>.
This method requires modified Coulomb
interactions and support for the type of nonbonded interactions is limited similar to Ewald sums except
that the <a href="keywords.html#GHOST">ghosting of interactions</a> is supported for net neutral
solutes.
Note that reaction-field corrections assume dielectric homogeneity, <i>i.e.</i>,
the underlying theory breaks
down if the effective dielectric inside or outside the cutoff sphere
might become inhomogeneous. The latter
is always the case, if, for example, a large enough macromolecule is
present or
if the system is non-periodic. Note that
algorithmically this is not a long-range correction and that
(G)RF-corrected terms are computed with the same
frequency as short- and mid-range terms are (see <a
 href="keywords.html#NBCUTOFF">NBCUTOFF</a> and <a href="keywords.html#ELCUTOFF">ELCUTOFF</a>).
Due to stability issues, twin-range cutoffs are not allowed for
reaction-field methods. Even then, the force discontinuity 
at the <a href="keywords.html#ELCUTOFF">cutoff distance</a> (vanishes only 
if the dielectric is assumed to be infinite) may cause more noise than a simple truncation scheme (option 1).
The reaction-field solution replaces
the standard Coulomb term, <i>i.e.</i>, it is relevant for all polar
interactions even in the absence of full charges.</li>
  <li>The same option as 3) in <a href="keywords.html#LREL_MC">LREL_MC</a>.
The same rules and caveats apply. By matching the methods this way and setting the
two cutoff criteria equal to one another, this allows a consistent
choice of Hamiltonian in hybrid runs (→ <a href="keywords.html#DYNAMICS">DYNAMICS</a>). This option is currently
the default choice.</li>
  <li>The same option as 1) in <a href="keywords.html#LREL_MC">LREL_MC</a>.
The
same rules and caveats apply. By matching the methods this way and setting the
two cutoff criteria equal to one another, this allows a consistent
choice of Hamiltonian in hybrid runs (→ <a href="keywords.html#DYNAMICS">DYNAMICS</a>).</li>
</ol>
Note that periodic boundary conditions are mutually inconsistent with the above options 4 and 5
because in <a href="keywords.html#BOUNDARY">PBC</a> the largest effective cutoff value
for nonbonded interactions must not exceed half of the smallest linear dimension of the box.<br/>
<h4><a class="NoHi" id="GRIDDIM"><b>GRIDDIM</b></a></h4>
If grid-based cutoffs are in use (→ <a href="keywords.html#CUTOFFMODE">CUTOFFMODE</a>),
this keyword allows the user to specify the three integers determining the
x,y,z dimensions for the rectangular cutoff grid. The origin and the size of the grid
are determined by the box parameters (see <a href="keywords.html#BOUNDARY">BOUNDARY</a>
and <a href="keywords.html#SHAPE">SHAPE</a>). In a droplet boundary condition, the grid
cannot be aligned with the simulation container exactly, and parts of it are wasteful. The 
extra buffer space is computed automatically, and this may lead to crashes of CAMPARI complaining
that a part of the system is "off the grid". This most often occurs with an unstable (exploding) simulation
but can also happen if <a href="keywords.html#BOUNDARY">a residue-based boundary condition</a> is used
in conjunction with bulky residues or if the <a href="keywords.html#SOFTWALL">restraining force</a>
is very small.<br/>
The total number of grid
points should not be so large that operations scaling linearly with this number
become a contribution of significant computational cost. Setting the size of the grid cells
equal to the cutoff is typically not an effective strategy due to the
requirement of having large margins. The latter are a result of the residue-based grid
association CAMPARI uses which requires accounting for the effective
residue radii in determining spatial neighbor relationships via the grid.<br/>
<h4><a class="NoHi" id="GRIDMAXRSNB"><b>GRIDMAXRSNB</b></a></h4>
If grid-based cutoffs are in use (→ <a href="keywords.html#CUTOFFMODE">CUTOFFMODE</a>),
this keyword allows the user to specify an initial limit for the maximum
number of residues associated with a single grid point. Arrays are dynamically
re-sized during the simulation but if the initial setup fails already, an error
is returned (see also <a href="keywords.html#GRIDMAXGPNB">GRIDMAXGPNB</a>). This 
keyword is required mostly so CAMPARI has a realistic estimate of the required memory at the beginning.<br/> 
<h4><a class="NoHi" id="GRIDMAXGPNB"><b>GRIDMAXGPNB</b></a></h4>
If grid-based cutoffs are in use (→ <a href="keywords.html#CUTOFFMODE">CUTOFFMODE</a>),
static grid-point neighbor lists are set up initially and used to simplify the
generation of neighbor-lists using the grid. This keyword specifies the
maximum number of grid-point neighbors each grid-point may possess. If the
number is too small, the program will fail during the initial setup. This is again to avoid
inadvertent memory emergencies (as for <a href="keywords.html#GRIDMAXRSNB">GRIDMAXRSNB</a>).<br/>
It can be annoying to find an acceptable value for this keyword as the distance range depends on the
system and the grid. For a big system, it may be advisable to use a temporary
<a href="inputfiles.html#FMCSC_SEQFILE">sequence file</a> with just the largest residue present to speed
up the remainder of the initial setup. Once a proper value has been found for GRIDMAXGPNB,
the real sequence can be restored and <a href="keywords.html#GRIDMAXRSNB">GRIDMAXRSNB</a> can
be calculated relatively easily.<br/>
<h4><a class="NoHi" id="GRIDREPORT"><b>GRIDREPORT</b></a></h4>
If grid-based cutoffs are in use (→ <a href="keywords.html#CUTOFFMODE">CUTOFFMODE</a>),
this simple logical instructs CAMPARI to write out a summary of the initial
grid occupation statistics.<br/>
<h4><a class="NoHi" id="CHECKFREQ"><b>CHECKFREQ</b></a></h4>
This keyword is interpreted differently dependent on the type of
calculation. In pure <a href="keywords.html#DYNAMICS">gradient-based simulations</a>,
CHECKFREQ simply sets the interval for how often to report global ensemble variables to log output.
This can be useful to track simulation progress and make sure that no unexpected behavior (instability) occurs.
This output overlaps with output file <a href="outputfiles.html#ENSEMBLE.dat">ENSEMBLE.dat</a>.
There is no significant cost incurred by this reporting as the relevant numbers have been
computed anyway. In <a href="keywords.html#PDBANALYZE">trajectory analysis runs</a>, CHECKFREQ is ignored.
For monitoring the progress of processing large input data sets, keyword
<a href="keywords.html#FLUSHTIME">FLUSHTIME</a> can be used instead.<br/>
CHECKFREQ takes on a more important role in  <a href="keywords.html#DYNAMICS">Monte Carlo calculations</a>
or the MC stretches of hybrid sampling runs. Here, it specifies the interval (in <a href="keywords.html#NRSTEPS">elementary steps</a>)
how often to recompute the total energy globally. This number is compared to the incremental
energy obtained from the energy updates for individual MC moves (which do not compute the global nonbonded energy).
The global value supersedes the incremental one (<i>i.e.</i>, it is a reset). The numerical drift error 
from the incremental calculations is usually very small. Thus, the reference energy can be chosen
to be either the same as what propagates the Markov chain (affected by keyword <a href="keywords.html#CUTOFFMODE">CUTOFFMODE</a>
and all associated choices) or it can be chosen as the N<sup>2</sup> sum assuming a lack of cutoffs.
This is controlled by keyword <a href="keywords.html#N2LOOP">N2LOOP</a>. The choice of reference energy 
has no implications for the Markov chain but can (and usually does) affect absolute energy values.
This may be relevant for certain <a href="keywords.html#GHOST">free energy calculations</a>, for comparisons
of simulation results obtained with different <a href="keywords.html#NBCUTOFF">cutoff lengths</a>, <i>etc.</i>
Whenever absolute energies need to be comparable, it is best that that <a href="keywords.html#N2LOOP">N2LOOP</a>
is set to zero. If it is not zero and the <a href="keywords.html#CUTOFFMODE">cutoff-assisted</a>
and N<sup>2</sup> energies differ, the cutoff-sensitive values reported to output file
<a href="outputfiles.html#ENERGY.dat">ENERGY.dat</a> will begin to deviate within each
interval of CHECKFREQ steps. In this case, consistent output to <a href="outputfiles.html#ENERGY.dat">ENERGY.dat</a> is achievable
only if <a href="keywords.html#ENOUT">ENOUT</a> is a multiple of CHECKFREQ.
The drifting inconsistency in each interval is precisely what was the original motivation of the output, <i>i.e.</i>,
to understand the magnitude of cutoff effects and to be able to diagnose the correctness
of incremental energy calculations. As an additional function, if <a href="keywords.html#CUTOFFMODE">cutoffs are turned on</a> and
<a href="keywords.html#N2LOOP">N2LOOP</a> has not been set to zero, a sanity
check is performed as well, <i>i.e.</i> given the current structure, are the derived interactions
in fact complete given the chosen maximum cutoff distance set by <a href="keywords.html#ELCUTOFF">ELCUTOFF</a>?
If not, this would most likely mean that the parameters used for deriving the list
of relevant interactions (specifically, the maximum residue radii) are inappropriate
(this can happen for simulations of unsupported residues).<br/>
Because both the N<sup>2</sup> energy evaluation and the cutoff check can be extremely slow for 
large systems, low frequencies are highly recommended for these cases especially if <a href="keywords.html#N2LOOP">N2LOOP</a> is not zero.<br/>
<h4><a class="NoHi" id="N2LOOP"><b>N2LOOP</b></a></h4>
This keyword is a simple logical which allows the user control over
whether or not to compute the full N<sup>2</sup>-loop of non-bonded interactions (on by
default) as a reference.
In pure <a href="keywords.html#DYNAMICS">gradient-based simulations</a>, this number
is reported initially only for information purposes but serves no other function. Setting
N2LOOP to zero disables this initial calculation, which can be very slow for large systems,
in particular as it does not benefit from the <a href="keywords.html#NRTHREADS">OpenMP parallelization</a>.
In <a href="keywords.html#RESTART">restarted</a> calculations of this type, N2LOOP never comes into play.
In <a href="keywords.html#PDBANALYZE">trajectory analysis runs</a>, N2LOOP has no effect even
if energies only are calculated (<a href="keywords.html#DYNAMICS">DYNAMICS</a> is 1).<br/>
The primary use of N2LOOP is to choose the reference energy in Monte Carlo calculations
(see <a href="keywords.html#CHECKFREQ">CHECKFREQ</a>). When turned on (default), MC simulations
will continuously reset the total energy to the cutoff-free value. When it is turned off (zero),
they will reset the total energy to the user-selected cutoff scheme (which can be the same of course &rarr;
<a href="keywords.html#CUTOFFMODE">CUTOFFMODE</a>). This happens at regular intervals
of <a href="keywords.html#CHECKFREQ">CHECKFREQ</a> steps. If N2LOOP is set to zero, it will
additionally suppress the sanity check
procedure for cutoffs. Note that the Markov chain of MC calculations is unaffected by 
this keyword (it corresponds to a shift of the arbitrary zero point). In particular in <a href="keywords.html#DYNAMICS">hybrid samplers</a>,
N2LOOP should probably be 0 to avoid confusion. It is important to keep in mind that,
whatever the context, the N<sup>2</sup> sum of nonbonded energies may not be a useful
reference state, especially in <a href="keywords.html#BOUNDARY">periodic boundary conditions</a>.<br/>
<h4><a class="NoHi" id="USESCREEN"><b>USESCREEN</b></a></h4>
This logical keyword applies to all Monte Carlo elementary moves (except
<a href="keywords.html#PARTICLEFLUCFREQ">particle deletion moves</a>). The
normal sequence of events in CAMPARI is:
<ol>
<li>Perturb configuration.</li>
<li>Compute short-range terms for moving parts for new conformation.</li>
<li>Compute corresponding long-range terms.</li>
<li>Restore original conformation.</li>
<li>Compute short-range terms for moving parts for original conformation.</li>
<li>Compute corresponding long-range terms.</li>
<li>Evaluate Metropolis criterion.</li>
<li>Process acceptance or rejection.</li>
</ol>
Often it will be possible to detect already after step 2 that the new conformation
produces a steric clash. Therefore, when USESCREEN is turned on, CAMPARI
will build in an energy screen after step 2, which can serve to
quickly eliminate those conformations (acceptance probability will often be numerically
too small to even be representable in floating-point format). 
This premature termination of the sequence above is sought to shorten the overall runtime. The height
of the screen is set by keyword <a href="keywords.html#BARRIER">BARRIER</a>. Note that
the above sequence of events is incomplete for certain types of 
<a href="keywords.html#CRFREQ">concerted rotation</a> moves.<br/>
From the above, it is clear that at step 2 we do not yet have access to a difference in energies (which
is only available after step 5). Consequently, this quantity is simply compared to the net value of the
short-range energy terms (→ <a href="keywords.html#SC_IPP">SC_IPP</a>, <a
 href="keywords.html#SC_ATTLJ">SC_ATTLJ</a>,
<a href="keywords.html#SC_WCA">SC_WCA</a>, <a href="keywords.html#SOFTWALL">boundary interactions</a>, 
<a href="keywords.html#SC_BONDED_B">SC_BONDED_B</a>, <a href="keywords.html#SC_BONDED_B">SC_BONDED_A</a>,
<a href="keywords.html#SC_BONDED_B">SC_BONDED_I</a>, <a href="keywords.html#SC_BONDED_B">SC_BONDED_T</a>,
<a href="keywords.html#SC_EXTRA">SC_EXTRA</a>), and certain bias terms 
(&rarr; <a href="keywords.html#SC_ZSEC">SC_ZSEC</a>, <a href="keywords.html#SC_POLY">SC_POLY</a>,
<a href="keywords.html#SC_DSSP">SC_DSSP</a>, <a href="keywords.html#SC_EMICRO">SC_EMICRO</a>,
<a href="keywords.html#SC_DREST">SC_DREST</a>). With the exception of 
<a href="keywords.html#SC_ATTLJ">SC_ATTLJ</a>, <a href="keywords.html#SC_WCA">SC_WCA</a>,
<a href="keywords.html#SC_BONDED_T">SC_BONDED_T</a>, and <a href="keywords.html#SC_BONDED_I">SC_BONDED_I</a>,
these are all strictly penalty terms that can only yield positive contributions to the total energy.
Because of the above, the screen is most useful if <a href="keywords.html#SC_IPP">SC_IPP</a> is used.
Inverse power potentials diverge for small distance and can yield arbitrarily large values, which allow
meaningful choices for the associated keyword <a href="keywords.html#BARRIER">BARRIER</a>.
If all aforementioned terms are either zero or negative, the screen will not have any effect.
Harmonic potentials (as used in most of the bias terms) can also yield very large values,
but the likelihood of this happening during simple MC moves is very small except for
<a href="keywords.html#SC_DREST">SC_DREST</a>, <a href="keywords.html#SC_BONDED_B">SC_BONDED_B</a>,
and <a href="keywords.html#SC_BONDED_B">SC_BONDED_A</a> (for the latter two terms, this
only holds in the presence of <a href="keywords.html#CRLK_MODE">soft crosslinks</a>).
Therefore, the difficult cases are those, for which the penalty terms are generally high, but
do not necessarily vary quickly or strongly upon MC moves. It may then become impossible
to use a simplification of this type, <i>i.e.</i>, if the chosen  <a href="keywords.html#BARRIER">screen height</a>
is too small, the Markov chain will be corrupted, and if it is made larger, the screen
no longer has any effect. To buffer against incorrect use of the method, there is 
an additional criterion that the incremental energy must exceed twice the total system energy
(for typical interaction potentials and an equilibrated system, the latter is often a negative number,
and this condition becomes trivially fulfilled). <br/>
Note that this technique assumes that the Markov chain remains unperturbed even though the actual acceptance
criterion is circumvented. Depending on the setting for <a href="keywords.html#BARRIER">BARRIER</a>, this will
often be rigorously true for a finite-length simulation. Because the same threshold is used
for all types of moves, the efficacy of the screen is likely move type-dependent. Finally, 
simulations using the <a href="keywords.html#MC_ACCEPT">Wang-Landau acceptance criterion</a>
may not be able to use this technique (a warning is printed in any case).<br/>
<h4><a class="NoHi" id="BARRIER"><b>BARRIER</b></a></h4>
This keyword is used in two different contexts. First, Monte Carlo
moves can take advantage of a cutoff-like screen eliminating proposed
conformations after only a partial evaluation of the relevant energy terms.
(this is enabled with <a href="keywords.html#USESCREEN">USESCREEN</a>). Then,
BARRIER sets the energy threshold (screen height, cutoff value, barrier) in kcal/mol.<br/>
Second, the value of BARRIER in kcal/mol is used as the hard-sphere penetration penalty
in the hard-sphere excluded-volume implementation (enabled by setting
<a href="keywords.html#IPPEXP">IPPEXP</a> to a sufficiently large value).<br/>
<br/>
<br/>
<br/>
<h3><a class="NoHi" id="MPI_settings">Parallel Settings: MPI (Multi-Copy) Parallelism (Replica exchange (REX), PIGS, and MPI Averaging)
and OpenMP Parallelism (Task Decomposition):</a></h3>
<hr style="width: 100%; height: 2px;"></hr> (<a href="keywords.html#TOP">back to top</a>)<br/>
<h4><i>Preamble (this is not a keyword)</i></h4>
Most biomolecular simulation software packages allow a form of
parallelization which one may refer to
as domain decomposition. Here, the system is partitioned into a number
of subsystems corresponding to the number of processor cores available to the parallel computation.
Each core then - more or less - computes only interactions of its own subsystem. The main requirements
for an efficient implementation are to keep the
communication load as small as possible and the workload even. While for specific classes of systems (dense,
truncated interactions, <i>etc.</i>) this method is undoubtedly superior, CAMPARI does not
currently implement it. Instead, it offers a general-purpose shared memory parallelization  
relying on OpenMP. A shared memory parallelization has the advantage of replacing communication 
calls with conceptually simpler synchronization calls. The shared memory parallelization
in CAMPARI is primarily a way to speed up simulation and analysis tasks within the confines
of a single machine. Current (2016) compute nodes in supercomputers offer tens of CPU
cores, and significant gains can be made for many practically relevant applications.
While the OpenMP parallelization is the inner layer of parallelism of CAMPARI, there is 
also an outer layer that implements sparse communication algorithms such as replica
exchange. Like most simulation software, CAMPARI uses the MPI standard for
handling the communication requirements of this outer parallelization layer. The resultant 
hybrid OpenMP/MPI code is particularly well-suited to multi-copy (replica exchange, PIGS) simulations
of medium-sized systems.<br/>
<br/>
<hr/>

<h4><a class="NoHi" id="NRTHREADS"><b>NRTHREADS</b></a></h4>
This keyword controls the number of threads that the workload of the calculation is distributed across.
The actual value is respected only if the pure OpenMP-enabled version of CAMPARI is used (campari_threads).
For the hybrid MPI/OpenMP executable (campari_mpi_threads), the number of threads cannot be set this way in CAMPARI
(because it must be known during creation of the MPI universe). Instead, the environment variable OMP_NUM_THREADS
should be defined accordingly. The threads parallelization as described next is the same in both cases,
so the documentation here is relevant in both cases.<br/>
The OpenMP parallelization of CAMPARI is not a domain decomposition in the vein of almost all MPI-parallel
decompositions found in molecular dynamics codes. CAMPARI is meant to cover a diverse set of simulations
(including those using <a href="keywords.html#DYNAMICS">different samplers</a> or those in implicit solvent).
Spatial domain decompositions work well for systems with homogeneous density undergoing global and continuous
evolution (which creates workloads that are all large enough and remain comparable across many simulation steps).
Conversely, a single Monte Carlo move of a small molecule in a dilute solution of biopolymers and small molecules
is not meaningfully addressable by spatial decomposition techniques. Task-based parallelizations are conceptually
simpler but offer less scalability (communication/cache/memory issues). Here, the necessary calculations are
simply divided at all cost-intensive stages across processes, which usually requires that all parallel processes
“see” the entire system. This is suitable for a shared memory (OpenMP) decomposition (although cache and memory
issues remain). As in any other parallel implementation, Amdahl's law holds. This is critical if the decomposable
workload is very low to begin with as in those cases any nonparallel task will become a bottleneck (performance
tapers off). Additionally, synchronization costs increase with increasing number of threads. Consequently,
performance reversal will occur for systems with unfavorable size or properties. This is particularly tricky
on modern many-core architectures where memory management (cache), task pinning, <i>etc.</i> are all nontrivial
or sometimes impossible to analyze and control. The systems that parallelize best in general are those that have
high floating point operations (FLOP) counts and can take advantage of blocky memory layouts.<br/>
The main “modes” or tasks covered by the shared memory parallelization in CAMPARI are as follows:
<ol>
<li><b>Global force and energy evaluations</b>. This is the most cost-intensive step in any gradient-based
technique implemented in CAMPARI. In general, forces and energies are grouped into terms even though this
leads to partial redundancy. For the nonbonded terms, which in general have costs that are conformation-dependent
(cutoffs), and a specific group of bonded and other terms loads are <a href="keywords.html#THREADS_DLB_FREQ">balanced dynamically</a>.
The limits are usually subsets of atoms, residues, molecules, or residue-residue interactions.  
Some bias terms have an inner parallelization that is independent of these types of limits, specifically
the <a href="keywords.html#SC_EMICRO">spatial density potential</a>, the <a href="keywords.html#SC_POLY">polymeric biasing potential</a>,
and <a href="keywords.html#SC_DREST">custom distance/position restraints.</a>. This is in contrast to other bias and bonded terms,
which are occasionally evaluated asynchronously by individual threads.</li>
<li><b>Incremental energy evaluations</b>. Incremental energy calculations account for the bulk of the cost of most Monte Carlo simulations and
can differ dramatically in extent from step to step. This is why CAMPARI will compute an explicit distribution of work load onto
threads every time. No dynamic balancing occurs. The workload can easily be so low that the scaling limit is reached.
To avoid adverse effects for larger numbers of threads, the number of synchronization operations per step is kept small.
The fact that no forces need to be computed simplifies both the required synchronization operations and the required data
structures considerably. The second point can lessen the negative impact of cache management on performance.</li>
<li><b>Determination of neighbor/interaction lists</b>. Irrespective of the sampler, any scalable simulation on a system
of appreciable size featuring nonbonded interactions will require truncation or transformation of these interactions
(&rarr; <a href="keywords.html#CUTOFFMODE">CUTOFFMODE</a>), which in turn necessitates algorithms to identify 
nearby species efficiently. These algorithms are all parallelized with generally good efficiency.</li>
<li><b>Managing complex constraints.</b>If <a href="keywords.html#SHAKESET">holonomic constraints</a> are in use,
CAMPARI identifies all groups that can be solved independently. This may offer a trivial parallelization across threads.
If one or few groups are expected to dominate the cost, CAMPARI evaluates whether these groups are large enough. If so,
each of these groups is solved in parallel by all threads, which requires a number of synchronizations proportional to the number of
<a href="keywords.html#SHAKEMETHOD">actual SHAKE iterations (only SHAKE is supported for this)</a>. Note that
with this and similar decompositions, it is currently not supported to use just a subset of the requested threads
to define an optimal setting. Instead, either 1 or all threads have to work on such a constraint group. This means that 
this type of parallelization is sometimes inactivated upon increasing the number of threads further as it is no longer
deemed efficient, which can be a limitation. In a similar vein, if <a href="keywords.html#CARTINT">Cartesian or internal</a>
coordinate space is used in conjunction with a gradient-based sampler, atom-based forces must be redistributed to these
degrees of freedom and their effective masses need to be computed. Both of these happen in recursive loops for complex
molecules. CAMPARI will again detect whether the sizes of molecules are large enough to warrant "internal" parallelizaiton.
If so, each of the eligible molecules is solved in parallel by all threads, which requires synchronization operations proportional to
the longest continuous branch in the molecule in question.</li>
<li><b>Coordinate operations for large molecules.</b>When sampling in <a href="keywords.html#CARTINT">Cartesian or internal</a>
coordinate space with methods that propagate many or all degrees of freedom simultaneously, it will be necessary to globally
reconstruct the Cartesian coordinates of the system based on the altered values. This conversion (Z matrix to Cartesian coordinates)
scales lienarly with the number of atoms but requires a large number of trigonometric functions and has very high data dependency
because it is strictly hierarchical. If required at every step, it can thus become a significant cost factor when the remainder 
of the rate-limiting computations are parallelized efficiently. Thus, for each molecule deemed large enough, CAMPARI analyzes automatically the hierarchy and
creates a parallel procedure for solving this problem with a fixed number of threads that can be less than the total available
number. As such, this is one of only two fully supported feature that can require nested OpenMP parallelism. As a result,
performance is harder to control (see comments below for FFTW). Conversely, other coordinate operations such as the
simple propagation in Cartesian dynamics, or simple translations by a single vector are straightforwardly parallelized.</li>
<li><b>Threaded computation of fast Fourier transforms with FFTW.</b>Unlike all other libraries linked by CAMPARI (<i>e.g.</i>, NetCDF or HSL), 
the code looks for and uses explicitly the threaded implementation of the <a href="http://www.fftw.org/" target="_TOP">FFTW</a> library.
Because of the way the interface works, this involves creating a new team of threads from the parallel CAMPARI execution, <i>i.e.</i>,
it entails nested parallelism. Because the other threads of the original team are idle during FFTW calls (but not destroyed),
performance is harder to control and predict, <i>i.e.</i>, it depends on the way the kernel, compiler, and custom runtime environment
end up distributing threads onto the available resources. This is why keyword <a href="keywords.html#THREADS_TEST">THREADS_TEST</a>
also enables a performance test for threaded FFTW execution (if available and in use). This can be used to understand 
better the influence of environment variables like "OMP_WAIT_POLICY" or "OMP_PROC_BIND" on FFTW performance inside CAMPARI.</li>
<li><b>A number of required utility operations required at every step of a calculation.</b>
Especially in <a href="keywords.html#DYNAMICS">gradient-based</a> calculations, there are a number of simple tasks
to complete that depend on atomic coordinates of the entire system. These include the actual coordinate propagation
(whether <a href="keywords.html#CARTINT">Cartesian or internal</a>), the correction of <a href="keywords.html#SYSFRZ">drift velocities</a>,
the calculation of total kinetic energies, or the management of polymeric descriptors and reference frames (center of mass, <i>etc.</i>).
The overall cost of all of these is linear with the total number of atoms. Synchronization requirements occur if a molecular property
like the center of mass needs to be computed by multiple threads (the necessity to do so is detected automatically) but they
are generally low. In <a href="keywords.html#DYNAMICS">Monte Carlo</a> calculations, quaternion-based parallelizations
of pivot-type moves occur in many move types along with repeated copy operations on coordinate arrays. Most of these operations
for any sampler have a low cost to begin with and are thus limited in scalability unless the systems get larger. They differ
from the holonomic constraint handler or the coordinate operations in that they should simply plateau in parallel performance
with increasing numbers of threads (rather than become slower again). This is because of the low (but nonzero) synchronization requirements.</li>
<li><b>Simple analysis tasks.</b>
At every step of any run (exceptions caused by the use of <a href="keywords.html#FRAMESFILE">FRAMESFILE</a> aside),
CAMPARI evokes a high-level routine that goes over all possible analysis tasks, evaluates whether they need
to be performed at that step (depending on the output and calculation frequencies listed 
<a href="keywords.html#output_analysis">elsewhere</a>), and executes the identified ones. The majority
of tasks are not worthwhile to be handled by multiple threads at once, so CAMPARI uses a task
parallelization using a large "SECTIONS" construct. This means that it is beneficial for the parallel
efficiency of these analyses if the calculation/output frequencies are matched with each other. Conversely,
it is inefficient to enter the function with multiple threads with only a single simple task to be performed.</li>
<li><b>Specific analysis tasks.</b>
Some analysis tasks, which are inherently expensive, have been parallelized specifically to be handled by all 
threads at once. This includes the calculation of <a href="keywords.html#EMCALC">spatial densities</a>,
<a href="keywords.html#REOLCALC">overlap metrics</a> in hybrid MPI/OpenMP multi-copy simulations (as they 
rely on global energy evaluations), and a number of tasks that are part of the
<a href="keywords.html#CCOLLECT">structural clustering</a> utility evoked during post-processing. Specifically,
the <a href="keywords.html#CMODE">tree-based clustering</a>, the <a href="keywords.html#CPROGINDMODE">approximate progress index</a>,
and iterative algorithms in graph processing (see <a href="keywords.html#CADDLINKMODE">CADDLINKMODE</a>,
<a href="keywords.html#CREWEIGHT">CREWEIGHT</a>, and <a href="keywords.html#CMSMCFEP">CMSMCFEP</a>) have been
OpenMP-parallelized. Other tasks could, due to their unfavorable scaling with system size, benefit from this type of parallelization,
and they may be implemented in the future, <i>e.g.</i>, parallel <a href="keywords.html#CONTACTCALC">contact</a>,
<a href="keywords.html#DSSPCALC">DSSP</a>, or <a href="keywords.html#SCATTERCALC">scattering</a> analyses.</li>
</ol>
<br/>
A few more comments are needed. First, the OpenMP parallelization does not extend to all parts of CAMPARI. In particular,
the initial setup and final clean-up are completely serial with no thread awareness whatsoever. Some of the procedures
performed there, for example, <a href="keywords.html#RANDOMIZE">initial structure randomization</a>, can be time-consuming,
and it is a limitation that they cannot be accelerated. Second, it is always recommended to get a quick estimate of
parallel efficiency by timing the code (keyword <a href="keywords.html#FLUSHTIME">FLUSHTIME</a> can be used 
to force frequent production rate estimates). Note that some calculations have inherently heterogeneous production rates,
<i>e.g.</i>, <a href="keywords.html#DYNAMICS">hybrid dynamics/Monte Carlo</a> calculations. Third, task decomposition by threads
generally changes the order in which individual summands are combined to yield net properties like the total force acting
on an atom. Because floating point math is not associative, this leads to a generally lower level of exact reproducibility
compared to multiple executions of 100% serial code. For large sums, a multi-threaded calculation will generally be <i>more</i> precise.
The loss in reproducibility is generally smaller than the loss of reproducibility across architectures and, especially, compilers
(which often has fundamentally the same reasons).<br/>
<h4><a class="NoHi" id="THREADS_DLB_FREQ"><b>THREADS_DLB_FREQ</b></a></h4>
If the <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization of CAMPARI</a> is in use,
this keyword determines after how many steps dynamic load balancing is periodically enabled. Dynamic load balancing 
conservatively shifts bounds on internal entities of representation (such as atoms, molecules, degrees of freedom)
between adjacent threads to improve the balance of times spent per thread. It is important to realize that embedded 
synchronization requirements destroy the ability to meaningfully measure load balance, which means
that dynamic balancing is only performed for synchronization-free subtasks (of which there are several,
<i>e.g.</i>, evaluation of nonbonded forces or neighbor list generation).  
It does so for at most <a href="keywords.html#THREADS_DLB_STOP">THREADS_DLB_STOP</a>
elementary simulation steps after the start of each interval.<br/>
In detail, this means that
every THREADS_DLB_FREQ steps a new data collection and balancing interval is started and continued for
up to <a href="keywords.html#THREADS_DLB_STOP">THREADS_DLB_STOP</a> elementary steps. The information used for balancing can
be pre-averaged across multiple steps using keyword <a href="keywords.html#THREADS_DLB_EXT">THREADS_DLB_EXT</a>.
For each block, if satisfactory balance is achieved, the balancing will stop until the next interval is encountered.
For small systems in particular, some subtasks will not be able to achieve a satisfactory balance (insufficient
granularity). If in these cases <a href="keywords.html#THREADS_DLB_STOP">THREADS_DLB_STOP</a> is equal to or larger than 
THREADS_DLB_FREQ, continuous load balancing is obtained. This is not recommended because the measurements 
themselves are not completely cost-free, and because a continuous adjustment of bounds is likely to
yield inferior cache performance.<br/>
There are two notes of caution. First, the idea of dynamic load balancing implies that the load does not
change dramatically from step to step. This may be violated in trajectory analysis runs where OpenMP is used
to compute energies. Splitting the trajectories and running an <a href="keywords.html#PDBANALYZE">MPI-parallel analysis</a>is likely to be a superior
strategy here. Second, dynamic load balancing expects threads to have the same "computing power" available 
to them at every step. This is not necessarily the case in oversubscribed systems (more threads than CPU cores)
where system-induced waiting times occur. It can also happen in undersubscribed (less threads than CPU cores) cases 
on multi-CPU systems where threads are not pinned to specific cores. This is because the available cache differs 
depending on how many threads reside on a CPU (socket). These issues are (at least theoretically) controllable
at the level of the operating system, for example using environment variables such as OMP_PROC_BIND. In practice,
it is very hard to predict performance accurately, and some amount of trial-and-error (benchmarking) is usually needed.
In particular, native hyper-threading for Intel chips should be tested as, possibly contrary to expectation,
it has proven beneficial in many applications (most likely due to better cache use).<br/>
<h4><a class="NoHi" id="THREADS_DLB_STOP"><b>THREADS_DLB_STOP</b></a></h4>
If the <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization of CAMPARI</a> is in use,
this keyword determines the maximum length of each periodic data collection interval for dynamic load 
balancing. The interval frequency is set by keyword <a href="keywords.html#THREADS_DLB_FREQ">THREADS_DLB_FREQ</a>.
Data collection and bounds adjustment is stopped as soon as the load imbalance is satisfactorily small or as soon as the
number of elementary passed since the beginning of each interval is equivalent to THREADS_DLB_STOP. Note that
generally it is recommended that the chosen value be small in relation to that chosen for 
<a href="keywords.html#THREADS_DLB_FREQ">THREADS_DLB_FREQ</a> as repeated measurement cycles and
bounds adjustments can themselves adversely affect performance.<br/>
<h4><a class="NoHi" id="THREADS_DLB_EXT"><b>THREADS_DLB_EXT</b></a></h4>
If the <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization of CAMPARI</a> is in use,
this keyword determines the number of elementary steps over which the execution times per thread are averaged
in <a href="keywords.html#THREADS_DLB_FREQ">dynamic load balancing</a>. Choosing a value different from 1, which
is the default, can violate the requirement that has to be balanced in <i>every</i> step for performance to be
optimal. However, for small systems and certain execution blocks, the measured times can be so small (and noisy) that averaging may be required
to balance them effectively. This is the role of this keyword. Note that choosing larger values
also limits the rate of convergence for load balance.<br/>
<h4><a class="NoHi" id="THREADS_VERBOSE"><b>THREADS_VERBOSE</b></a></h4>
If the <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization of CAMPARI</a> is in use,
this keyword controls the level of diagnostic output written to a dedicated output file, <i>viz.</i>,
<a href="outputfiles.html#THREADS.log">THREADS.log</a>. Options are as follows:<br/>
<ol start="0">
<li>No output is provided.</li>
<li>Only timing information (performance and expected time to finish) is written at intervals controlled by
keyword <a href="keywords.html#FLUSHTIME">FLUSHTIME</a>. This is the default and recommended option for
normal usage.</li>
<li>In addition to all output produced by the previous options, CAMPARI periodically reports updated bounds resulting
from <a href="keywords.html#THREADS_DLB_FREQ">dynamic load balancing</a> in case a reasonable balance is 
achieved. This is available for different categories. No output is written if the balancing approach fails to find
a satisfactory solution after <a href="keywords.html#THREADS_DLB_STOP">the requested of steps</a> for the 
<a href="keywords.html#THREADS_DLB_FREQ">current interval</a>. The bounds specify the chunk processed by each threads
and can refer to different representation constructs (atoms, residues, dihedral angles, and so on).</li>
<li>In addition to all output produced by the previous options, CAMPARI initially reports fixed bounds for operations
with predictable cost. These bounds are used in various places, and the information will not be of much use
for regular users.</li>
<li>In addition to all output produced by the previous options, CAMPARI frequently reports load imbalance measures
for any tasks that undergo dynamic load balancing. It is not recommended to use this option outside of
specific debugging or optimization tasks as the amount of data written gets very large very quickly. Note also
that the significant file I/O can interfere with external performance measurements. The output can highlight
aspects of the calculation that fail to become balanced.</li>
</ol>
Note that the timing information described for option 1 above is written directly to log-output 
if OpenMP is not in use.<br/> 
<h4><a class="NoHi" id="THREADS_TEST"><b>THREADS_TEST</b></a></h4>
This keyword is primarily for developer use. It instructs CAMPARI to not perform the actual simulation or analysis but to
instead test a subset of relevant threaded execution routines relative to their serial counterparts.
These tests use the actual system specified by the key-file. The output of the tests is 
mostly self-explanatory but understanding all of the reported deviations may require some insight into
algorithm structure. If the <a href="keywords.html#LREL_MD">particle-mesh Ewald</a> method
is in use, the correctness tests are followed by a scaling test for the linked 
FFTW library in threaded execution mode. This is a point of concern because the library does not
allow an existing parallel region to access it. More details are given <a href="keywords.html#EWALD">elsewhere</a>.<br/> 
<h4><a class="NoHi" id="REMC"><b>REMC</b></a></h4>
This logical keyword - when set to 1 - instructs CAMPARI to perform a
calculation employing and evolving a <a href="keywords.html#REPLICAS">number of copies</a>
of the <a href="inputfiles.html#FMCSC_SEQFILE">system</a>. Unlike for the mutually
exclusive keyword <a href="keywords.html#MPIAVG">MPIAVG</a>, here it is allowed that each replica is 
evolving under a different condition (<i>e.g.</i>, <a href="keywords.html#TEMP">temperature</a>).
This covers the replica exchange (RE) method for simulations and parallel analysis 
runs yielding as many results as there are trajectories.
Like all multi-copy (or multi-replica) methods in CAMPARI, the communication between copies
is handled by MPI, and it is therefore necessary to use an MPI-enabled executable. 
The <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization of CAMPARI</a> 
can be used simultaneously as this inner parallelization layer does not deal with 
the exchange of information between copies. In hybrid MPI/OpenMP mode, the number of threads
is no longer settable by <a href="keywords.html#NRTHREADS">NRTHREADS</a> but has to use
an environment variable (OMP_NUM_THREADS) at the system level instead.<br/>
For a simulation task, REMC activates <a href="references.html#ref21_1">the replica exchange method</a>
employing <a href="keywords.html#REPLICAS">REPLICAS</a>
separate conditions (processes). The conditions differ in one or more parameters
(&rarr; <a href="keywords.html#REDIM">REDIM</a>), and there is a dedicated input file
<a href="inputfiles.html#FMCSC_REFILE">FMCSC_REFILE</a> to specify them. Note that the order
of conditions may matter (&rarr; <a href="keywords.html#RENBMODE">RENBMODE</a>).
Irrespective of whether the underlying propagator is
pure Monte Carlo (see <a href="keywords.html#DYNAMICS">DYNAMICS</a>),
a dynamics-based method, or any hybrid method, restrictions apply in that the sampled ensemble
must be the canonical (NVT) one (see <a href="keywords.html#ENSEMBLE">ENSEMBLE</a>).
This can either be achieved by running constant particle number MC,
Newtonian dynamics with a proper thermostat (see <a href="keywords.html#TSTAT">TSTAT</a>), or
stochastic (Langevin) dynamics (which inherently tempers the ensemble).
In the RE method, structures (or conditions) are exchanged periodically between replicas
using a well-defined acceptance criterion. This is controlled by keyword <a href="keywords.html#REFREQ">REFREQ</a>
and includes the case of disabling these exchanges altogether. 
The exchanges are generally meant to improve sampling by allowing excursions into conditions
or <a href="keywords.html#energy_terms">Hamiltonians</a> in which (enthalpic) barriers are reduced.
The evaluation of the acceptance probability implies that energies of current structures must be 
computed for different conditions. Independently of any exchanges, this functionality is useful 
in free energy calculations (perturbations) as the exponential average of the work required to
change condition (energy difference) is directly related to the free energy difference between
those conditions (&rarr; <a href="keywords.html#REOLCALC">REOLCALC</a>). Parameters of the method
are the exchange frequency (<a href="keywords.html#REFREQ">REFREQ</a>) the scope for possible
exchange partners (<a href="keywords.html#RENBMODE">RENBMODE</a>), the number of exchange attempts
in a single exchange cycle (<a href="keywords.html#RESWAPS">RESWAPS</a>), and for dynamics
propagators the way of dealing with velocities upon a successful exchange (<a href="keywords.html#RE_VELMODE">RE_VELMODE</a>).<br/>
In CAMPARI, each replica and its output will correspond to both instantaneous and averaged
information from the associated condition, <i>i.e.,</i> the underlying trajectory is no
longer continuous in conformational terms. The typical assumption is that, depending on the settings for
the parameters of the method and given a suitable arrangement of replicas in <a href="inputfiles.html#FMCSC_REFILE">the RE input file</a>,
it can be achieved that the resultant ensemble averages and distributions are, for finite samples, indistinguishable
within error from a correct reference simulation for the same condition that does not utilize
exchange moves. This issue is not trivial, however, and the more general and precise approach
to the analysis of replica exchange data is to reweight all samples to a given target condition
that should either have been part of the original replica space or that can be obtained
by interpolation.
This reweighting is technically possible in CAMPARI (&rarr; <a href="keywords.html#FRAMESFILE">FRAMESFILE</a>) for 
almost all analysis features in <a href="keywords.html#PDBANALYZE">trajectory analysis mode</a>,
but the weights have to be determined externally (<i>e.g.,</i>, by the weighted histogram analysis method, WHAM).<br/>
If a RE run contains <a href="keywords.html#DYNAMICS">Monte Carlo moves</a>,
and is combined with the <a href="keywords.html#MC_ACCEPT">Wang-Landau acceptance criterion</a>, there is
a necessary note of caution. Specifically, if <a href="keywords.html#WL_MODE">WL_MODE</a> is set to 1,
this may result in identical copies of Wang-Landau 
runs if the exchanged parameters do not alter the Hamiltonian (since environmental conditions are irrelevant
to the Wang-Landau sampler in such a case). In any case, the Wang-Landau iterations
will proceed independently for each replica. This implies that it may yield
results that are difficult to interpret if replica-exchange swap moves are allowed 
(because those - currently - always follow a Boltzmann criterion).<br/>
If an <a href="keywords.html#PDBANALYZE">analysis run</a> is performed, the meaning of keyword REMC changes compared
to the case of simulation tasks described above.
For analysis, REMC instructs CAMPARI to perform trajectory analysis in parallel while keeping the data from all
<a href="keywords.html#REPLICAS">replicas</a> separate (for parallel analysis runs combining data,
see keyword <a href="keywords.html#MPIAVG">MPIAVG</a>). Example applications are to speed up
expensive analyses of large data sets, to compute free energy differences between ensembles,
or to obtain data suitable for error estimates via block averaging.
Keywords <a href="keywords.html#REFILE">REFILE</a>, <a href="keywords.html#REPLICAS">REPLICAS</a>, and
<a href="keywords.html#REDIM">REDIM</a> are required. All other RE simulation-related keywords are ignored. 
For the RE setup, analysis keywords <a href="keywords.html#REOLCALC">REOLCALC</a>, <a href="keywords.html#REOLINST">REOLINST</a>, and
<a href="keywords.html#REOLALL">REOLALL</a> are respected. As alluded to, this can be useful in post-processing simulation
data for <a href="keywords.html#GHOST">free energy growth</a> or related calculations requiring "foreign" energies.
There is another complication with RE data and that is the question how to evaluate a possible sampling benefit.
Users should always keep in mind that a RE trajectory with swaps inherently averages over data from several coupled
trajectories. A simple consequence of this is that data tend to look smoother and better converged if the number of 
replicas is increased. An assessment of the actual purpose of the method, <i>i.e.</i>, increased barrier crossing rates 
by excursions into conditions amenable to barrier crossing, is more feasibly obtained by unscrambling trajectories,
<i>i.e.</i>, by looking at trajectories continuous in conformation (and not in condition). This is why CAMPARI
allows the user to supply an <a href="keywords.html#TRACEFILE">input file with the swap history</a> of a set of
trajectories with the goal of transcribing
the set of trajectories to a new set that are all continuous in conformation. The input file needs to be
similar in format to the analogous <a href="outputfiles.html#N_000_REXTRACE.dat">output file created by CAMPARI during RE simulations</a>.
If this option is enabled, auxiliary keywords <a href="keywords.html#RE_TRAJSKIP">RE_TRAJSKIP</a> and <a href="keywords.html#RE_TRAJOUT">RE_TRAJOUT</a>
may become relevant.<br/>
Technically, parallel trajectory analysis requires that the <a href="keywords.html#REPLICAS">REPLICAS</a> individual
trajectories are systematically named and numbered in a fashion similar to how CAMPARI writes
<a href="outputfiles.html#Trajectory_output">trajectories in RE simulations</a>. This means that every file
is prefixed with "N_XXX_", where XXX gives the replica number (started from "000"). Since there is only a single
key-file, the input trajectory name specified should not include this prefix (it will be added automatically).
An example is given <a href="inputfiles.html#FMCSC_PDBFILE">elsewhere</a>. <a href="keywords.html#FRAMESFILE">Frame-specific analyses</a>
(and thereby frame weights) are not yet supported in parallel trajectory analysis runs.<br/>
<h4><a class="NoHi" id="REFREQ"><b>REFREQ</b></a></h4>
For any multi-replica simulation that supports structure transfer
between replicas, this keyword sets a fixed interval for attempting these
structure transfers. It is an important parameter of both the <a href="keywords.html#REMC">replica exchange method</a>
and the <a href="keywords.html#MPI_PIGS">PIGS method</a>.
Unlike frequencies supplied to define Monte Carlo move sets
described <a href="keywords.html#movesetcontrols">above</a>, this parameter
is a deterministic interval,
<i>i.e.</i>, a setting of 10<sup>4</sup> will imply that possible exchanges are
attempted exactly every 10<sup>4</sup> elementary steps.
This is because, in general, the communication requirement will mandate
that all replicas remain synchronized regardless. For replica exchange,
a swap cycle counts as a single (Monte Carlo) step in the trajectory. For PIGS,
the reseeding does <i>not</i> count as a step. Instead, it is performed exactly between the
steps corresponding to multiples of REFREQ and the respective next ones
(see <a href="outputfiles.html#N_000_PIGSTRACE.dat">elsewhere</a> for details).<br/>
All structure exchange is implemented 
in peer-to-peer mode. For generality reasons, the head node is always involved
in decision making for structure exchange. This imposes an unfavorable (centralized) communication
structure for some data (<i>e.g.</i>, reassignment maps).<br/>
For <a href="keywords.html#REMC">replica exchange runs</a>, structure
transfer is realized as swaps between conditions. Viewed as a Monte Carlo move,
such a swap attempt is defined in the context of a multicanonical ensemble.
This means that any analysis should consider the entire
set of simulation data and employ appropriate reweighting protocols to
obtain canonical averages corresponding to the individual or even interpolated conditions.
It is not immediately clear how justified it is to assume that the individual replicas in
a replica exchange run can be analyzed as if they satisfied the canonical distribution for
each condition individually. For a large fraction of published replica exchange simulations, swap attempts
are restricted to the immediate neighbors along a <a href="keywords.html#REDIM">one-dimensional</a>
temperature coordinate, and the data coming from replicas are treated independently.
Keyword <a href="keywords.html#RENBMODE">RENBMODE</a> allows the user to choose between
neighbor-only and global swap protocols.
We emphasize again that CAMPARI does support the computation of reweighted averages and distributions
by adding floating-point weights to a <a href="keywords.html#FRAMESFILE">frames file</a>.<br/>
It is difficult to provide guidelines for useful settings for this keyword. In replica exchange, very small values
for this exchange attempt interval can lead to relaxation problems. With dynamics samplers, the treatment
of velocities becomes an important consideration (see <a href="keywords.html#RE_VELMODE">RE_VELMODE</a>).
There is a considerable body of literature on this subject (some of it is cited in 
<a href="references.html#ref5_17">this reference</a>).<br/>
<h4><a class="NoHi" id="RESWAPS"><b>RESWAPS</b></a></h4>
If the <a href="keywords.html#REMC">replica exchange method</a> is in use, this
keyword specifies the number of swaps within a swap cycle. Each time a step is
encountered that is a multiple of <a href="keywords.html#REFREQ">REFREQ</a> CAMPARI will
collect the data from all replicas, construct the required energy matrix, and 
randomly pick pairs of eligible replicas (see <a href="keywords.html#RENBMODE">RENBMODE</a>)
for which the swap move Boltzmann acceptance criterion is evaluated. This process is repeated RESWAPS times
and the map matrix (structure to condition) is upated after every successful swap. This means that it is
possible for no pairs of replicas to effectively swap structures despite the presence of accepted moves.
This stochastic
implementation differs from that seen in other software and requires a
careful choice
for this keyword. For exchanges between all replicas
(see <a href="keywords.html#RENBMODE">RENBMODE</a>), this
should probably be at least N<sub>rep</sub>·(N<sub>rep</sub>-1)/2,
where N<sub>rep</sub> is the number of replicas in the simulation. For
neighbor swaps only, it should be N<sub>rep</sub>-1.
The reason for choosing a number proportional to or larger than the unique possible
exchanges is that the computational cost of computing necessary cross-energies 
(in Hamiltonian replica exchange) and of communicating the information required for the 
aforementioned matrix is, in our implementation, independent of the final number of accepted
swaps. This means that the cost of a swap cycle would be largely wasted by exchanging just a single pair
chosen from a much larger number of replicas. For neighbor swaps, the set of possible 
swaps is limited because the required energy matrix is only a tridiagonal band matrix.
This means that "secondary" swaps may be rejected due to lack of information rather than
the Boltzmann criterion, which can introduce biases.<br/>
Note that the acceptance rates become very small once there
is hardly any overlap between different replicas (in turn, the
acceptance is always strictly unity if the
conditions are the same - regardless of the two structures). A large number
of attempted swaps in conjunction with <a href="keywords.html#RENBMODE">all-against-all</a> exchange
corresponds to an equilibration of current structures across conditions.
In the limit
of tiny acceptance rates, the impact of the replica exchange method is no longer felt, and it
reduces to a set of independent canonical simulations at different conditions (the same limit
is achieved explicitly by setting <a href="keywords.html#REFREQ">REFREQ</a> to be very large). 
Because of this, a reasonable swap acceptance rate is often taken as the primary diagnostic 
toolfor the choice of conditions (see <a href="outputfiles.html#N_000_PROBABILITIES.dat">output file
for swap probabilities</a>).<br/>
<h4><a class="NoHi" id="REFILE"><b>REFILE</b></a></h4>
This keyword defines location and name of the file containing the
specifications for the <a href="keywords.html#REMC">replica exchange</a> method (see
<a href="inputfiles.html#FMCSC_REFILE">elsewhere</a> for details).<br/>
<h4><a class="NoHi" id="RENBMODE"><b>RENBMODE</b></a></h4>
As alluded to <a href="keywords.html#REMC">above</a>, the replica exchange method
represents a rigorous sampling technique if one considers the multicanonical
ensemble it defines. This can cause problems in the interpretation of data
obtained for an individual condition. Moreover, the energetic overlap
between distant conditions is often small leading to negligible
swap likelihood for all but the replicas most similar in condition.
This is the typical scenario for temperature replica exchange calculations
in explicit solvent. Here, it is very common to restrict swap attempts to the (at most) two
neighboring replicas for a series of conditions. In Hamiltonian replica exchange,
the same idea might actually be more useful as it also restricts the computation
of the energy matrix to neighboring conditions. Recomputing energy values for many different
conditions can be costly. Therefore, the available options are:<br/>
<ol>
  <li>Swaps are attempted with all available replicas</li>
  <li>Only the (at most two) neighboring replicas are eligible for
swap moves, and neighbor relationships are determined by the sequence of conditions
as they appear in the <a href="keywords.html#REFILE">input file</a>
(this is the default).</li>
</ol>
The replica exchange moves can be seen as attempts to stochastically distribute 
structures across conditions according to their energies and a Boltzmann criterion.
This attempt is conditional upon the spectrum of energies available. The spectrum
of energies is changed exclusively by the base sampler and associated with
a relexation time scale. This creates a possible race condition with 
the setting for <a href="keywords.html#REFREQ">REFREQ</a>. The exchange pattern
defined by RENBMODE influences this rate of structure exchange. Choosing neighbor-only
exchange often gives quantifiable biases in the terminal replicas. Beyond that, it is the
simpler and computationally more efficient choice that is also more compliant with standard literature practice.<br/>
Note that almost all exchange-related problems naturally disappear in
the limit of few attempted swaps (→ <a href="keywords.html#REFREQ">REFREQ</a>)
or in the limit of poor overlap and consequently few <i>accepted</i> swaps. This limit
is very easily reached for large, condensed-phase system with typical interaction
potentials (fluctuations decrease with increasing size).<br/>
<h4><a class="NoHi" id="REPLICAS"><b>REPLICAS</b></a></h4>
This keyword sets the number of subprocesses intended to be created by a multi-copy
simulation. For <a href="keywords.html#REMC">replica exchange</a>
calculations, this has to rigorously correspond to the number of
processes granted by the system. A large enough number of different conditions in the corresponding input file (→ <a
 href="inputfiles.html#FMCSC_REFILE">FMCSC_REFILE</a>) has to be present.
For <a href="keywords.html#MPIAVG">MPI averaging</a> calculations, which includes
<a href="keywords.html#MPI_PIGS">PIGS runs</a> and parallel 
<a href="keywords.html#MC_ACCEPT">Wang-Landau runs</a>,
this keyword will actually be overridden by the actual processor number granted by the system.
Note that if the <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization of CAMPARI</a>
is also used (hybrid OpenMP/MPI), the management of access to hardware resources (compute cores) by 
both MPI processes and their spawned OpenMP threads is not trivial on modern many-core CPUs.
For example, a machine with two sockets with a 12-core CPU each can host a calculation with
4 MPI processes using 6 OpenMP threads each in many different ways including nonsensical mappings like
running everything on a single core. While this mapping can often be controlled by the user at both levels,
it should really be managed automatically by the operating environment whenever possible.<br/>
<h4><a class="NoHi" id="REDIM"><b>REDIM</b></a></h4>
If the replica exchange method is in use (→ <a href="keywords.html#REMC">REMC</a>), this
keyword sets the number of dimensions specifying the conditions to be expected in
the dedicated input file (→ <a href="inputfiles.html#FMCSC_REFILE">FMCSC_REFILE</a>).
Note that replica exchange calculations may rely on neighbor relations (see <a
 href="keywords.html#RENBMODE">RENBMODE</a>),
and that those may be difficult to define if multiple dimensions are
used to specify each
condition.<br/>
<h4><a class="NoHi" id="REMC_DOXYZ"><b>REMC_DOXYZ</b></a></h4>
For any multi-replica simulation that uses <a href="keywords.html#DYNAMICS">pure MC sampling</a>
and supports <a href="keywords.html#REFREQ">structure transfer between replicas</a>,
this simple logical keyword lets the user choose to use Cartesian rather than torsional/rigid-body
coordinates to be transferred. The keyword is ignored if the propagator 
is fully or partially reliant on a dynamics method. 
This keyword can be useful if internal degrees of freedom not sampled by MC diverge in any
node-specific input files (for example, through rare scenarios when trying to restart
an MC run from (modified) restart files produced by MD).<br/>
<h4><a class="NoHi" id="RE_VELMODE"><b>RE_VELMODE</b></a></h4>
This keyword selects how to deal with velocities for any multi-replica
calculation allowing structural transfer between replicas. As such, it is relevant
for <a href="keywords.html#REMC">replica-exchange</a>
molecular dynamics runs and for <a href="keywords.html#MPI_PIGS">PIGS runs</a> using a
molecular dynamics propagator (see <a href="keywords.html#DYNAMICS">DYNAMICS</a>). One of the
complications of theses types of calculations arises in the necessity to pass on
or re-assign
velocities upon any successful structure change. The options for handling
this
difficulty are as follows:
<ol>
  <li>All velocities are always randomly re-assigned upon receiving a
new structure. This is equivalent
to an instantaneous, global action of an Andersen-type thermostat (see <a
 href="keywords.html#TSTAT">TSTAT</a>). It might be the safest option
to use for pure Hamiltonian replica-exchange, especially if the
Andersen thermostat is used in conjunction with Newtonian dynamics.
It is also the required option for <a href="keywords.html#MPI_PIGS">PIGS runs</a>
with propagators lacking a stochastic component.
</li>
  <li>Velocities are re-scaled by a factor equivalent to
(T<sub>i</sub>/T<sub>j</sub>)<sup>1/2</sup> where T<sub>i</sub> is the
temperature of the current node,
and T<sub>j</sub> the temperature of the node the received structure
originated from.
Note that this does not scale the instantaneous temperature to a
specific value, but rather by a specific factor. Unlike the first
option, it preserves directions and
relative magnitudes of all velocities. This mode relaxes to the third
option if temperature is not one of the replica exchange dimensions, or if the run is
using the <a href="keywords.html#MPI_PIGS">PIGS protocol</a>
instead of replica exchange.</li>
  <li>Velocities are taken directly from the node the incoming
structure originated from, <i>i.e.</i>, always remain associated with
"their" structure. This will almost
certainly lead to small artifacts for replica exchange calculations with
temperature as one of its dimensions. It is the preferred choice for <a href="keywords.html#MPI_PIGS">PIGS runs</a>
with stochastic propagators.</li>
</ol>
<h4><a class="NoHi" id="RETRACE"><b>RETRACE</b></a></h4>
This keyword is only relevant in <a href="keywords.html#REMC">MPI replica exchange</a>
or in <a href="keywords.html#MPI_PIGS">MPI PIGS (or PIGS analysis) calculations</a>
with <a href="keywords.html#REFREQ">swaps or reseedings performed</a>.
It requests that an instantaneous integer trace is written that
allows the user to recapitulate the complete history of structure transfer
between replicas. For replica exchange, the trace indicates
which condition is (after each swap or reseeding cycle) associated with which
initial starting conformation (see
<a href="outputfiles.html#N_000_REXTRACE.dat">N_000_REXTRACE.dat</a>). For
PIGS, the trace indicates every reseeding event in an even simpler form
(see <a href="outputfiles.html#N_000_PIGSTRACE.dat">N_000_PIGSTRACE.dat</a>).
For <a href="keywords.html#REMC">replica exchange</a>, these
data can be used to reconstruct trajectories continuous in geometric
variables rather than continuous in exchange condition (the latter being the
CAMPARI default). This is useful to be able to estimate the sampling enhancement
provided by replica exchange in terms of conformational decorrelation or similar metrics.
For <a href="keywords.html#MPI_PIGS">MPI PIGS calculations</a>, the trace can be read in 
by CAMPARI to recover the structural connectivity of configurations in <a href="keywords.html#CCOLLECT">graph-related
analyses</a>.<br/>
<h4><a class="NoHi" id="MPIAVG"><b>MPIAVG</b></a></h4>
This logical keyword - when set to 1 - instructs CAMPARI to perform a
calculation employing and evolving a number of copies
of the <a href="inputfiles.html#FMCSC_SEQFILE">system</a>. Unlike for the mutually
exclusive keyword <a href="keywords.html#REMC">REMC</a>, here it is assumed that each replica is 
evolving under exactly the same condition. Note that keyword <a href="keywords.html#REPLICAS">REPLICAS</a>
is no longer used to set the number of copies (the value is taken directly from the MPI environment instead).
Like all multi-copy (or multi-replica) methods in CAMPARI, the communication between copies
is handled by MPI, and it is therefore necessary to use an MPI-enabled executable.
The <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization of CAMPARI</a> 
can be used simultaneously as this inner parallelization layer does not deal with 
the exchange of information between copies. In hybrid MPI/OpenMP mode, the number of threads
is no longer settable by <a href="keywords.html#NRTHREADS">NRTHREADS</a> but has to use
an environment variable (OMP_NUM_THREADS) at the system level instead.<br/>
Additional keywords can activate specific multi-copy methods that utilize a similar framework, <i>viz.</i>,
parallel Wang-Landau runs (via <a href="keywords.html#MC_ACCEPT">MC_ACCEPT</a>) and
the PIGS protocol (via <a href="keywords.html#MPI_PIGS">MPI_PIGS</a>). In detail,
the possible tasks are:
<br/>
<i>MPI averaging</i><br/>
This is the mode achieved without any additional keywords. Here, 
The individual copies (replicas) are strictly independent (no communication requirement) until the very end when on-the-fly
analysis data are automatically collected and processed by the head node
(see <a href="outputfiles.html">documentation of output files</a>
for details). Some analysis functions or simulation algorithms may not
be supported. This is primarily a mode to save time for the user since it essentially reproduces 
a common mode of running molecular simulations, <i>i.e.</i>, running multiple trajectories in parallel
and analyzing the results to together. Starting conditions (see <a href="keywords.html#RANDOMIZE">RANDOMIZE</a>
and <a href="keywords.html#PDBFILE">PDBFILE</a>) and stochasticity of the propagator are
important here to avoid multiple replicas diverging only on account of numerical drift.<br/>
<i>Parallel Wang-Landau runs</i><br/>
If the simulation is a <a href="keywords.html#DYNAMICS">pure Monte Carlo simulation</a>
, and if the <a href="keywords.html#MC_ACCEPT">Wang-Landau acceptance criterion</a> is used,
the behavior changes. Wang-Landau runs are essentially iterative, and in such
a case keyword MPIAVG will create a parallel version of the
Wang-Landau scheme. At an interval set by <a href="keywords.html#WL_FLATCHECK">WL_FLATCHECK</a>, the
histograms are recombined over the individual nodes. The combined histogram is then what
determines the move acceptance and what is used to evaluate whether to update
the convergence parameter or not. The value of the convergence parameter and all other
relevant settings remain synchronized throughout. In between update steps, the individual
replicas evolve according to the last global histogram that was since incremented locally.
This means that the value chosen for <a href="keywords.html#WL_FLATCHECK">WL_FLATCHECK</a> is a delicate
quantity since both too small and too large values may impede convergence. While the former may
remove the bias for an individual replica to traverse phase space faster than a canonical simulation,
the latter may result in several replicas exploring the same area of phase space, thereby amplifying
a lack of global convergence. Note that the communication routines used in the parallel Wang-Landau implementation
can be fine-tuned using keywords <a href="keywords.html#MPICOLLS">MPICOLLS</a> and <a href="keywords.html#MPIGRANULESZ">MPIGRANULESZ</a>.<br/>
<i>PIGS runs</i><br/>
PIGS runs are explained in detail <a href="keywords.html#MPI_PIGS">below</a>. Here, CAMPARI collects
information from all replicas over a specified interval. Rather than biasing the potential energy surface,
this information is used to make decisions on whether to truncate some of the trajectories and to restart them
from more interesting points corresponding to the current states of other replicas. PIGS stands for
Progress Index-Guided Sampling and utilizes information from a method described
<a href="keywords.html#CMODE">elsewhere</a> (please refer also to the published articles:
<a href="references.html#ref23_5">progress index</a>; <a href="references.html#ref5_17">PIGS</a>).<br/>
<i>Parallel analysis runs</i><br/>
It is possible to let CAMPARI analyze several trajectories in parallel using either the 
 <a href="keywords.html#REMC">MPI replica exchange</a> setup or the MPI averaging setup. This is enabled
by setting <a href="keywords.html#MPI_PIGS">MPI_PIGS</a> to 0 (the default) and <a href="keywords.html#PDBANALYZE">PDBANALYZE</a>
to 1. For an analysis run in the MPI averaging setup, the behavior is exactly as in an MPI averaging calculation, <i>i.e.</i>, data are collected and analyzed
by each MPI process and pooled at the end. The results from such a calculation should be the same
as the result from a serial analysis of a single long trajectory obtained by concatenating the
individual trajectories.
Technically, parallel trajectory analysis requires that the <a href="keywords.html#REPLICAS">REPLICAS</a> individual
trajectories are systematically named and numbered in a fashion similar to how CAMPARI writes
<a href="outputfiles.html#Trajectory_output">trajectories in RE simulations</a>. This means that every file
is prefixed with "N_XXX_", where XXX gives the replica number (started from "000"). Since there is only a single
key-file, the input trajectory name specified should not include this prefix (it will be added automatically).
An example is given <a href="inputfiles.html#FMCSC_PDBFILE">elsewhere</a>. <a href="keywords.html#FRAMESFILE">Frame-specific analyses</a>
(and thereby frame weights) are not yet supported in any parallel trajectory analysis runs of this type. For parallel analysis runs
using the <a href="keywords.html#REMC">replica exchange</a> setup, please see <a href="keywords.html#REMC">above</a>.<br/>
<i>Parallel analysis runs emulating a PIGS stretch</i><br/>
This option is identical to the previous one with the single exception that <a href="keywords.html#CCOLLECT">structural clustering</a>
and related analyses are not available in their standard form. Instead, CAMPARI will emulate the behavior of the 
PIGS reseeding heuristic and print out a line of the <a href="outputfiles.html#N_000_PIGSTRACE.dat">PIGS trace file</a>.
This respects input for keywords <a href="keywords.html#MPI_GOODPIGS">MPI_GOODPIGS</a>, <a href="keywords.html#RE_TRAJTOTAL">RE_TRAJTOTAL</a>,
<a href="keywords.html#RE_TRAJOUT">RE_TRAJOUT</a>, and all the required keywords for computing the progress index
(starting with <a href="keywords.html#CCOLLECT">CCOLLECT</a>). 
For details, please consult the documentation on the <a href="keywords.html#MPI_PIGS">PIGS simulation method</a>.
This mode is enabled by setting <a href="keywords.html#MPI_PIGS">MPI_PIGS</a> to 1 and <a href="keywords.html#PDBANALYZE">PDBANALYZE</a>
to 1.<br/>
<h4><a class="NoHi" id="MPI_PIGS"><b>MPI_PIGS</b></a></h4>
If a multi-replica simulation is requested via keyword <a href="keywords.html#MPIAVG">MPIAVG</a>,
this keyword allows the user to enable the PIGS enhanced sampling scheme. We refer the user
to the <a href="references.html#ref5_17">literature</a> for a detailed overview. Technically, PIGS utilizes parts of the infrastructure
of both replica-based parallel simulation protocols (keywords <a href="keywords.html#MPIAVG">MPIAVG</a> and
<a href="keywords.html#REMC">REMC</a> as described below).
Briefly, PIGS works as follows:<br/>
Each of the <a href="keywords.html#REPLICAS">REPLICAS</a> processes running in parallel propagates a copy of the same system.
After an interval of <a href="keywords.html#REFREQ">REFREQ</a> steps has elapsed, the algorithm
evaluates a heuristic that is used to selectively terminate some of the trajectories and to reseed
them from the current states of other replicas. To avoid bit-identical trajectories, the <a href="keywords.html#DYNAMICS">propagator</a>
must have a stochastic component to it, <i>e.g.</i>, Langevin dynamics, Monte Carlo, or Newtonian molecular
dynamics with suitable <a href="keywords.html#TSTAT">thermostats</a>. Unlike in replica exchange,
the conditions associated with each replica are identical, and swaps would be redundant. The termination
and reseeding of trajectories implies a loss of information and is justified only if the reseeding
point ultimately leads to better sampling. The notion of "better" is not general. For PIGS, it consists
of the desire to diversify individual replicas, <i>e.g.</i>, to prevent sampling of overlapping regions of phase space.
The truncation and selective reseeding of simulations is used
in many methods such as distributed computing or transition path sampling.<br/>
To evaluate the heuristic, PIGS collects data from every trajectory over every interval of size <a href="keywords.html#REFREQ">REFREQ</a>.
To remain scalable, it is a memory-free algorithm, <i>i.e.</i>, the slice of data determining the reseeding is always of the same size.
From the composite data slice, the so-called progress index is constructed (see option 4 to <a href="keywords.html#CMODE">CMODE</a>).
The size of the data slice is therefore set by the combination of keywords <a href="keywords.html#REFREQ">REFREQ</a>, 
<a href="keywords.html#CCOLLECT">CCOLLECT</a>, and <a href="keywords.html#REPLICAS">REPLICAS</a> (or the actual number
of replicas available). Construction of the progress index requires as essential input only the definition
of a representation and distance between snapshots, which is provided by <a href="keywords.html#CDISTANCE">CDISTANCE</a>
and possibly <a href="keywords.html#CFILE">CFILE</a>. Again, for scalability reasons, the approximate progress index
is constructed, and this entails additional parameters of minor importance (see
keyword <a href="keywords.html#CPROGINDMODE">CPROGINDMODE</a> for details).<br/>
With the complete progress index in hand, it is possible to locate the current snapshots for all replicas in the
index. This requires that <a href="keywords.html#REFREQ">REFREQ</a> be a multiple of <a href="keywords.html#CCOLLECT">CCOLLECT</a>.
The progress index is an ordered sequence of snapshots that arranges geometrically similar snapshots close to one
another without using a reference state. Every snapshot is associated with a specific distance that corresponds to
the length of an edge in an underlying spanning tree. From this information, a composite rank of three individual ranks is constructed.
The latter are:<br/>
<ol>
<li>Position in the progress index (larger is better as snapshots from low likelihood regions are more likely to appear there).</li>
<li>Length of the associated edge (larger is better as distances tend to be larger in low likelihood regions).</li>
<li>Distance from any other current snapshot in terms of progress index position (larger distances are better as they
indicate more unique sampling domains).</li>
</ol>
From the composite rank (sum of the individual ranks), a specified number of top-ranked replicas is identified and serves as a
database for reseeding the remaining replicas. This number is provided as keyword <a href="keywords.html#MPI_GOODPIGS">MPI_GOODPIGS</a>.
For each of these lower-ranked replicas, one of the <a href="keywords.html#MPI_GOODPIGS">MPI_GOODPIGS</a> top-ranked replicas
is chosen with uniform probability, and the following expression is evaluated:<br/>
p(X &rarr; Y) = [ &zeta;(X)-&zeta;(Y) ] / (&Delta;&zeta;<sub>max</sub>+1)<br/>
Here, &zeta;(X) and &zeta;(Y) are the composite (summed) ranks for replicas X and Y, respectively. &Delta;&zeta;<sub>max</sub>
is the maximum realizable difference in composite rank. The result is 
compared to a uniformly distributed random number between 0 and 1. A reseeding is accepted putatively if this random
number is smaller than the evaluated expression, which biases acceptance toward cases with large rank difference.
It is only putatively accepted because every replica can be protected on account of a uniqueness criterion. This
is evaluated by finding the first and third quartiles of the snapshots coming from the replica in question 
in terms of progress index position. If they are tightly clustered,  the number is small, and it is inferred that
this replica samples a relatively unique area of phase space. Conversely, if they are distributed, this indicates sampling overlap.
The difference in the positions of the first and third quartiles is compared to the number
<a href="keywords.html#REFREQ">REFREQ</a>/<a href="keywords.html#CCOLLECT">CCOLLECT</a>, which is twice the minimum value.
If it is less than this number, any putative reseeding is rejected for the replica in question.<br/>
A positive reseeding decision incurs the same mechanism as that of accepting a new structure in replica exchange.
Principally, all required settings and variables for the propagator are transferred. This excludes the 
<a href="keywords.html#RANDOMSEED">seed of the random number generator</a>, <i>i.e.</i>, otherwise identical
trajectory can diverge quickly on account of the different sequences of random numbers. This is how the
stochastic component of the propagator as mentioned above is relevant. 
For <a href="keywords.html#DYNAMICS">molecular dynamics propagators</a>, velocities can be kept or reassigned, <i>i.e.</i>,
both meaningful controls supplied by <a href="keywords.html#RE_VELMODE">RE_VELMODE</a> are supported. For pure MC propagators,
keyword <a href="keywords.html#REMC_DOXYZ">REMC_DOXYZ</a> is also supported. The history of reseeding decisions
can be recorded in a <a href="outputfiles.html#N_000_PIGSTRACE.dat">trace file</a>. This file is similar to
the same output file for the replica exchange method and can be obtained with keyword
<a href="keywords.html#RETRACE">RETRACE</a>. It is strongly recommended to always write this file for subsequent 
diagnosis and analysis.<br/>
With the exception of <a href="keywords.html#CCOLLECT">structural clustering</a>, on-the-fly data analysis is 
supported by PIGS in the same way as it is by the default multi-replica (MPI averaging) setup. Data are gathered
across replicas, combined, and total averages and distributions are provided. In general, however, PIGS
leads to biased distributions, and it may therefore be more useful to adopt a standard protocol that stores
trajectories individually for each replica (with <a href="keywords.html#MPIAVG_XYZ">MPIAVG_XYZ</a>), disables
most on-the-fly analyses, and performs all further analyses strictly in post-processing (with
<a href="keywords.html#PDBANALYZE">PDBANALYZE</a>).<br/>
<a href="keywords.html#CCOLLECT">Structural clustering</a>
uses the same infrastructure that PIGS requires to evaluate the heuristic but the data are deleted
after each interval of length <a href="keywords.html#REFREQ">REFREQ</a>. Note that this implies that the memory requirement
of the head node can be large if <a href="keywords.html#REFREQ">REFREQ</a>/<a href="keywords.html#CCOLLECT">CCOLLECT</a>
and the number of replicas are both large. Scalability of the protocol with respect to the number of replicas requires
parallelization of the progress index computation itself, and this is only implemented at the level of 
the master MPI process thus far. Conversely, the subordinate ranks do nothing but communicate their
snapshot to the master instantly after each collection event. Once the data for the entire stretch has been received
from all replicas, the <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> 
of the data mining algorithms comes into play (in a hybrid MPI/OpenMP run). The available OpenMP threads are only those
of the master MPI process even if multiple MPI processes reside on the same shared-memory node. Because of these
limitations, it is recommended
to ensure through appropriate parameter settings that the cost added by the heuristic is kept manageable.
Keep in mind that 
some aspects of the structural clustering facility are not available in the context of the PIGS heuristic. Obviously,
<a href="keywords.html#CMODE">CMODE</a> is not selectable, nor are <a href="keywords.html#CPROGINDSTART">CPROGINDSTART</a>
or <a href="keywords.html#CPROGINDMODE">CPROGINDMODE</a> controllable (they default to 4, -1, and 2, respectively).
Keyword <a href="keywords.html#CPROGMSTFOLD">CPROGMSTFOLD</a> has no effect (it use would be undesirable in the context of the 
first ranking criterion mentioned above). All keywords related to editing or utilizing the link structure of the network are 
irrelevant. <a href="keywords.html#CPREPMODE">Data preprocessing</a> and the <a href="keywords.html#CMODWEIGHTS">utilization
of weights</a> are both supported but the <a href="keywords.html#PCAMODE">application of linear transforms</a> is not (yet).
The use of weights can entail a number of associated parameters that reflect or describe a (time) locality in the sequence 
of snapshots, <i>e.g.</i>, a <a href="keywords.html#CLAGTIME">lag time</a>. It is important to keep in mind that the PIGS
algorithm simply concatenates the data from all replicas, which can lead to artificial periodicities or spikes in locally
estimated fluctuations, which may or may not be desired. Lastly, the technical parameters controlling the tree-based clustering
and the short spanning tree construction for the progress index are of course relevant in PIGS
(&rarr; <a href="keywords.html#CRADIUS">CRADIUS</a>, <a href="keywords.html#CMAXRAD">CMAXRAD</a>, 
<a href="keywords.html#BIRCHHEIGHT">BIRCHHEIGHT</a>, <a href="keywords.html#BIRCHMULTI">BIRCHMULTI</a>,
<a href="keywords.html#CREFINE">CREFINE</a>, <a href="keywords.html#CLEADER">CLEADER</a>, <a href="keywords.html#BIRCHCHUNKSZ">BIRCHCHUNKSZ</a>,
<a href="keywords.html#CMERGEDIAM">CMERGEDIAM</a>, <a href="keywords.html#CPROGINDRMAX">CPROGINDRMAX</a>,
<a href="keywords.html#CPROGRDEPTH">CPROGRDEPTH</a>, <a href="keywords.html#CPROGRDBTSZ">CPROGRDBTSZ</a>).<br/>
<br/>
<h4><a class="NoHi" id="MPI_GOODPIGS"><b>MPI_GOODPIGS</b></a></h4>
This, along with <a href="keywords.html#REFREQ">REFREQ</a>, <a href="keywords.html#CCOLLECT">CCOLLECT</a>, and 
<a href="keywords.html#CDISTANCE">CDISTANCE</a>, is one of the main parameters of the <a href="keywords.html#MPI_PIGS">PIGS protocol</a>
(see link for details).
It determines how many of the parallel replicas are protected from being reseeded and serve as database for the remaining
replicas. If MPI_GOODPIGS equals the actual number of replicas (normally set by <a href="keywords.html#REPLICAS">REPLICAS</a>),
the PIGS algorithm relaxes to the propagation of independent, identical copies of the system
(basic functionality of <a href="keywords.html#MPIAVG">MPIAVG</a>). There is no consensus rule for good choices
for this parameter, but a reasonable starting point is usually given by setting it to <a href="keywords.html#REPLICAS">REPLICAS</a>/2.
<br/>
<h4><a class="NoHi" id="MPIAVG_XYZ"><b>MPIAVG_XYZ</b></a></h4>
If the MPI averaging technique is in use (→ <a
 href="keywords.html#MPIAVG">MPIAVG</a>),
this simple logical keyword lets the user choose to obtain trajectory
data for each of the
independent, identical replicas separately (which is also the default).
If this keyword
is explicitly set to zero (logical false), only a single trajectory
file will be written
with entries cycling not only through the time or equivalent axis but
also through replica
space (see <a href="outputfiles.html#Trajectory%20output">elsewhere</a>
for details). The choice
here is mostly a matter of convenience for post-processing but note
that with individual
trajectories <a href="keywords.html#REPLICAS">REPLICAS</a> as much
structural data are written
as with a single file. Lastly note that very frequent write operations
by different processes
to a shared output file may occasionally cause race conditions and/or
be inefficient due to
long waiting times.<br/>
<h4><a class="NoHi" id="MPICOLLS"><b>MPICOLLS</b></a></h4>
This keyword acts as a simple logical (turned off by default) that allows the user
to enable the usage of collective communication routines defined by the MPI standard
for selected communication operations in CAMPARI (routines such as MPI_ALLREDUCE,
MPI_BCAST, <i>etc</i>). These routines should at all times be functionally equivalent to
what CAMPARI would use otherwise, <i>i.e.</i>, collective primitives constructed
exclusively from blocking send and receive operations (MPI_SEND and MPI_RECV).<br/>
The reason for having such a keyword is twofold. First, buggy code in conjunction with
these MPI-defined collective communication routines can be difficult to diagnose and debug,
because the MPI standard requires an outcome, but not a specific implementation.
Essentially, developers and users cannot make any assumptions about the underlying
communication flow. In general, this is of course desired (especially from a performance point of view),
since it leaves the optimization of said communication to the MPI library rather than forcing
the calling program to address these issues. Second, there are enough reports on the web
of potentially faulty implementations of these routines in common MPI libraries. In conjunction
with additional concerns regarding thread safety, <i>etc</i>, it could prove advantageous
to developers to have modifiable implementations in place.<br/>
<h4><a class="NoHi" id="MPIGRANULESZ"><b>MPIGRANULESZ</b></a></h4>
If custom CAMPARI routines for collective communications are in use
(&rarr; <a href="keywords.html#MPICOLLS">MPICOLLS</a>), and if a calculation is performed
that relies on such collective communication operations, this keyword lets the user
alter the communication flow structure CAMPARI sets up to handle these cases.
The keyword specifies a number of processes, amongst which communication is presumed
fast (most often the number of CPU cores on a single board). The communication flow
is then set up in a way that minimizes the required communication between such blocks
of processes (they are generally assumed to be in sequence and to all be of identical size).
This keyword is therefore unlikely to be useful for heterogeneous allocations (different
numbers of cores granted on different machines or processes distributed non-sequentially).
Between blocks, communication attempts 
to minimize latency (tree topology), whereas within blocks communication is (currently)
strictly hierarchical and sequential with a single head process for each block.
This means that (currently) setting MPIGRANULESZ to the number of processes granted by MPI
will generate a global hierarchical flow with a single master, whereas setting it to 1 will
generate a global tree-like flow. <br/>
<br/>
<br/>
<br/>
<h3><a class="NoHi" id="output_analysis">Output and Analysis:</a></h3>
<hr style="width: 100%; height: 2px;"></hr> (<a href="keywords.html#TOP">back to top</a>)<br/>
<h4><i>Preamble (this is not a keyword)</i></h4>
Unlike most other simulation software, CAMPARI offers to analyze
certain quantities while the simulation is being
performed ("on-the-fly"). This has the advantage that the frequency of
dumping raw trajectory data to the disk does
not have to control the frequency of analyses. This can save time and
money by circumventing expensive write operations
to disk. Of course, in a typical simulation setting, the user will
still want to obtain trajectory data: for visualization,
for non-yet-defined analyses, and so on. However, the built-in analyses
can still prove beneficial by utilizing as much
data as possible. This is generally controlled by several interval
settings: analysis X should be performed or instantaneous data Y should
be reported every N steps.
Such keywords (see for example <a href="keywords.html#ANGCALC">ANGCALC</a>)
are interpreted the same way unless otherwise noted.
For example, if <a href="keywords.html#ANGCALC">ANGCALC</a> is 250 and
<a href="keywords.html#NRSTEPS">NRSTEPS</a> is 1000, the analysis would
be performed at steps #250, 500, 750, and 1000. There is only one other
keyword affecting this: the number
of <a href="keywords.html#EQUIL">equilibration steps</a>. If in the
above example <a href="keywords.html#EQUIL">EQUIL</a> is 400,
the analysis would only be performed at steps, 500, 750, and 1000 (<i>i.e.</i>,
the count is always relative to the 0<sup>th</sup> step).<br/>
Note that some analyses can be costly. Their scaling with system size
will usually be stated.
At the very end, the log-output will typically report the fraction of
CPU time spent
performing analysis routines. This may help assess whether some of the
frequency settings should be reduced. Simple ways to
<a href="keywords.html#DISABLE_ANALYSIS">disable built-in analyses</a> are provided.<br/>
CAMPARI often groups statistics together. For example, for a
melt of identical polymers, CAMPARI would by default
compute only a single histogram of end-to-end distances. This grouping
is at times undesired and is overcome by the concept
of <a href="keywords.html#ANGRPFILE">analysis groups</a>. Unfortunately, the
opposite task of grouping information from different species together is currently
not supported for such analyses.<br/>
For long CAMPARI runs, the instantaneous analysis has the downside that (currently)
no intermediate results are produced (everything remains in memory until the very end).
In this case, it can be useful to 
utilize the restart functionality (&rarr; <a href="keywords.html#RSTOUT">RSTOUT</a>) to produce
simulation blocks of equivalent sizes each with complete analysis output files.
This strategy also serves to preserve more information in case of unexpected crashes or job terminations.
The alternative is to follow the classical route of shifting the entire analysis burden
to <a href="keywords.html#PDBANALYZE">post-processing</a> by only saving instantaneous
<a href="keywords.html#XYZOUT">trajectory output</a>. As mentioned above, this has the downside of dealing with 
larger amounts of data and, more importantly, with a loss of coordinate precision (for example,
when using <a href="keywords.html#XTCPREC">the xtc compression library</a>). Another issue
that can prove problematic with long runs is that some instantaneous output files 
(such as <a href="outputfiles.html#ENERGY.dat">the file with running energy terms</a>) are
subject to buffered I/O. This depends on compiler and operating and file systems and means 
information can be lost in case of unclean terminations, which makes it harder to diagnose the error.
Keyword <a href="keywords.html#FLUSHTIME">FLUSHTIME</a> helps with this problem.<br/>
When the <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
there are a few additional considerations to be taken into account. First, few analyses are <i>per se</i>
parallelized (mentioned below for these cases). For the remainder, which are largely
inexpensive in terms of CPU time, CAMPARI uses an inhomogeneous and dynamic task parallelization approach at every step.
This means that it is beneficial to to make sure that analyses are triggered at the same
simulation/trajectory steps. Conversely, if their executions are staggered, <i>i.e.</i>,
only one or few tasks are executed at a given step, the  
load distribution across threads by task cannot provide a benefit. Notably,
the final processing/printing of results, with the exception of 
<a href="keywords.html#CCOLLECT">structural clustering</a> does not employ the
<a href="keywords.html#NRTHREADS">shared memory parallelization</a> at all.
In contrast, it is possible to chop a large trajectory into multiple pieces and to
use MPI-parallel <a href="keywords.html#PDBANALYZE">trajectory analysis</a> to
speed up analyses on large data sets (whether this involves combining the results in the end or not).<br/>
<br/>
<hr/>
<h4><a class="NoHi" id="RSTOUT"><b>RSTOUT</b></a></h4>
This keyword sets the interval specifying how often to write out a
restart file. Such a file
will allow continuing both crashed and normally terminated runs without
losing significant accuracy due to truncation of significant digits (such as in pdb-files).
Note that they are not bitwise perfect, however.
The concept is described <a href="keywords.html#RESTART">elsewhere</a>.
Restart files are written to two files continuously replacing
themselves on an alternating schedule such that even
if a crash occurs during a write-operation at least one sane restart
file should exist. These files
are generally named <a href="outputfiles.html#basename_1.rst">{basename}_1(2).rst</a>.
Settings for <a href="keywords.html#EQUIL">EQUIL</a> are (of course) irrelevant for this
output. Whenever a restart file is written, the system's potential energy is
recalculated, which is the only part aided by CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a>.<br/>
<h4><a class="NoHi" id="ANGRPFILE"><b>ANGRPFILE</b></a></h4>
This keyword sets path and name to the input file for determining
analysis groups by custom request rather than
by molecule type (→ <a href="inputfiles.html#FMCSC_ANGRPFILE">ANGRPFILE</a>).
By default, CAMPARI
will often combine collected analysis data for molecules of identical
type. This is not always the desired behavior.
For example, CAMPARI fails to recognize differences introduced to
molecules of the same type by virtue of
molecule-specific constraints or biasing potentials. Analysis groups
alleviate this and similar problems
by allowing to group molecules of identical type into arbitrary
analysis groups. Note that it is never
possible to combine data for molecules of chemically different type or
to split a single molecule into
multiple groups (although the latter may be implemented in the future).
Systems employing chemical crosslinks
(please refer to <a href="inputfiles.html#FMCSC_SEQFILE">sequence
input</a> for details) pose a special case:
here, intermolecular crosslinks do <b>not</b> conjoin two molecules in
terms of data structures and analysis, <i>i.e.</i>,
it will for example (currently) not be possible to obtain the net
radius of gyration of two crosslinked polypeptide chains. Instead, both
chains will be analyzed and treated as if they were separate molecules.<br/>
<h4><a class="NoHi" id="FLUSHTIME"><b>FLUSHTIME</b></a></h4>
This keyword determines the desired time interval (in minutes, with the caveat that there
is only a single measurement per elementary step) for two things. First,
every FLUSHTIME minutes (fractional values are allowed), CAMPARI will report 
the current production rate (in elementary steps/day) and time to finish. 
This happens to either log-output (for serial or pure MPI executables) or 
to a <a href="outputfiles.html#THREADS.log">dedicated output file</a> in 
case the <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a>
is in use. This performance estimation is bound to be misleading for inhomogeneous calculations
where the average cost of a step per time interval can change dramatically (for example, in <a href="keywords.html#DYNAMICS">simulations
with hybrid propagators</a> or <a href="keywords.html#PDBANALYZE">analysis runs</a>
where not all analysis frequencies are 1). Second, CAMPARI will flush the 
buffers of all instantaneous output files every FLUSHTIME minutes. This can be useful
because I/O buffers on a given system may be so large that the information in these files
(which are often used to monitor a running simulation) are rarely up-to-date, and that significant 
data loss can occur upon unexpected terminations.<br/>
<h4><a class="NoHi" id="DISABLE_ANALYSIS"><b>DISABLE_ANALYSIS</b></a></h4>
In CAMPARI, many analysis features are turned on by default. This keyword exists to simplify
turning them off, for example, when trajectory post-processing is desired, for trial runs, <i>etc.</i>
DISABLE_ANALYSIS is processed at the lowest hierarchy level of the key-file parser
and, like all other keywords, sequentially for a given hierarchy level. It is not
a keyword in the traditional sense since it does not set any CAMPARI-internal variable
associated with it to a given value. Instead, it is a shortcut for listing explicitly 
analysis features with calculation intervals larger than the <a href="keywords.html#NRSTEPS">simulation length</a>.
The options are:
<ol>
<li>All analysis and instantaneous output options are disabled. The only features not affected are
the writing of <a href="outputfiles.html#basename_START.pdb">initial and final structure files</a>, the
printing to log output (warnings, summary, and some progress information), the
<a href="outputfiles.html#THREADS.log">log-file for the OpenMP parallelization</a>,
the <a href="keywords.html#RETRACE">printing of the trace file</a> in certain MPI multi-copy runs, and
the writing of <a href="keywords.html#RSTOUT">restart files</a>.
Using this option without other keywords overriding DISABLE_ANALYSIS, a run will not provide much useful information.</li>
<li>All analysis options are disabled. This is the same as the previous option only that 
simple instantaneous output features like <a href="keywords.html#ENOUT">energy</a> or 
<a href="keywords.html#XYZOUT">trajectory</a> output are not turned off. Instantaneous output
relying on a built-in feature are disable implicitly, <i>e.g.</i>, 
<a href="keywords.html#INSTDSSP">running DSSP output</a>.</li>
<li>All instantaneous output options are disabled. This is the same as option 1 except that it
leaves all built-in analysis features
at their defaults (some are disabled by default in any case since they rely on additional information) but 
disables both simple and dependent instantaneous output features.</li>
</ol>
Because keywords are processed sequentially and hierarchically, the normal way of using DISABLE_ANALYSIS would be to 
include it toward the top of the key-file. This is equivalent to changing the default settings for analysis features.
The remainder of the key-file would then specifically enable the desired features. This usually leads to a shorter 
key-file than manually disabling unwanted features one-by-one.<br/> 
<h4><a class="NoHi" id="ENOUT"><b>ENOUT</b></a></h4>
This keyword defines the interval how often current potential energy
data are written to a file called <a href="outputfiles.html#ENERGY.dat">ENERGY.dat</a>.
Note that the total energy is decomposed into the individual
terms controllable by keywords of the type SC_XYZ (for example <a
 href="keywords.html#SC_IPP">SC_IPP</a>).
It is presently <i>not</i> possible to obtain energy decompositions
based on subcomponents of the system. The data in <a href="outputfiles.html#ENERGY.dat">ENERGY.dat</a>
are the only direct print-out of unperturbed energy values if 
<a href="keywords.html#SCULPT">energy landscape sculpting</a> is in use. Settings
for <a href="keywords.html#EQUIL">EQUIL</a> are ignored for this
output. Note that energies are calculated at every step for every term that is turned on.
Energies are never calculated specifically for reporting purposes. This means that ENOUT has no significant associated cost <i>per se</i>
and, more importantly, cannot be used
to speed up <a href="keywords.html#PDBANALYZE">post-processing runs</a> where energy values are required only for selected
frames of an input trajectory (the correct way to deal with this situation is to first <a href="keywords.html#FRAMESFILE">extract these frames</a>
and to then run the energy analysis in a second step).<br/>
<h4><a class="NoHi" id="ENSOUT"><b>ENSOUT</b></a></h4>
By this keyword, the user sets the interval how often to write current
ensemble data to a file called <a href="outputfiles.html#ENSEMBLE.dat">ENSEMBLE.dat</a>.
This is only relevant
if <a href="keywords.html#DYNAMICS">DYNAMICS</a> is not set to 1 or 6
(pure Monte Carlo sampling or minimization).
The reported quantities are informative ensemble variables (limited
output presently) including - most prominently -
potential and kinetic energies. Settings for <a
 href="keywords.html#EQUIL">EQUIL</a> are ignored for this output. As is the case for 
keyword <a href="keywords.html#ENOUT">ENOUT</a>, these values are calculated at every step regardless,
and no computation occurs specifically for reporting purposes.<br/>
<h4><a class="NoHi" id="ACCOUT"><b>ACCOUT</b></a></h4>
If pure Monte Carlo or hybrid sampling is used (→ <a
 href="keywords.html#DYNAMICS">DYNAMICS</a>), this keyword
sets the interval how often to report cumulative acceptance data to a
file called <a href="outputfiles.html#ACCEPTANCE.dat">ACCEPTANCE.dat</a>.
Note that these data are mildly informative in that
they do not directly allow to compute acceptance rates. They are mostly
useful in analyzing a running simulation
and assessing the performance of the <a
 href="keywords.html#movesetcontrols">move set</a>. CAMPARI will report
acceptance statistics as well as residue- and molecule-resolved
acceptance counts at the very end of the simulation
to log-output. The data in <a href="outputfiles.html#ACCEPTANCE.dat">ACCEPTANCE.dat</a>
are only resolved by move type. Settings
for <a href="keywords.html#EQUIL">EQUIL</a> are ignored for this
output.<br/>
<h4><a class="NoHi" id="TOROUT"><b>TOROUT</b></a></h4>
This keyword lets the user decide how often to write sets of 
internal coordinate space degrees of freedom to a file <a href="outputfiles.html#FYC.dat">FYC.dat</a>
in a one structure-per-line format. These files can easily become large due to
the number of degrees of freedom in general scaling linearly
with system size. There are two options selected by using a positive (mode 1)
or negative integer (mode 2) for TOROUT.<br/>
<ol>
<li>Native CAMPARI degrees of freedom are written with a header providing residue-level
information. These generally correspond to the unconstrained degrees of freedom in
Monte Carlo or torsional dynamics calculations (see <a href="inputfiles.html#FMCSC_SEQFILE">sequence input</a> for details).
All but rigid-body coordinates are written to <a href="outputfiles.html#FYC.dat">FYC.dat</a>
and much more information is provided there. Because rigid-body coordinates as missing,
the information in the file is never enough to completely reconstruct the system even when assuming the default
covalent geometries</li>
<li>Sampled, dihedral angle degrees of freedom are written with a header that provides
atomic indices corresponding to the various Z-matrix lines describing these dihedral angles.
This mode excludes degrees of freedom that are actually frozen, and can include
degrees of freedom that are not native to CAMPARI. All values are again written
to <a href="outputfiles.html#FYC.dat">FYC.dat</a>, and more details are provided there. This mode never includes bond angles
and/or dihedral angles that have no explicit Z-matrix entry.</li>
</ol>
Note that, regardless of mode, bond angles altered by the <a href="keywords.html#ANGCRFREQ">Ulmschneider-Jorgensen
concerted rotation moves</a> are never reported in <a href="outputfiles.html#FYC.dat">FYC.dat</a>.
Because there can be a lot of columns, it is possible for significant I/O lag to be associated with
this option. Like all other instantaneous output files, the printing 
of <a href="outputfiles.html#FYC.dat">FYC.dat</a> is done by a single thread
if CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use. This
happens with other threads performing other tasks concurrently (if there are any).<br/>
<h4><a class="NoHi" id="XYZOUT"><b>XYZOUT</b></a></h4>
This very important keyword sets the frequency with which snapshots
containing (at least) the Cartesian coordinates of the system
(or selected subsystem) are written to a new file or appended to an
existing trajectory file (→
<a href="outputfiles.html#Trajectory_output">documentation on output files</a> and keyword <a
 href="keywords.html#XYZPDB">XYZPDB</a>). Part of the filename(s) will
be
determined by keyword <a href="keywords.html#BASENAME">BASENAME</a>.
This is the fundamental saving frequency for obtaining
trajectory data and should be chosen carefully whenever the proposed
simulation is resource-intensive. These files can easily be very large, and it is possible for significant I/O lag
to arise. The printing 
of <a href="outputfiles.html#Trajectory_output">trajectory data</a> is done by a single thread
if CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use. This
happens with other threads performing other tasks concurrently (if there are any).<br/>
<h4><a class="NoHi" id="XYZPDB"><b>XYZPDB</b></a></h4>
If structural output is requested (→ <a href="keywords.html#XYZOUT">XYZOUT</a>),
this keyword chooses the output file format
(see <a href="outputfiles.html#Trajectory_output">documentation on output files</a>).
It is an integer [1-3(4,5)] interpreted as:
<ol>
  <li> Tinker-style .arc-files (ASCII)</li>
  <li> ASCII .pdb-files (default option) in various output conventions (see <a
 href="keywords.html#PDB_W_CONV">PDB_W_CONV</a> and 
<a href="keywords.html#PDB_OUTPUTSTRING">PDB_OUTPUTSTRING</a>)</li>
  <li> CHARMM-style binary .dcd-files (these include the box
information for each snapshot and have a CHARMM-style header - note
that the header is written only once by CAMPARI and contains the number
of snapshots in the file. This may not always be correct if simulations
are prematurely terminated or trajectory files appended)</li>
  <li> Compressed binary .xtc-files as used in GROMACS: note that this
option is only available if the program is linked against a proper
version of XDR (see <a href="install.html">installation instructions</a>)</li>
  <li> Compressed binary .nc-files as define by the NetCDF format in
<a href="http://www.ambermd.org/netcdf/nctraj.pdf" target="_TOP">AMBER convention</a>: note that this option is only available if the
program is linked against a proper NetCDF library (see <a href="install.html">installation instructions</a>).</li>
</ol>
When simulating large systems with significant computational expense, it
is typical to preserve as much trajectory information as possible which
is why file-sizes become important. The ratio of sizes for typical
settings may be something similar to 15:15:3:1:3 for .arc vs. .pdb vs.
.dcd vs. .xtc vs. .nc. Note that CAMPARI always prints out atoms in its
intrinsic assumed order which may be different from that used by other
programs. The exception to this is a specific setting changing that
order across residue boundaries for polynucleotides (see <a
 href="keywords.html#PDB_NUCMODE">PDB_NUCMODE</a>). Unannotated binary
files such as .xtc-, .dcd-, and .nc-files may therefore not be
compatible with other software unless a template file is used (for the
analogous option within CAMPARI see <a
 href="keywords.html#PDB_TEMPLATE">PDB_TEMPLATE</a>).<br/>
<h4><a class="NoHi" id="XYZMODE"><b>XYZMODE</b></a></h4>
If structural output is requested (→ <a href="keywords.html#XYZOUT">XYZOUT</a>),
this integer [1-2] keyword determines
whether to write to a series of numbered files (1) or a single file
(2, the default).
This, however, currently works for pdb only (specifically: .arc are
always multiple files, and the binary formats always write to (append)
a single file).<br/>
<h4><a class="NoHi" id="XTCPREC"><b>XTCPREC</b></a></h4>
If structural output is requested (→ <a href="keywords.html#XYZOUT">XYZOUT</a>)
and the chosen output format
is the binary .xtc-format (option 4 for <a href="keywords.html#XYZPDB">XYZPDB</a>),
this keyword can be used to
specify the multiplicative factor determining the accuracy of
compressed xtc-trajectories (the minimum is 100.0). It is also
required for proper reading of xtc-trajectories in xtc-analysis mode
(see <a href="keywords.html#PDBANALYZE">PDBANALYZE</a>
and <a href="keywords.html#XTCFILE">XTCFILE</a>).<br/>
<h4><a class="NoHi" id="PDB_NUCMODE"><b>PDB_NUCMODE</b></a></h4>
CAMPARI's internal representation of polynucleotides has one
peculiarity. It assigns the entire PO<sub>4</sub><sup>-</sup>
functional
group to the same nucleotide residue whereas most other programs seem
to assign the 3'-oxygen atom to the residue carrying the sugar.
This causes a non-trivial inconsistency when trying to use
CAMPARI-generated pdb-files as input for other software. Therefore,
this keyword defines how to assign the O3*-atom of nucleic acids in
pdb-output <b>only</b>. There
are two options:<br/>
<ol>
  <li>The O3*-atom is assigned to the residue carrying the
5'-phosphate it is part of, <i>i.e.</i>, it is the very first atom in
that
residue. This is the CAMPARI-inherent convention and
reflects the authentic structure of arrays in CAMPARI (which is
relevant for any analysis requiring atom numbers, see
for example <a href="inputfiles.html#FMCSC_PCCODEFILE">the input on selecting specific
distance distributions to be collected</a>).</li>
  <li>The O3*-atom is assigned to the residue carrying the
sugar it is part of; this is the PDB-typical convention. Note that this
inherently disrupts the 1:1-correspondence between
numbering in the pdb-file and how nucleic acids are represented
internally. It is recommended if and only if CAMPARI-output is sought
to be compatible with other software working in this latter convention. Note
that for this option to work correctly with unsupported polynucleotide residues
(recognized as such) atom names have to be canonical.</li>
</ol>
Note that option 2 also destroys the 1:1 correspondence between binary
(unannotated) trajectory files or TINKER .arc-files
on the one side and pdb-files on the other side. This may lead to
misrepresentations when using the
<a href="outputfiles.html#basename_VIS.vmd">automatic
visualization scripts</a>. This option may be extended in the future
to support other trajectory file formats - both for reading and writing
- as well.<br/>
<h4><a class="NoHi" id="PDB_W_CONV"><b>PDB_W_CONV</b></a></h4>
CAMPARI can in general process different atom and residue naming
conventions for the formatting of PDB files. This keyword selects the
format for written files. Choices are:<br/>
<ol>
  <li>CAMPARI format</li>
  <li>GROMACS format (atom naming, nucleotide and cap residue names, ...)</li>
  <li>CHARMM format (atom naming, cap residue names and numbering
(patches), ...): Note that there are two exceptions pertaining to
C-terminal cap residues (NME and NH2) which arise due to non-unique
naming in CHARMM: 1), NH2 atoms are called NT2 (instead of NT) and
HT21, HT22 (instead of HT1, HT2), and 2), NME methyl hydrogens are
called HAT1, HAT2, HAT3 (instead of HT1, HT2, HT3).<br/>
  </li>
  <li>AMBER format (atom naming, nucleotide residue names, ...)</li>
</ol>
Note that for subsequent work with CAMPARI it is of course safest and
easiest to just the default option (1). This keyword is supposed to
provide
cross-compatibility with other simulation software. Note that support is limited
to standard biomacromolecules and typically does not extend to small molecules or unusual
polymer residues (extensions
may be provided in the future). Also note that for polynucleotides, the setting
for <a href="keywords.html#PDB_NUCMODE">PDB_NUCMODE</a> is an <i>independent</i>
modifier of pdb-output. This is the twin keyword to <a href="keywords.html#PDB_R_CONV">PDB_R_CONV</a>
above.<br/>
<h4><a class="NoHi" id="PDB_OUTPUTSTRING"><b>PDB_OUTPUTSTRING</b></a></h4>
This keyword allows changing the formatting string
(Fortran) used for PDB files written by CAMPARI. This can be useful to make PDB files of very large
systems and in particular for changing the precision of PDB files. In order for CAMPARI to read
these files back in, the analogous keyword <a href="keywords.html#PDB_INPUTSTRING">PDB_INPUTSTRING</a> has to
be used. Because Fortran in general deals poorly with string-based I/O, any improper use of this keyword can easily lead to 
abnormal program termination. The default format is "a6,i5,1x,a4,a1,a3,1x,a1,i4,a1,3x,3f8.3" (<i>with</i> the quotes). The letters (a, i, f) give
the type of variable, which must not change. The numbers give the fields lengths, and these
can be customized for variables of type integer ("i") or real ("f"). It is also possible to modify the
field widths of string variables ("a") but that is likely harmful because the variables in use
are tied to the default format. Note that the insertion code (the last "a1" element) is always
written as a blank by CAMPARI since all residues are renumbered consecutively. The same is true for
the alternate location indicator (the first "a1" element).
The vast majority of modifications to the output format will create files that are no longer
readable (at least correctly) by other software, <i>.e.g.,</i> visualization software, or other
simulation codes, and it may be useful to use CAMPARI itself (or to write a script) to convert back
these nonstandard files whenever needed.<br/>
Common problems with standard PDB files, which can be addressed at least in part by the format string,
are that the integer number for atom index overflows, that the chain 
indicator becomes fused to neighboring columns (because of overlong residue names or large residue numbers),
that the residue number column overflows, that the coordinate entries get fused or overflow (if absolute coordinates
are not centered at small (in absolute magnitude) values), or that the coordinate precision
is insufficient for recovering exact covalent geometries based on this information alone.<br/>
<h4><a class="NoHi" id="XYZ_SOLVENT"><b>XYZ_SOLVENT</b></a></h4>
If structural output is requested (→ <a href="keywords.html#XYZOUT">XYZOUT</a>),
this logical keyword allows the user to suppress trajectory output
for molecules labeled as solvent. This can be useful to down-convert
trajectory files from explicit solvent runs or - more general - to
isolate certain parts of the system from existing trajectory data
(employing <a href="keywords.html#PDBANALYZE">PDBANALYZE</a> and
<a href="inputfiles.html#FMCSC_ANGRPFILE">ANGRPFILE</a>).
It may also be used to save space during actual simulations but it
should be kept in mind that information about the solvent may be lost
irrevocably and that the resultant trajectories may no longer be 
straightforward to analyze. A more general option for printing only parts
of the system is provided by supplying an index file via keyword
 <a href="keywords.html#TRAJIDXFILE">TRAJIDXFILE</a>.
<h4><a class="NoHi" id="TRAJIDXFILE"><b>TRAJIDXFILE</b></a></h4>
Usage of keywords <a href="keywords.html#XYZ_SOLVENT">XYZ_SOLVENT</a>
in conjunction with the concept of
<a href="inputfiles.html#FMCSC_ANGRPFILE">analysis groups</a> allows
the user some amount of fine control over what is
written to the <a href="outputfiles.html#Trajectory%20output">trajectory
file</a>. In some scenarios this may not be enough
(for example, if external scripts or software or even CAMPARI itself
are meant to analyze non-trivial subsets of the system).
Then, the user has the option to supply a simple index file providing
per-atom control over what coordinate information
is written to the trajectory file. Note that this will be useful for
subsequent <a href="keywords.html#PDBANALYZE">trajectory analysis runs</a>
only if the selected subset preserves the integrity of all molecules to
remain in the output, or if the output format
is pdb such that missing atoms can be re-built. For example, consider a
block co-polymer consisting of two blocks. The full
trajectory could be re-analyzed using an index file to yield a reduced
trajectory in pdb-format (keywords
<a href="keywords.html#XYZOUT">XYZOUT</a>, <a
 href="keywords.html#XYZPDB">XYZPDB</a>, and <a
 href="keywords.html#XYZMODE">XYZMODE</a>)
that contains only one of the two blocks. With a properly adjusted <a
 href="inputfiles.html#FMCSC_SEQFILE">sequence input file</a>,
it may then be possible to perform intrinsic
CAMPARI analyses over the isolated block which really was part of a
larger molecule. In this process, almost certainly some terminal
atoms would have to be rebuilt at the break point (but those may not
influence the analyses). For a description of the input file
format, see <a href="inputfiles.html#Atomindexinput">here</a>. Note
that all other output selection settings
are ignored if an index set is used via this keyword.<br/>
<h4><a class="NoHi" id="XYZ_FORCEBOX"><b>XYZ_FORCEBOX</b></a></h4>
If a system is simulated or analyzed that utilizes <a href="keywords.html#BOUNDARY">periodic boundary conditions</a>,
this keyword can be used to alter the standard CAMPARI way of placing
atoms with respect to the unit cell. By default, CAMPARI will never
break up molecules in <a href="outputfiles.html#Trajectory_output">trajectory output</a>,
which implies that the absolute coordinates in the trajectory file(s) can
extend significantly beyond the formal boundary of the unit cell. Similarly, by default
CAMPARI will assume that <a href="keywords.html#PDBFILE">structural input</a> preserves the integrity
of molecules, <i>i.e.</i>, that it conforms to exactly this standard.
Sometimes (for example, for visualization or for certain analyses), it may be desired to instead have
all atoms be inside the unit cell, and this is what this keyword accomplishes.<br/>
There are currently 4 different options related to both input and output.
<ol start="0">
<li>For both input and output, CAMPARI assumes that molecules are intact and intended to be left intact.</li>
<li>For output, CAMPARI will leave molecules intact. For input, CAMPARI will assume that the coordinates are such that
molecules have been forced to reside inside the central unit cell. Using <a href="keywords.html#SIZE">box information</a>,
CAMPARI will calculate image shift vectors and apply them to the processed input. This option is
incompatible with <a href="keywords.html#PDB_READMODE">PDB_READMODE</a> being 1. Image shift vectors are evaluated
<i>before</i> possible tolerance violations are considered (see keywords 
<a href="keywords.html#PDB_TOLERANCE_B">PDB_TOLERANCE_B</a> and <a href="keywords.html#PDB_TOLERANCE_A">PDB_TOLERANCE_A</a>.</li>
<li>For input, CAMPARI assumes that molecules are intact (no corrections applied). For output, it will
force coordinates to reside inside the central unit cell by breaking up molecules as needed.</li>
<li>This options combines the properties of options 1 and 2 for input and output, respectively.</li>
</ol>
Note that splitting molecules into two or more parts may interfere with molecular representations relying
on bonds, <i>etc.</i><br/>
Note that in some cases trajectory files with broken-up molecules may be ambiguous unless information
about the <i>expected</i> topology is present or provided. The input strategy currently implemented works as long
as the length of Z matrix bonds remains small in comparison to the box dimensions. Note that the start of the simulation
from a <a href="keywords.html#PDBFILE">pdb file</a> is affected by this keyword as is the 
<a href="keywords.html#PDBANALYZE">analysis</a> of <a href="inputfiles.html#FMCSC_PDBFILE">(binary) trajectory files</a>.<br/>
It is not recommended
to use options 1 or 3 above for writing trajectories from a production simulation, rather the output feature is
intended to transform preexisting trajectories (via <a href="keywords.html#PDBANALYZE">trajectory
analysis mode</a>). Lastly, in the case of an <a href="keywords.html#PDBANALYZE">analysis run</a>,
any structural input with entire molecules given as the "wrong" images will also be adjusted by options 1 and 3 above.
This scenario should be avoided as it leads to inconsistencies in any operations relying on absolute coordinates.
For options 0 and 2, output coordinates will not be altered by XYZ_FORCEBOX but they may still be altered
by keywords <a href="keywords.html#XYZ_REFMOL">XYZ_REFMOL</a> and <a href="keywords.html#ALIGNCALC">ALIGNCALC</a>.<br/>
<h4><a class="NoHi" id="XYZ_REFMOL"><b>XYZ_REFMOL</b></a></h4>
If a system is simulated or analyzed that utilizes <a href="keywords.html#BOUNDARY">periodic boundary conditions</a>,
this keyword can be used to alter the standard CAMPARI way of placing
molecules in three contexts, <i>viz.</i>, <a href="outputfiles.html#Trajectory_output">trajectory output</a>,
<a href="keywords.html#CCOLLECT">structural clustering</a> using 
<a href="keywords.html#CDISTANCE">absolute Cartesian coordinates (RMSD)</a>, and, similarly, 
the derivation of the alignment operator for <a href="keywords.html#ALIGNCALC">output trajectory alignment</a>.
The use of this keyword is explained primarily in the context of the first role.<br/> 
By default, CAMPARI will never allow the geometric center (or center of mass in
gradient-based simulation runs) to "leave" the central unit cell. When looking at intermolecular interfaces,
this can lead to the undesirable effect of the interface being broken across the periodic boundary.
These images often flicker back and forth, which makes visual inspection difficult unless periodic
images are explicitly replicated.
XYZ_REFMOL allows the user to specify a reference molecule whose center serves as reference point
for all images, <i>i.e.</i>, the coordinates of all other molecules printed to trajectory output are those
of the nearest image of these molecules with respect to the chosen reference. This operation
does not destroy information (<i>i.e.</i>, it does not center or align anything) but leads to
molecules being displayed that are outside of the central unit cell. In fact, the reference molecule
is the only one that is guaranteed to reside in the central cell at all times.<br/>
Note that this keyword does not actually alter coordinates used internally, and therefore has no
impact on the majority of analysis functions, <i>etc</i>. The only exceptions are structural clustering relying
on absolute Cartesian coordinates (options 5, 6, and 10 for <a href="keywords.html#CDISTANCE">CDISTANCE</a>)
and the <a href="keywords.html#ALIGNCALC">trajectory alignment facility</a>. For the latter XYZ_REFMOL simply picks the 
reference molecule to override the internal heuristic. In both scenarios, the alignment operator is derived using
image-corrected coordinates for all conformations in question. This role of XYZ_REFMOL is distinct but not separable
from the role for <a href="outputfiles.html#Trajectory_output">trajectory output</a> (<i>i.e.</i>, it is not possible
to use XYZ_REFMOL to pick the reference molecule for image selection for clustering or trajectory alignment while retaining
the default trajectory output).
XYZ_REFMOL is also ignored for the pdb files written at the
<a href="outputfiles.html#basename_START.pdb">beginning</a> and <a href="outputfiles.html#basename_END.pdb">end</a>
of a simulation. Along similar lines, trajectory files created in such a manner can be read back
by CAMPARI without problems (internally, every molecule is translated to the central unit cell upon read-in
as long as the box information (<a href="keywords.html#BOUNDARY">BOUNDARY</a>, <a href="keywords.html#SIZE">SIZE</a>,
and <a href="keywords.html#ORIGIN">ORIGIN</a>) is preserved).<br/>
<h4><a class="NoHi" id="ALIGNCALC"><b>ALIGNCALC</b></a></h4>
In <a href="keywords.html#PDBANALYZE">trajectory analysis runs</a>
CAMPARI offers the option to structurally superpose the
current Cartesian coordinates to a suitable reference. Note that this
functionality is conveniently available through
almost all molecular visualization software packages. CAMPARI provides automatically generated
<a href="outputfiles.html#basename_VIS.vmd">visualization scripts</a> designed to work with VMD.
If these options are unavailable or inconvenient, for example, because the visualization
program tries to read an entire very large data set into memory, ALIGNCALC
lets the user set the interval at which CAMPARI should perform structural alignment.
For example, to create - from an original trajectory - a superposed
trajectory of every 10th frame,
<a href="keywords.html#XYZOUT">XYZOUT</a> would have to be 10 and
ALIGNCALC would have to be 10 or a factor of 10 (5,2,1).<br/>
For convenience, the root mean square deviation over the <a href="keywords.html#ALIGNFILE">alignment set</a> after
alignment can be written to an <a href="outputfiles.html#RMSD.dat">instantaneous output file</a>.
This can be enabled by specifying a negative number to ALIGNCALC, which
is, except for the sign, interpreted in the same way. Sometimes it
may also be desirable to align on one set of atoms and compute RMSD values for 
another set. CAMPARI supports this, if in addition to an appropriate choice of
<a href="keywords.html#ALIGNFILE">alignment set</a>, the user provides
another index set via keyword <a href="keywords.html#CFILE">CFILE</a>. This second
input then becomes an additional set to compute RMSD values for. This is the same logic
as found in RMSD-based structural clustering with split sets
(see option 6 for keyword <a href="keywords.html#CDISTANCE">CDISTANCE</a>).<br/>
Alignment happens before any of the analysis routines are called and
works by first defining a reference set of atom indices
(→ <a href="keywords.html#ALIGNFILE">ALIGNFILE</a>). It can be somewhat time-consuming
and is currently not aided in any way by CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a>.
Using a quaternion-based algorithm, an optimal translation and
rotation is determined that minimizes - when applied to the current
coordinates - the deviation between the transformed current
coordinates and the reference coordinates (<i>i.e.</i>, a set of
coordinates for all atoms in the alignment set).
Note that this procedure will always preserve the internal state of
molecules and - except for certain cases in
<a href="keywords.html#BOUNDARY">periodic boundary conditions</a> - the
relative arrangement of molecules. It will not, however,
preserve the relative position of the system boundary. This may lead to
artifacts in energetic analyses of aligned trajectories
or any analyses that rely upon relative, intermolecular coordinates.<br/>
There are two ways of defining/providing the coordinates for the alignment set. The first
is via an external file. Here, CAMPARI reuses the
<a href="keywords.html#PDB_TEMPLATE">pdb-template functionality</a>. If
keyword <a href="keywords.html#PDB_TEMPLATE">PDB_TEMPLATE</a>
is specified and successfully read, then the reference coordinate set
is extracted from this file for the set of atoms defined via
<a href="keywords.html#ALIGNFILE">ALIGNFILE</a>. Note that the template
may serve a double purpose in this scenario as it
may still provide the atom numbering map needed to read binary
trajectory formats with non-CAMPARI atom order.
If no template is specified, the reference coordinates will be defined by the
previously aligned structure. This successive alignment
therefore uses a different reference coordinate set each time and will
consequently lead to drift.<br/>
As described for keyword <a href="keywords.html#XYZ_REFMOL">XYZ_REFMOL</a>, the combination
of <a href="keywords.html#BOUNDARY">periodic boundary conditions</a> and multimolecular
assemblies can become ambiguous in terms of absolute coordinates. By default,
CAMPARI will scan the <a href="keywords.html#ALIGNFILE">alignment set</a> and use
the molecule with the largest number of contributing atoms as the reference one.
This choice can be overridden by keyword <a href="keywords.html#XYZ_REFMOL">XYZ_REFMOL</a>.
It can be confusing that the alignment operator is derived for the image-corrected coordinate sets
yet the transformation is applied to the coordinates in their default state.
This is relevant if molecules are not found in the central unit cell
in the <a href="inputfiles.html#FMCSC_PDBFILE">trajectory files</a>. In this scenario, the output
gets particularly difficult to interpret if <a href="keywords.html#XYZ_REFMOL">XYZ_REFMOL</a>
and/or <a href="keywords.html#XYZ_FORCEBOX">XYZ_FORCEBOX</a> modify the output coordinates
as well (not recommended).<br/>
<h4><a class="NoHi" id="ALIGNFILE"><b>ALIGNFILE</b></a></h4>
If system alignment is possible and requested (&rarr; <a
 href="keywords.html#ALIGNCALC">ALIGNCALC</a>), this keyword
allows the user to supply the path and name of a mandatory input file containing an <a
 href="inputfiles.html#Atomindexinput">atomic index list</a>
defining the set of atoms to align on. For
example, in the simulation of a macromolecule with co-solutes it will
not be meaningful to use the entire set of atoms in the system as the
alignment set since the randomly
dispersed co-solutes will dominate the alignment. Instead, one will
typically want to only supply nonsymmetric protein atoms here.<br/>
This keyword serves a second purpose, <i>viz.</i>, if <a href="keywords.html#CMODE">structural
clustering</a> is requested, and if an <a href="keywords.html#CDISTANCE">RMSD distance criterion with
differing alignment and distance atom index sets</a> is desired, this keyword
lets the user specify the input file with the alignment set. Simultaneous
use of both functionalities is permitted. The converse is also possible, <i>i.e.</i>, to 
specify an additional distance set for RMSD evaluation and instantaneous output 
in the same logic. Then, keyword <a href="keywords.html#CFILE">CFILE</a> can be used to specify this
additional distance set. Lastly, note that any set used for
alignment must consist of at least three atoms.<br/>
<h4><a class="NoHi" id="POLOUT"><b>POLOUT</b></a></h4>
This keyword sets the interval how often to compute and write current
system-wide
polymeric variables (→ <a href="outputfiles.html#POLYMER.dat">POLYMER.dat</a>).
This
instantaneous output can be useful to easily monitor structural changes
(such as dimerization events) in dilute systems with heterogeneous
density. It is completely uninformative for systems with homogeneous
density. For simulations of a single polymer chain,
distributions of polymeric order parameters as well as correlation
functions can be computed
from the output in <a href="outputfiles.html#POLYMER.dat">POLYMER.dat</a>.
When CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
the computation of the system-wide gyration tensor and related properties as well as the writing to
<a href="outputfiles.html#POLYMER.dat">POLYMER.dat</a> are done by a single thread.
This happens with other threads performing other tasks concurrently (if there are any).<br/>
<h4><a class="NoHi" id="POLCALC"><b>POLCALC</b></a></h4>
This keyword lets the user specify the frequency with which values for
polymeric properties
incurring low computational cost are computed. These data are collected
and reported resolved by
analysis group and include characteristic values for shape and size,
histograms of end-to-distances, <i>etc.</i>
Setting this keyword such that polymeric analyses are performed,
several output files are generated:
(→ <a href="outputfiles.html#POLYAVG.dat">POLYAVG.dat</a>, <a
 href="outputfiles.html#RGHIST.dat">RGHIST.dat</a>,
<a href="outputfiles.html#RETEHIST.dat">RETEHIST.dat</a>, and <a
 href="outputfiles.html#RDHIST.dat">RDHIST.dat</a>).
Furthermore POLCALC controls the interval for data collection to obtain
averages of the suitably defined angular correlation function along the
polymer backbone, which may be related
to the intrinsic stiffness or persistence length of the polymer (→ <a
 href="outputfiles.html#PERSISTENCE.dat">PERSISTENCE.dat</a> and
<a href="outputfiles.html#TURNS_RES.dat">TURNS_RES.dat</a>). Lastly,
this keyword controls the
frequency for the computation and averaging of molecular, radial
density profiles, <i>i.e.</i>,
the mass distribution function along the radial coordinate originating
from the each molecule's center
of mass considering only atoms belonging to that molecule (→ <a
 href="outputfiles.html#DENSPROF.dat">DENSPROF.dat</a>).
This quantity is used in Lifshitz-type polymer theories.
When CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
these calculations are performed by a single thread while other threads perform other tasks concurrently (if there are any).<br/>
<h4><a class="NoHi" id="RHCALC"><b>RHCALC</b></a></h4>
Since the computation of comprehensive polymer-internal distances is
more expensive, this dedicated
keyword controls the data collection interval for analyses relying on
such data. A comprehensive set of internal distances in CAMPARI is used
to compute three quantities:
<ol>
  <li>An alternative estimate of the polymer's spatial size which is
sometimes related to the hydrodynamic radius
(→ corresponding entry in <a href="outputfiles.html#POLYAVG.dat">POLYAVG.dat</a>;
note that should RHCALC be set such that no analysis is performed but <a
 href="keywords.html#POLCALC">POLCALC</a> be chosen
such that the other quantities in <a
 href="outputfiles.html#POLYAVG.dat">POLYAVG.dat</a> are compute and
provided,
the corresponding column must be ignored).</li>
  <li>A scaling profile of the internal distances with distance of
separation in primary sequence (→ <a
 href="outputfiles.html#INTSCAL.dat">INTSCAL.dat</a>).</li>
  <li>The scattering (Kratky) profile of the polymer (→ <a
 href="outputfiles.html#KRATKY.dat">KRATKY.dat</a>;
this relies on the additional frequency setting <a
 href="keywords.html#SCATTERCALC">SCATTERCALC</a>).</li>
</ol>
Note that the scaling of internal distances can be used to assess
solvent quality given the simulation
of just a single polymer very efficiently. All mentioned data are
obtained resolved by analysis group. When CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
these calculations, including the dependent <a href="keywords.html#SCATTERCALC">Kratky analysis</a>,
are (at the moment) performed by a single thread while other threads perform other tasks concurrently (if there are any).
Because these analyses scale poorly with system size, they can quickly become performance-limiting, which
will similarly limit parallel efficiency.
<br/>
<h4><a class="NoHi" id="SCATTERCALC"><b>SCATTERCALC</b></a></h4>
As alluded to above, this keyword sets an auxiliary frequency for the
calculation of scattering properties
resolved by analysis group (→ <a href="outputfiles.html#KRATKY.dat">KRATKY.dat</a>).
This requires computing
Fourier transforms of internal distances for a series of wave vectors
and is consequently a very
expensive calculation. Due to the coupling to the computation of
internal distances
(see <a href="keywords.html#RHCALC">RHCALC</a>), this keyword is <b>not</b>
interpreted like the other
interval keywords (???CALC). Instead, SCATTERCALC sets the calculation
interval amongst only those steps
chosen already via <a href="keywords.html#RHCALC">RHCALC</a>. For
example, if <a href="keywords.html#RHCALC">RHCALC</a>
is 10 and SCATTERCALC is 20, then scattering data will be accumulated
every 200 steps.
The data in <a href="outputfiles.html#KRATKY.dat">KRATKY.dat</a> can
be used to compare
simulation data directly to experiment. In a double-logarithmic plot,
it may also be possible to identify
linear regimes ("power law regime" in contrast to the "Guinier regime"
for smaller wave vectors)
which can be fit to yield the scaling exponent for fractal objects.
Conversely,
for globular polymers, Porod's law may hold.<br/>
<h4><a class="NoHi" id="SCATTERRES"><b>SCATTERRES</b></a></h4>
Since the required number of points and range of wave vectors for the
prediction of scattering
profiles may be system-dependent, this keyword allows the user to
adjust the spacing of wave vectors
assuming scattering data are being calculated at all (→ <a
 href="keywords.html#RHCALC">RHCALC</a> and
<a href="keywords.html#SCATTERCALC">SCATTERCALC</a>). The first wave
vector's absolute magnitude q=|<b>q</b>|
will always be 0.5·SCATTERRES with units of Å<sup>-1</sup>. In general,
the larger the chain, the smaller the absolute magnitudes of
wave vectors needed.<br/>
<h4><a class="NoHi" id="SCATTERVECS"><b>SCATTERVECS</b></a></h4>
Since the required number of points and range of wave vectors for the
prediction of scattering
profiles may be system-dependent, this keyword allows the user to
adjust the total number of
employed wave vectors assuming scattering data are being calculated at
all
(→ <a href="keywords.html#RHCALC">RHCALC</a> and <a
 href="keywords.html#SCATTERCALC">SCATTERCALC</a>).
Together with <a href="keywords.html#SCATTERRES">SCATTERRES</a>,
this determines the range of the wave vectors. Note that generally a
coarse resolution (and hence a small number of vectors) is sufficient
as
scattering profiles tend to be very smooth functions.<br/>
<h4><a class="NoHi" id="HOLESCALC"><b>HOLESCALC</b></a></h4>
For polymers it may be interesting to analyze the distribution of
"internal" void spaces. In CAMPARI,
a rudimentary analysis routine exists which attempts to place spheres
of varying size at different
distances from the molecule's center-of-mass and to record whether any
overlap with part of the
polymer is encountered. This analysis is recorded in instantaneous
output (<a href="outputfiles.html#HOLES.dat">HOLES.dat</a>),
and the latter needs to be post-processed. Note that this analysis is
restricted to simulations of monomeric polymers.
When CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
it is performed by a single thread while other threads perform other tasks concurrently (if there are any).<br/>
<h4><a class="NoHi" id="RGBINSIZE"><b>RGBINSIZE</b></a></h4>
If standard polymeric analyses are performed (→ <a
 href="keywords.html#POLCALC">POLCALC</a>), this keyword
sets the size of the bins in Å for the three output files <a
 href="outputfiles.html#RGHIST.dat">RGHIST.dat</a>, <a
 href="outputfiles.html#RETEHIST.dat">RETEHIST.dat</a>, and <a
 href="outputfiles.html#DENSPROF.dat">DENSPROF.dat</a>. It therefore
determines the
resolution along the radius of gyration- or related axes.<br/>
<h4><a class="NoHi" id="POLRGBINS"><b>POLRGBINS</b></a></h4>
If standard polymeric analyses are performed (→ <a
 href="keywords.html#POLCALC">POLCALC</a>), this keyword
can be used to set the number of bins of size <a
 href="keywords.html#RGBINSIZE">RGBINSIZE</a>
for the three output files <a href="outputfiles.html#RGHIST.dat">RGHIST.dat</a>,
<a href="outputfiles.html#RETEHIST.dat">RETEHIST.dat</a>, and <a
 href="outputfiles.html#DENSPROF.dat">DENSPROF.dat</a>.
Since quantities like the radius of gyration or end-to-end distances
are strongly
system-dependent, it is up to the user to ensure the appropriate number
of bins. Note that - just like all other histograms in CAMPARI -
terminal
bins will be overstocked should range exceptions occur.<br/>
<h4><a class="NoHi" id="PHOUT"><b>PHOUT</b></a></h4>
This keyword controls the frequency how often to output ionization
states of certain ionizable residues.
Currently, this analysis relies on pseudo-Monte Carlo moves (see <a
 href="keywords.html#PHFREQ">PHFREQ</a>)
to work and is therefore only available in straight MC runs. Further
limitations
are listed in the descriptions of <a href="keywords.html#PHFREQ">sampler</a>
and <a href="outputfiles.html#PHTIT.dat">output file</a>.<br/>
<h4><a class="NoHi" id="ANGCALC"><b>ANGCALC</b></a></h4>
This keyword lets the user define the interval how often to extract
polypeptide backbone torsion angle statistics,
<i>i.e.</i>, how often to go through all non-terminal polypeptide
residues and bin values for the φ/ψ-angles into a
two-dimensional histogram. This keyword also controls the data collection
frequency for estimation of vicinal NMR J-coupling
constants (H<sub>N</sub> to H<sub>α</sub> → <a
 href="outputfiles.html#JCOUPLING.dat">JCOUPLING.dat</a>). The
Ramachandran
analysis itself is reported globally in a file called <a
 href="outputfiles.html#RAMACHANDRAN.dat">RAMACHANDRAN.dat</a>. Due to
the system-wide averaging
(including over molecules of different type), this is probably most
meaningful for simulations of single homopolymers.
For more detailed control, further output files may be obtained: <a
 href="outputfiles.html#RESRAMA_xxxxx.dat">residue-specific</a>
as well as <a href="outputfiles.html#MOLRAMA_xxxxx.dat">analysis
group-specific</a> maps should requests have been provided via
keywords <a href="keywords.html#RAMARES">RAMARES</a> and <a
 href="keywords.html#RAMAMOL">RAMAMOL</a>, respectively.
When CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
these analyses are performed by a single thread while other threads perform other tasks concurrently (if there are any).<br/>
<h4><a class="NoHi" id="ANGRES"><b>ANGRES</b></a></h4>
This keyword matters only if <a href="keywords.html#ANGCALC">ANGCALC</a>
is chosen such that polypeptide backbone
φ/ψ-statistics are accumulated. If so, it sets the resolution in
degrees for such angular distribution functions.
The smallest permissible value at the moment is 1.0°.<br/>
<h4><a class="NoHi" id="RAMARES"><b>RAMARES</b></a></h4>
This keyword matters only if polypeptide φ/ψ-analysis is requested (→ <a
 href="keywords.html#ANGCALC">ANGCALC</a>).
If so, it allows the user to monitor the distributions specifically for
selected polypeptide residues in the system.
The first entry, which defaults to zero, specifies the number of such
specific requests. The user then has to provide the
appropriate number of integer values (residue numbers as defined per <a
 href="inputfiles.html#FMCSC_SEQFILE">sequence input</a>)
on that same line in the key-file. The maximum number for individually
monitored residues is limited to 1000, but even this requires increasing the default string length
CAMPARI assumes (in a file called <a href="../source/macros.i">macros.i</a>) <i>during compilation</i>.
Successful requests (those pointing to
non-polypeptide, non-existing, or terminal residues
will be ignored) will create output files like "<a
 href="outputfiles.html#RESRAMA_xxxxx.dat">RESRAMA_00024.dat</a>".<br/>
<h4><a class="NoHi" id="RAMAMOL"><b>RAMAMOL</b></a></h4>
This keyword is exactly analogous to <a href="keywords.html#RAMARES">RAMARES</a>
only that it operates not on residue but on analysis groups (all residues of
all molecules in that analysis group are pooled, numbering as reported
initially in the log-output).
It will create files like "<a href="outputfiles.html#MOLRAMA_xxxxx.dat">MOLRAMA_00002.dat</a>".<br/>
<h4><a class="NoHi" id="INTCALC"><b>INTCALC</b></a></h4>
This keyword sets the interval how often to compute comprehensive
statistics for
typical internal coordinates of the system, <i>i.e.</i>, all bond
lengths,
angles, torsional angles, as well as improper
torsional angles (trigonal-planar centers - consult <a
 href="parameters.html#S9_Bonded_types">PARAMETERS</a> for further details). Note that
molecular topology defines
which atom pairs - for example - share a bond. With this analysis, it
is therefore <b>not</b>
possible to analyze arbitrarily defined distances, angles, and
torsion angles in the system. If turned on, up to five different output files
are provided, namely <a href="outputfiles.html#INTERNAL_COORDS.idx">INTERNAL_COORDS.idx</a>,
<a href="outputfiles.html#INTHISTS_BL.dat">INTHISTS_BL.dat</a>,
<a href="outputfiles.html#INTHISTS_BA.dat">INTHISTS_BA.dat</a>, <a href="outputfiles.html#INTHISTS_DI.dat">INTHISTS_DI.dat</a>,
and <a href="outputfiles.html#INTHISTS_IM.dat">INTHISTS_IM.dat</a>.
When CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
all of these analyses are performed (in sequence) by a single thread while other threads perform other tasks concurrently (if there are any).<br/>
<h4><a class="NoHi" id="WHICHINT"><b>WHICHINT</b></a></h4>
This is one of the few keywords expecting multiple inputs and
matters only if internal coordinate analysis is requested (→ <a
 href="keywords.html#INTCALC">INTCALC</a>).
Four integers should be provided and each one is interpreted as a
logical to turn on individual groups of
internal coordinate analyses. The first turns on the calculation of
<a href="outputfiles.html#INTHISTS_BL.dat">bond length histograms</a>,
the second that of
<a href="outputfiles.html#INTHISTS_BA.dat">bond angle histograms</a>,
the third that of
<a href="outputfiles.html#INTHISTS_IM.dat">improper dihedral angle
histograms</a>, and the fourth that of
<a href="outputfiles.html#INTHISTS_DI.dat">proper torsional angle
histograms</a>. Note that the number of possible internal coordinates
quickly exceeds the number of atoms for any
complex molecule. These analyses can therefore easily become fairly
time-consuming as well as data-rich (in terms of
the sizes of the output files). This is one of the reasons for
introducing this selection mechanism.
The other lies simply in the fact that in any simulation using
CAMPARI-typical torsional space constraints
(see <a href="keywords.html#CARTINT">CARTINT</a>) analyses of bond
length, angle, and improper dihedral
distribution is meaningless.<br/>
<h4><a class="NoHi" id="SEGCALC"><b>SEGCALC</b></a></h4>
This keyword lets the user specify the interval how often to scan the
polypeptide backbone for stretches of similar
secondary structure (as defined in the specified file through <a
 href="inputfiles.html#FMCSC_BBSEGFILE">FMCSC_BBSEGFILE</a>).
The annotation - in contrast to <a href="keywords.html#DSSPCALC">DSSP</a>
- is obtained purely on torsional criteria and relies
on defining consensus regions within φ/ψ-space. These consensus
definitions are found in a supplied
data file (→ <a href="inputfiles.html#FMCSC_BBSEGFILE">BBSEGFILE</a>).
At the end of the simulation results are written to
files named <a href="outputfiles.html#BB_SEGMENTS_NORM.dat">BB_SEGMENTS_NORM.dat</a>,
<a href="outputfiles.html#BB_SEGMENTS_NORM_RES.dat">BB_SEGMENTS_NORM_RES.dat</a>,
<a href="outputfiles.html#BB_SEGMENTS.dat">BB_SEGMENTS.dat</a>,
and <a href="outputfiles.html#BB_SEGMENTS_RES.dat">BB_SEGMENTS_RES.dat</a>
This analysis is resolved by analysis group and useful to identify coarse
secondary
structure propensities in polypeptides. As an example, the data in <a
 href="outputfiles.html#BB_SEGMENTS_NORM_RES.dat">BB_SEGMENTS_NORM_RES.dat</a>
can be used to compute parameters of the helix-coil transition
according to the <a href="references.html#ref23_14">Lifson-Roig</a> formalism
(see for example <a href="tutorial3.html">Tutorial 3</a> or this <a href="references.html#ref24_11">reference</a>).
SEGCALC also controls the computation of global (at a molecular level)
secondary structure order parameters f<sub>α</sub> and f<sub>β</sub>
(which are also used for the corresponding bias potentials → <a href="keywords.html#SC_ZSEC">SC_ZSEC</a> used in 
<a href="tutorial9.html">Tutorial 9</a> or this <a href="references.html#ref24_5">reference</a>).
Various distribution histograms are written to files <a href="outputfiles.html#ZSEC_HIST.dat">ZSEC_HIST.dat</a>,
<a href="outputfiles.html#ZSEC_HIST.dat">ZAB_2DHIST.dat</a>,
and <a href="outputfiles.html#ZSEC_HIST.dat">ZBETA_RG.dat</a>.
Analysis of these order parameters is similarly performed in analysis
group-resolved fashion. When CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
both of these analyses are performed sequentially by a single thread while other threads perform other tasks concurrently (if there are any).<br/>
<h4><a class="NoHi" id="DSSPCALC"><b>DSSPCALC</b></a></h4>
This keyword specifies how frequently to perform DSSP analysis. DSSP is
a secondary
structure assignment procedure for proteins (<a
 href="references.html#ref20_1">reference</a>). All
eligible (<i>i.e.</i>, full peptide) residues are scanned for
backbone-backbone
hydrogen bond patterns and various statistics and running output is
provided if so desired (see <a href="outputfiles.html#DSSP_NORM_RES.dat">DSSP_NORM_RES.dat</a>, <a href="outputfiles.html#DSSP_NORM.dat">DSSP_NORM.dat</a>,
<a href="outputfiles.html#DSSP.dat">DSSP.dat</a>,
<a href="outputfiles.html#DSSP_RES.dat">DSSP_RES.dat</a>, <a href="outputfiles.html#DSSP_HIST.dat">DSSP_HIST.dat</a>,
<a href="outputfiles.html#DSSP_EH_HIST.dat">DSSP_EH_HIST.dat</a>, and <a href="outputfiles.html#DSSP_RUNNING.dat">DSSP_RUNNING.dat</a>).
The DSSP results typically complement the results from backbone segment statistics (see
for example <a href="outputfiles.html#BB_SEGMENTS_NORM_RES.dat">BB_SEGMENTS_NORM_RES.dat</a>)
well as the former are based
exclusively on hydrogen bond patterns while the latter are based
exclusively on dihedral angles. When CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
the DSSP analysis is performed by a single thread while other threads perform other tasks concurrently (if there are any).
Similar to <a href="keywords.html#CONTACTCALC">contact analyses</a>, the determination of the hydrogen bond patterns
scales, at some level, poorly with system size. They thus can become performance-limiting, which
will similarly limit parallel efficiency.<br/>
<h4><a class="NoHi" id="INSTDSSP"><b>INSTDSSP</b></a></h4>
If DSSP analysis is requested (→ <a href="keywords.html#DSSPCALC">DSSPCALC</a>),
this keyword
is interpreted as a simple logical whether to write out running traces
of the full
DSSP assignment for the current snapshot (see <a href="outputfiles.html#DSSP_RUNNING.dat">DSSP_RUNNING.dat</a>). This
can be useful when analyzing <a href="keywords.html#PDBANALYZE">input trajectories</a> or even individual
pdb-structures with CAMPARI. Instantaneous DSSP output is currently not
supported for MPI-averaging calculations (see <a href="keywords.html#MPIAVG">MPIAVG</a>).
This output file can easily become very large, and it is possible for significant I/O lag
to occur because of this.<br/>
<h4><a class="NoHi" id="DSSP_MODE"><b>DSSP_MODE</b></a></h4>
Based on DSSP analysis (→ <a href="keywords.html#DSSPCALC">DSSPCALC</a>),
the
code computes two order parameters to measure canonical
secondary structure content. The E-score corresponds
to the β-content and the H-score to the
α-content. they are system-wide quantities and are computed as
follows: <br/>
<br/>
&nbsp;&nbsp; E-score = E-fraction · ( H-bond-Score_E )<sup>1/n</sup><br/>
&nbsp;&nbsp; H-score = H-fraction · ( H-bond-Score_H )<sup>1/n</sup><br/>
<br/>
Here, E-fraction and H-fraction are simply the fractions of
residues which are assigned E or H according to DSSP. n is an arbitrary
scaling exponent (see <a href="keywords.html#DSSP_EXP">DSSP_EXP</a>).
H-bond-Score_E is a
continuous variable which measures the mean quality of the hydrogen
bonds forming the β-sheets in the system and
H-bond-Score_H is the analog for α-helices. In principle, all the
hydrogen bond energies are collected and divided by the value for the
same number of good hydrogen bonds (see <a
 href="keywords.html#DSSP_GOODHB">DSSP_GOODHB</a>).
The quantity can be capped, however, based on the choice for <a
 href="keywords.html#DSSP_MODE">DSSP_MODE</a>:<br/>
<ol>
  <li>Every hydrogen bond can maximally contribute the value of <a
 href="keywords.html#DSSP_GOODHB">DSSP_GOODHB</a>. Therefore,
H-bond-Score_X is always less than unity and only approaches unity if
each and every relevant H-bond is at least as favorable as the cutoff
given by <a href="keywords.html#DSSP_GOODHB">DSSP_GOODHB</a>. This is
the most
stringent score. The resultant X-scores
will always be less or equal to the corresponding X-fractions. </li>
  <li>Every hydrogen bond can maximally contribute <a
 href="keywords.html#DSSP_MINHB">DSSP_MINHB</a> which is always more
negative than <a href="keywords.html#DSSP_GOODHB">DSSP_GOODHB</a>. The
value of H-bond-Score_X, however, is capped to be at most unity. In
this score, very strong H-bonds can compensate the effects of a few
weak ones but the value for X-score still is
capped by the corresponding X-fraction.</li>
  <li>Every hydrogen bond can maximally contribute <a
 href="keywords.html#DSSP_MINHB">DSSP_MINHB</a>. The value of
H-bond-Score_X is not capped and can adopt values larger than unity.
The X-score is capped, however, to
never exceed unity. This is the most lenient score and the only one in
which X-score can exceed the value of X-fraction.</li>
</ol>
Through the H-bond weighting two things are achieved: i) instead
of the inherently discreet X-fractions, smooth and continuous
distributions are obtained for X-score, and ii) it
removes redundancy in which secondary structure elements with
predominantly weak H-bonds are indistinguishable from perfect,
canonical secondary structure elements when using X-fraction. The limit
of X-score ≡ X-fraction is of course obtained for n
→ ∞.
<h4><a class="NoHi" id="DSSP_EXP"><b>DSSP_EXP</b></a></h4>
For the DSSP analysis in CAMPARI (→ <a href="keywords.html#DSSPCALC">DSSPCALC</a>),
this keyword choose
the integer scaling exponent for the H-bond term in
computing E- and H-scores (see <a href="keywords.html#DSSP_MODE">DSSP_MODE</a>).<br/>
<h4><a class="NoHi" id="DSSP_GOODHB"><b>DSSP_GOODHB</b></a></h4>
For the DSSP analysis in CAMPARI (→ <a href="keywords.html#DSSPCALC">DSSPCALC</a>),
this keyword
defines the standard energy for a "good" hydrogen bond. This is used to
evaluate the smoothed E- and H-scores (see <a
 href="keywords.html#DSSP_MODE">DSSP_MODE</a>) and not part of the
original DSSP standard.
Permissible values lie between -1.0 and -4.0 kcal/mol.<br/>
<h4><a class="NoHi" id="DSSP_MINHB"><b>DSSP_MINHB</b></a></h4>
For DSSP analysis (→ <a href="keywords.html#DSSPCALC">DSSPCALC</a>),
this keyword specifies the minimal (= lowest possible = most favorable)
energy for any hydrogen bond.
Since the DSSP-formula is based on inverse distances it
is useful to introduce this lower cap such that
conformations with steric overlap do not overly bias the analysis (for
example in pdb-analyses → <a href="keywords.html#PDBANALYZE">PDBANALYZE</a>).
Permissible
values
lie between -10.0 and -4.0 kcal/mol.<br/>
<h4><a class="NoHi" id="DSSP_MAXHB"><b>DSSP_MAXHB</b></a></h4>
For DSSP analysis (→ <a href="keywords.html#DSSPCALC">DSSPCALC</a>),
this keyword allows the
user to define the maximal (= highest possible = least favorable)
energy fo any
hydrogen bond. This is the fundamental cutoff for DSSP to consider
H-bonds and therefore a very important quantity for
the analysis to be meaningful. The recommended value is -0.5 kcal/mol
but values between -1.0 and 0.0 kcal/mol are allowed.<br/>
<h4><a class="NoHi" id="DSSP_CUT"><b>DSSP_CUT</b></a></h4>
For DSSP analysis (→ <a href="keywords.html#DSSPCALC">DSSPCALC</a>),
this keyword defines the distance cutoff
applied to the C<sub>α</sub>-atoms of two peptide residues to consider
them for hydrogen bonds. This can be
relatively short (defaults to 10 Å) but the accuracy
hinges on the choice for <a href="keywords.html#DSSP_MAXHB">DSSP_MAXHB</a>.
Consistency
has to be ensured by the user. Using a C<sub>α</sub> cutoff for
pre-screening of residue pairs significantly reduces the computation
time needed by the DSSP analysis.<br/>
<h4><a class="NoHi" id="CONTACTCALC"><b>CONTACTCALC</b></a></h4>
This keyword specifies the interval how often to perform contact
analysis, <i>i.e.</i>, how often to get
information about which and how many solute residues are close to each
other. Such contacts are generally calculated according to two definitions in CAMPARI; by
considering center-of-mass distances and by considering minimum atom-atom distances
(both applied to pairs of residues). The output includes a map of average contact frequencies (<a href="outputfiles.html#CONTACTMAP.dat">CONTACTMAP.dat</a>),
histograms of contact numbers (<a href="outputfiles.html#CONTACT_HISTOGRAMS.dat">CONTACT_HISTOGRAMS.dat</a>),
and a dependent analysis of solution structure by molecule
(<a href="outputfiles.html#CLUSTERS.dat">CLUSTERS.dat</a>, <a href="outputfiles.html#MOLCLUSTERS.dat">MOLCLUSTERS.dat</a>,
and <a href="outputfiles.html#COOCLUSTERS.dat">COOCLUSTERS.dat</a>).
The last analysis relies on an additional keyword: <a href="keywords.html#CLUSTERCALC">CLUSTERCALC</a>.
Note that these analyses are always restricted to residues of molecules tagged as solutes
(→ "<a href="inputfiles.html#FMCSC_ANGRPFILE">FMCSC_ANGRPFILE</a>)
in order to facilitate frequent contact analysis even if solute
molecules are explicitly represented (which may be prohibitively expensive otherwise).
When CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
contact analysis is performed by a single thread while other threads perform other tasks concurrently (if there are any).
Similar to <a href="keywords.html#DSSPCALC">DSSP analyses</a>, the determination of spatial proximity
patterns scales, at some level, poorly with system size and can thus become performance-limiting, which
will similarly limit parallel efficiency.<br/>
<h4><a class="NoHi" id="CLUSTERCALC"><b>CLUSTERCALC</b></a></h4>
This keyword (along with <a href="keywords.html#CONTACTCALC">CONTACTCALC</a>)
controls the computation frequency for solute cluster
statistics (<i>i.e.</i>, cluster sizes, cluster contact orders, and
molecule-resolved cluster statistics) where a cluster is
defined through the minimum atom-atom distance contact definition
(between any pair of residues). Note that this is the
interval at which to perform cluster analysis from within the
calculation of contacts (<i>i.e.</i>, <a
 href="keywords.html#CLUSTERCALC">CLUSTERCALC</a>
is relative to <a href="keywords.html#CONTACTCALC">CONTACTCALC</a>, as
<a href="keywords.html#SCATTERCALC">SCATTERCALC</a> is to <a
 href="keywords.html#RHCALC">RHCALC</a>). The reason is that the
cluster detection algorithm relies on the determination of contacts but that
it may not always be a meaningful analysis to perform (see <a
 href="outputfiles.html#CLUSTERS.dat">CLUSTERS.dat</a>,
<a href="outputfiles.html#MOLCLUSTERS.dat">MOLCLUSTERS.dat</a>, and <a
 href="outputfiles.html#COOCLUSTERS.dat">COOCLUSTERS.dat</a> for
further details on the output).<br/>
<h4><a class="NoHi" id="CONTACTOFF"><b>CONTACTOFF</b></a></h4>
If contact analysis is requested (→ <a href="keywords.html#CONTACTCALC">CONTACTCALC</a>),
this
keyword defines a sequence-space offset to exclude neighboring residues
from
the analysis. For topologically connected systems (<i>i.e.</i>, polymer
chains) data for near-neighbor contacts such as i↔i+1 may be
uninformative as they will always be in contact
on account of the underlying topology. Note that the omission only
applies to intramolecular
contacts.
Setting this to zero includes everything (even i↔i),
and any larger integer lets the analysis start from this distance. The
default here is zero, and there is rarely a reason to change it.<br/>
<h4><a class="NoHi" id="CONTACTMIN"><b>CONTACTMIN</b></a></h4>
For contact and cluster analysis (→ <a href="keywords.html#CONTACTCALC">CONTACTCALC</a>),
this keyword provides
the threshold value for of a residue-residue contact in Å. Here, the
threshold is applied to the minimum distance between
any arbitrary pair of atoms formed by the two residues in question.
This defaults to 5.0 Å. Note that this
computationally more expensive definition has the advantage of
rendering the contact probabilities more or less
size-independent for polyatomic residues. In the presence of excluded
volume interactions, monoatomic residues
(ions) of different size will still yield contact statistics which
include physically meaningless biases, however.<br/>
<h4><a class="NoHi" id="CONTACTCOM"><b>CONTACTCOM</b></a></h4>
For contact and cluster analysis (→ <a href="keywords.html#CONTACTCALC">CONTACTCALC</a>),
this keyword gives the alternative threshold value for a
residue-residue contact in Å. Here, the threshold applies to the
distance between the centers of mass
of the two residue it question. It also defaults to 5.0 Å. Note that
(in the presence of excluded volume
interactions) contact probabilities obtained this way are by design
dependent on
the size of the interacting residues and results may be misleading if
contact statistics between pairs of residues with highly
variable size are compared.<br/>
<h4><a class="NoHi" id="PCCALC"><b>PCCALC</b></a></h4>
This keyword allows the user to specify how often to perform pair
correlation analysis, <i>i.e.</i>, get distance
counts for a variety of intra- and intermolecular distances and - in
the case of intermolecular
distances - proper normalization by the current volume element. It
controls the computation frequency for three different
classes of distance distributions:<br/>
<ol>
  <li>Generic intramolecular amide-amide distributions covering various
acceptor-donor pairs, as well as a centroid-centroid distribution (→ <a href="outputfiles.html#AMIDES_PC.dat">AMIDES_PC.dat</a>),
only relevant for polypeptide systems.</li>
  <li>Generic intermolecular pair correlation functions for solutes
(→ <a href="outputfiles.html#RBC_PC.dat">RBC_PC.dat</a>), only relevant
for systems with more than one solute. Note that this option can consume
inordinate amounts of memory should a lot of different solute types
be present. Workarounds consist of disabling this analysis or of
using the <a href="keywords.html#ANGRPFILE">analysis group feature</a>
to redeclare most of those as solvent molecule types and to use specific atom-atom
distributions instead.</li>
  <li>Specific atom-atom distributions and/or pair correlation
functions as defined through an
index file provided by keyword <a href="inputfiles.html#FMCSC_PCCODEFILE">PCCODEFILE</a>
(→ <a href="outputfiles.html#GENERAL_PC.dat">GENERAL_PC.dat</a>).</li>
</ol>
Note that analysis groups are respected by both the output in <a href="outputfiles.html#RBC_PC.dat">RBC_PC.dat</a>
and in <a href="outputfiles.html#GENERAL_PC.dat">GENERAL_PC.dat</a>. The user-defined 
requests, unlike the centroid-centroid distributions, ignore whether a molecule is tagged
as solvent or solute (&rarr; <a href="keywords.html#ANGRPFILE">ANGRPFILE</a>). Conversely, the output 
in <a href="outputfiles.html#AMIDES_PC.dat">AMIDES_PC.dat</a> is not controllable in any way,
and the results are usable only for very specialized applications.<br/>
When CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
each of these 3 analyses is treated independently. This means that each one is executed by a single thread
while other threads perform other tasks concurrently (if there are any).<br/>
<h4><a class="NoHi" id="DO_AMIDEPC"><b>DO_AMIDEPC</b></a></h4>
If pair correlation analysis is requested (→ <a
 href="keywords.html#PCCALC">PCCALC</a>), this keyword enables the user
to disable the computation of intramolecular amide-amide distance
distribution functions
(→ <a href="outputfiles.html#AMIDES_PC.dat">AMIDES_PC.dat</a>) by
setting it to zero.
<h4><a class="NoHi" id="PCBINSIZE"><b>PCBINSIZE</b></a></h4>
This keyword specifies the distance bin size in Å for pair correlation
analysis
(→ <a href="keywords.html#PCCALC">PCCALC</a>).<br/>
<h4><a class="NoHi" id="PCCODEFILE"><b>PCCODEFILE</b></a></h4>
This keyword specifies the path and filename to the input file for
requesting specific pair correlation or distance distribution analyses (see <a
 href="inputfiles.html#FMCSC_PCCODEFILE">FMCSC_PCCODEFILE</a>). It is 
also possible to generate instantaneous traces for the selected distances with
keyword <a href="keywords.html#INSTGPC">INSTGPC</a>.
In general, the input is rather flexible and it is possible to
pool many analogous or even unrelated atom-atom distances
under a certain code or to use unique codes for
very specific requests. Upon successful parsing of the input and given
that pair correlation analysis
is globally requested (→ <a href="keywords.html#PCCALC">PCCALC</a>),
the output file
<a href="outputfiles.html#GENERAL_PC.dat">GENERAL_PC.dat</a> is created.<br/>
<h4><a class="NoHi" id="GPCREPORT"><b>GPCREPORT</b></a></h4>
This logical keyword instructs CAMPARI whether or not to write out a
summary of the terms requested
through <a href="inputfiles.html#FMCSC_PCCODEFILE">FMCSC_PCCODEFILE</a>
(→ <a href="outputfiles.html#GENERAL_PC.idx">GENERAL_PC.idx</a>). It
is only available if distance distribution /
pair correlation analysis is in use (→ <a href="keywords.html#PCCALC">PCCALC</a>).<br/>
<h4><a class="NoHi" id="INSTGPC"><b>INSTGPC</b></a></h4>
This keyword lets the user instruct CAMPARI how often to print out instantaneous values
for all the specific distances selected via <a href="inputfiles.html#FMCSC_PCCODEFILE">FMCSC_PCCODEFILE</a>.
Note that this does not include the generic distances CAMPARI analyzes, and consequently the
keyword has no effect if no usable input has been provided via
<a href="inputfiles.html#FMCSC_PCCODEFILE">FMCSC_PCCODEFILE</a> or of course if 
<a href="keywords.html#PCCALC">pair correlation analysis</a> is not in use.
This keyword is understood as a dependent frequency, <i>i.e.</i>, a setting of 1 
will print instantaneous values for every <a href="keywords.html#PCCALC">PCCALC</a><sup>th</sup>
step. Note that this feature is disabled by default and that the output in 
<a href="outputfiles.html#GENERAL_DIS.dat">GENERAL_DIS.dat</a> can easily become large.<br/>
<h4><a class="NoHi" id="SAVCALC"><b>SAVCALC</b></a></h4>
This keyword specifies how often to compute (or record) solvent-accessible
volume (SAV) fractions and solvation states for the system.
If the ABSINTH implicit solvent model is in use (→ <a href="keywords.html#SC_IMPSOLV">SC_IMPSOLV</a>),
this analysis can rely on the current values for those quantities (no additional, computational cost);
otherwise computing atomic SAV fractions incurs a moderate computational cost.
The solvent-accessible volume will globally depend on the choice for the thickness
of the assumed solvation shell (&rarr; <a href="keywords.html#SAVPROBE">SAVPROBE</a>). The mapped
solvation states as reported for individual atoms (please refer to the
<a href="references.html#ref19_1">ABSINTH publication</a> for details) will depend on further ABSINTH
parameters. Some of these can be adjusted through patches, <i>e.g.</i>, user-supplied values for
<a href="inputfiles.html#FMCSC_SAVPATCHFILE">overlap reduction factors</a>.<br/>
SAV analysis creates at most three output files; an instantaneous one (<a
 href="outputfiles.html#SAV.dat">SAV.dat</a>) that depends on auxiliary keyword
<a href="keywords.html#INSTSAV">INSTSAV</a>, an atom-resolved output file that
reports simulation averages (&rarr; <a href="outputfiles.html#SAV_BY_ATOM.dat">SAV_BY_ATOM.dat</a>), and
finally a file containing distribution functions (histograms) for selected atoms for
those quantities (&rarr; <a href="outputfiles.html#SAV_HISTS.dat">SAV_HISTS.dat</a>). The latter
file is dependent on another auxiliary keyword, <i>i.e.</i>, <a href="keywords.html#SAVATOMFILE">SAVATOMFILE</a>.
The instantaneous output is primarily useful as a diagnostic tool for the system while the simulation is
running, and to be able to compute correlation functions, multidimensional histograms, <i>etc.</i> for quantities related 
to the solvation of specific sites on macromolecules. Please refer to the
descriptions of the output files for further details.<br/>
When CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
the SAV analysis is handled by a single thread while threads perform other tasks concurrently (if there are any).
However, if the <a href="keywords.html#SC_IMPSOLV">ABSINTH DMFI</a> is turned on, the analysis task simply
consists of recording the values. Conversely, the evaluation of the DMFI is thread-assisted as usual.<br/>
<h4><a class="NoHi" id="INSTSAV"><b>INSTSAV</b></a></h4>
If analysis of solvent-accessible volume fractions is requested (&rarr; <a href="keywords.html#SAVCALC">SAVCALC</a>),
this keyword allows the user to have a quantity related to the total SAV along with a running average being printed
to a dedicated output file (&rarr; <a href="outputfiles.html#SAV.dat">SAV.dat</a>). In addition, the values for SAV fractions
for selected atoms (via <a href="keywords.html#SAVATOMFILE">SAVATOMFILE</a>) are written out. The latter 
allows the construction of correlation functions, multidimensional histograms, <i>etc.</i> The keyword (positive integer) is
interpreted as a print-out frequency relative to the frequency with which SAV analysis is performed
<i>per se</i>. This means that the effective print-out frequency will be
<a href="keywords.html#SAVCALC">SAVCALC</a>&#183;INSTSAV. Depending on the choices, 
the resultant output file can easily become very large, and it is possible for significant I/O lag
to occur because of this.<br/>
<h4><a class="NoHi" id="SAVATOMFILE"><b>SAVATOMFILE</b></a></h4>
If analysis of solvent-accessible volume fractions is requested (&rarr; <a href="keywords.html#SAVCALC">SAVCALC</a>), this keyword 
specifies the location and name of a simple input file (list of atomic indices, format is described <a href="inputfiles.html#Atomindexinput">elsewhere</a>)
that allows the user to select a subset of the system's atoms for creating histograms of both SAV fraction and
resultant solvation state (see <a href="keywords.html#SAVCALC">above</a>). These histograms are written to
a dedicated output file (&rarr; <a href="outputfiles.html#SAV_HISTS.dat">SAV_HISTS.dat</a>). In addition,
if instantaneous output of SAV-related quantities is requested (&rarr; <a href="keywords.html#INSTSAV">INSTSAV</a>), 
the values for the SAV fractions for the selected atoms are written to the corresponding output file
 (<a href="outputfiles.html#SAV.dat">SAV.dat</a>). Note that instantaneous values for the SAV fractions allow
manual computing (during post-processing) of solvation states (using parameters set in the key-file and/or reported 
in <a href="outputfiles.html#SAV_BY_ATOM.dat">SAV_BY_ATOM.dat</a>, and using the <a href="references.html#ref19_1">reference publication</a>
to retrieve the necessary expressions). It should be kept in mind that with normal settings for <a href="keywords.html#SAVPROBE">SAVPROBE</a>,
SAV fractions of nearby atoms are tightly coupled. This means for example that requesting information for atoms that are covalently bound
will rarely yield additional information. Lastly, the binning for the histograms is fixed and uses 100 bins across the interval
from zero to unity (both quantities are restricted to this interval).<br/>
<h4><a class="NoHi" id="NUMCALC"><b>NUMCALC</b></a></h4>
This keyword is relevant only when the chosen thermodynamic <a href="keywords.html#ENSEMBLE">ensemble</a> allows for
particle number fluctuations (simulation is performed in the
(semi-)grand canonical ensemble). It then specifies the number of Monte
Carlo steps between successive accumulations of number-present
histograms
for each fluctuating particle type. For a description of the
corresponding output file please refer to
<a href="outputfiles.html#PARTICLENUMHIST.dat">PARTICLENUMHIST.dat</a>.
<h4><a class="NoHi" id="COVCALC"><b>COVCALC</b></a></h4>
This simple keyword instructs CAMPARI to collect raw data (signal
trains) for select degrees of freedom
in the system (currently this is restricted to all flexible dihedral angles → <a
 href="outputfiles.html#TRCV_xxx.tmp">TRCV_xxx.tmp</a>)
every <a href="keywords.html#COVCALC">COVCALC</a> steps. This is 
a near-obsolete functionality that has large practical and technical overlaps with the output written
to <a href="outputfiles.html#FYC.dat">FYC.dat</a> via <a href="keywords.html#TOROUT">TOROUT</a>.
It was meant to provide intrinsic support for variance/covariance
analyses, <i>e.g.</i>, with the ultimate goal of performing dimensionality reduction.
Given that merely raw data are provided and that dihedral angle data
are generally <i>circular</i> (periodic) variables requiring the use of circular
statistics (not as trivial as it may sound), usage of this facility is generally
not recommended. This
option is available in
different modes (see <a href="keywords.html#COVMODE">COVMODE</a>) and
may eventually be revived or extended later. Note that CAMPARI can perform
intrinsic principal component analysis (PCA) and time-lagged independent component analysis (tICA) as part of the structural
clustering facility (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a> and
<a href="keywords.html#PCAMODE">PCAMODE</a>).<br/>
<h4><a class="NoHi" id="COVMODE"><b>COVMODE</b></a></h4>
This keywords chooses between (currently) two types of raw data to be
provided by CAMPARI in output files
<a href="outputfiles.html#TRCV_xxx.tmp">TRCV_xxx.tmp</a>. It can be set
to:<br/>
<ol>
  <li>Internal degrees of freedom (<i>i.e.</i>, torsions) directly in
torsional space (radian)</li>
  <li>Internal degrees of freedom (<i>i.e.</i>, torsions) expressed as
their cosine and sine components</li>
<!--
 <li>Linear combinations of (evtl. sin/cos-terms
of)
torsions (see keyword <a href="keywords.html#TORLCFILE">TORLCFILE</a>
and descr. in <a href="inputfiles.html#FMCSC_TORLCFILE">INPUTFILES</a> for
details: this option is currently not supported)</li>
-->
</ol>
As alluded to above (<a href="keywords.html#COVCALC">COVCALC</a>), more
options may be added in the future. In all cases, more documentation is found for <a href="outputfiles.html#TRCV_xxx.tmp">TRCV_xxx.tmp</a>.<br/>
<h4><a class="NoHi" id="DIPCALC"><b>DIPCALC</b></a></h4>
This keyword specifies how often to compute molecular and residue-wise
dipole moments
for net-neutral molecules (or residues). Because the analysis relies on
atomic
partial charges, dipole analysis requires <a
 href="keywords.html#SC_POLAR">SC_POLAR</a> to be set to
a value larger than zero as charges are otherwise not assigned.
The (somewhat preliminary) analysis produces output files <a
 href="outputfiles.html#MOLDIPOLES.dat">MOLDIPOLES.dat</a> and <a
 href="outputfiles.html#RESDIPOLES.dat">RESDIPOLES.dat</a>.
When CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
these analyses are executed by a single thread while other threads perform other tasks concurrently (if there are any).<br/>
<h4><a class="NoHi" id="EMCALC"><b>EMCALC</b></a></h4>
This keyword specifies how often to compute spatial density distributions for the 
simulated system. If the <a href="keywords.html#SC_EMICRO">density restraint potential</a> is in use,
this analysis is automatically performed at every step given that it is
computed regardless. The result is an averaged density on a three-dimensional grid
of dimensions controlled generally by keywords <a href="keywords.html#EMDELTAS">EMDELTAS</a>
and <a href="keywords.html#SIZE">SIZE</a>. For nonperiodic boundaries, the evaluation grid 
is or can not be mapped to the system dimensions exactly, and keyword <a href="keywords.html#EMBUFFER">EMBUFFER</a>
becomes relevant. When using the <a href="keywords.html#SC_EMICRO">density restraint potential</a>
the grid serves both the purpose of analysis as described here, and the purpose of 
evaluating the potential itself, which implies that it is an option to adopt the grid dimensions
from the <a href="keywords.html#EMMAPFILE">input density map</a>. This is the default
behavior for a cuboid system with 3D periodic boundary conditions when <a href="keywords.html#EMDELTAS">EMDELTAS</a> is not provided.<br/>
The resultant spatial density is that of a given atomic property selected by keyword
<a href="keywords.html#EMPROPERTY">EMPROPERTY</a>. It is written to an output file
in <a href="references.html#ref16_1">NetCDF format</a>, an external library required to use this feature.
The details of the file format CAMPARI use are described <a href="inputfiles.html#FMCSC_EMMAPFILE">elsewhere</a>.
The spatial density is computed as follows:<br/>
<br/>
&rho;<sub>ijk</sub> = &rho;<sub>sol</sub> + V<sub>ijk</sub><sup>-1</sup> &Sigma;<sub>n</sub><sup>N</sup>
[ <i>X</i><sub>n</sub> - &gamma;<sub>n</sub>V<sub>n</sub>&rho;<sub>sol</sub>  ]
&Pi;<sub>d</sub><sup>3</sup>
B<sub>A</sub> ( <i>r</i><sub>n</sub><sup>d</sup> - <i>P</i><sub>ijk</sub><sup>d</sup> )<br/>
<br/>
Here, V<sub>ijk</sub> is the volume of the grid cell with indices i, j, and k, N is the number of
atoms in the system, <i>X</i><sub>n</sub> is the target property of the atom with index "n", V<sub>n</sub>
is that atom's volume, and <i>r</i><sub>n</sub><sup>d</sup> are the three components of its position vector.
The parameter &gamma;<sub>n</sub> is a pairwise, volume overlap reduction factor that corrects
atomic volume for overlap with covalently bound atoms. It is explained in some detail 
<a href="keywords.html#ASRPATCHFILE">elsewhere</a>.
The parameter &rho;<sub>sol</sub> sets a <a href="keywords.html#EMBGDENSITY">physical background density</a>
for the property in question, and this is relevant when not all matter contributing to the property density
in the system is represented explicitly. In such a case, an assumed vacuum would lead to severe errors.
Note that atomic volumes and volume reduction factors are no longer relevant if &rho;<sub>sol</sub> is zero
in the above equation.
Finally, the product in the above equations utilizes 
<a href="keywords.html#EMBSPLINE">cardinal B-spline functions</a> of order "A", B<sub>A</sub>,
which are assumed centered at the center of each grid cell (vector P<sub>ijk</sub> with components
<i>P</i><sub>ijk</sub><sup>d</sup> for each dimension). This technique of distributing a property on
a lattice is shared with the <a href="keywords.html#EWALD">particle-mesh Ewald method</a>.<br/>
Like the corresponding <a href="keywords.html#SC_EMICRO">density restraint potential</a>, the accumulation
of these data has been parallelized, <i>i.e.</i>, when CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
all threads work on this task synchronously. If the potential is turned on, there is no additional significant cost; 
otherwise the grid has to be incremented with the current configuration. Parallel efficiency can suffer
in this mode of operation if subsequent snapshots have very different configuration (due to poor load balance).
Parallel efficiency is generally poor if the lattices are large (in number of grid cells) relative
to the number of atoms.<br/>
<h4><a class="NoHi" id="EMDELTAS"><b>EMDELTAS</b></a></h4>
If the <a href="keywords.html#SC_EMICRO">density restraint potential</a> is not in use, but
<a href="keywords.html#EMCALC">spatial density analysis</a> is requested, this keyword is mandatory
and sets the lattice cell size of the analysis grid by providing three floating point numbers
corresponding to the lattice cell sizes in &#8491; for the x, y, and z dimensions, respectively.<br/>
Conversely, if the <a href="keywords.html#SC_EMICRO">density restraint potential</a> is in use, this keyword
is optional and allows the user to set a lattice cell size different from the one
used by the <a href="keywords.html#EMMAPFILE">input density map</a>. The keyword
again requires the specification of three floating point numbers that set the
lattice cell sizes in &#8491; for the x, y, and z dimensions of the analysis and evaluation grid, respectively.
Note that acceptable choices require that it be possible to superpose the cells of the input density
map exactly with the analysis grid after reducing its resolution to that of the input map. Minor adjustments
may be made automatically to system size and/or the origin of the input map. If, for example, in the x-dimension
the input map has 10 cells of width 2&#8491;, and the evaluation grid has 26 cells of width 1&#8491;, then
the <a href="keywords.html#ORIGIN">system origin</a> has to be chosen such that the left boundary of the first cell of the input 
density aligns with the left boundary of the first, third, or fifth cell of the evaluation grid (but not any others).
In the same example, CAMPARI would reject a system size of 25&#8491;, because the resultant number
of cells in the x-dimension would not be divisible by the integer factor corresponding to the differences
in resolution (here 2). It would also reject an origin aligning the first input cell to the seventh 
evaluation grid cell, because this would mean that the input map extends beyond the system boundaries.
Finally, implied boundary conditions of the input map are not made
to correspond to <a href="keywords.html#BOUNDARY">system boundary conditions</a> automatically. For any periodic
boundaries of the system, the evaluation grid is and must be fit exactly to the system dimensions.<br/>
<h4><a class="NoHi" id="EMPROPERTY"><b>EMPROPERTY</b></a></h4>
If <a href="keywords.html#EMCALC">spatial density analysis</a> is requested, or if the
<a href="keywords.html#SC_EMICRO">density restraint potential</a>
is in use, this keyword lets the user pick an atomic property to be distributed on a lattice.
If this is supposed to work as a density restraint, there are only two options available at the moment:
<ol>
<li>Use atomic mass (resultant units are g/cm<sup>3</sup>)</li>
<li>Use atomic number, <i>i.e.</i>, proton mass (resultant units are also g/cm<sup>3</sup> for convenience)</li>
</ol>
Note that the density calculation is controlled by <a href="keywords.html#EMDELTAS">formal grid resolution</a>
and by the <a href="keywords.html#EMBSPLINE">function used to represent</a> the point property in question.
If there is an assumed <a href="keywords.html#EMBGDENSITY">physical background level</a>, the
effective atomic volumes become relevant as well.
If the <a href="keywords.html#SC_EMICRO">density restraint potential</a> is not in use, there currently is 
one further option as follows:<br/>
<ol start="3">
<li>Use atomic charge (resultant units are e/&#8491;<sup>3</sup>)</li>
</ol>
<br/>
Note that additional options may be made available in the future.<br/>
<h4><a class="NoHi" id="EMBGDENSITY"><b>EMBGDENSITY</b></a></h4>
If <a href="keywords.html#EMCALC">spatial density analysis</a> is requested, or if the
<a href="keywords.html#SC_EMICRO">density restraint potential</a>
is in use, this keyword sets an assumed background level for the atomic property in question. In general, the
value should be zero if all relevant matter in the system is represented explicitly, <i>i.e.</i>, if empty space
is indeed meant to correspond to a vacuum. If not, the value should be given in appropriate units 
depending on the <a href="keywords.html#EMPROPERTY">property</a> the density is derived from.
These are g/cm<sup>3</sup> for mass and proton densities (atomic number), and e/&#8491;<sup>3</sup> for
charge.<br/>
<h4><a class="NoHi" id="EMBUFFER"><b>EMBUFFER</b></a></h4>
If <a href="keywords.html#EMCALC">spatial density analysis</a> is requested, or if the
<a href="keywords.html#SC_EMICRO">density restraint potential</a>
is in use, this keyword sets a ratio for how much to extend the evaluation grid for spatial densities beyond
any <a href="keywords.html#BOUNDARY">nonperiodic boundaries of the system</a>. In the direction of a nonperiodic boundary, CAMPARI takes
the maximum dimension (<i>e.g.</i>, the diameter of a <a href="keywords.html#SHAPE">sphere</a>) and multiplies
it with this factor to obtain the (approximate) size of the rectangular cuboid grid. Alignment with a 
potential <a href="keywords.html#EMMAPFILE">input grid</a> is achieved by shifting the origin of the evaluation
grid slightly. Note that the behavior will generally be undefined for cases where solute material
samples positions off the evaluation grid. It is up to the user to ensure that the buffer spacing is big
enough for the <a href="keywords.html#SOFTWALL">stiffness of the boundaries</a> to prevent this from happening.
<br/>
<h4><a class="NoHi" id="EMBSPLINE"><b>EMBSPLINE</b></a></h4>
If <a href="keywords.html#EMCALC">spatial density analysis</a> is requested, or if the
<a href="keywords.html#SC_EMICRO">density restraint potential</a>
is in use, this keyword sets the order of B-splines used to distribute the 
<a href="keywords.html#EMPROPERTY">atomic property</a> of interest on the lattice.
This setting corresponds to parameter "A" in the equation <a href="keywords.html#EMCALC">above</a>.
B-splines of order 3 or higher lead to functions with smooth derivatives, and are appropriate
for gradient-based methods. B-splines have finite support, and the cost per atom will increase 
with A<sup>3</sup> for a three-dimensional lattice. The limiting case of A being unity
corresponds to a simple binning function, whereas for large A, a Gaussian function is recovered.
The effective width does not grow linearly with A, but it is rather the tails of the functions
that grow. This implies that very large values for A are probably not a useful investment of CPU time.
Note that the effective width of the B-spline can be thought of as setting an inherent 
resolution or averaging scale for a given atom in question, since it replaces a point function
with a distribution. The choice for this keyword should therefore be made in
concert with the choice of <a href="keywords.html#EMDELTAS">formal grid resolution</a>.<br/>
<h4><a class="NoHi" id="DIFFRCALC"><b>DIFFRCALC</b></a></h4>
This keyword specifies how often to compute approximate fiber
diffraction patterns for the whole system (excluding ghost particles in
GC simulations → <a href="keywords.html#ENSEMBLE">ENSEMBLE</a>). The
system is aligned according to an assumed fiber axis in the system (see
<a href="keywords.html#DIFFRAXIS">DIFFRAXIS</a>), and
amorphous diffraction patterns using cylindrical coordinates (through
Fourier-Bessel transform) are computed. The code currently assumes
atomic scattering
cross sections which are proportional to atomic mass with the
additional
modification that all hydrogen atoms are excluded from the diffraction
calculation.
Specifically, the atomic scattering function for heavy atom <i>i</i>
is proportional to m<sub><i>i</i></sub>/m<sub><b>C</b></sub>
with a proportionality constant yielding units of the square root of
scattering intensity. It is zero for
hydrogen atoms. See <a href="outputfiles.html#DIFFRACTION.dat">DIFFRACTION.dat</a>
for more details.
As a cautionary comment it should be noted that these calculations are
somewhat untested and that output should
be carefully examined. When CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
the diffraction pattern is calculated by a single thread while other threads perform other tasks concurrently (if there are any).
This is a limitation because of the high inherent cost of this analysis.<br/>
<h4><a class="NoHi" id="DIFFRRMAX"><b>DIFFRRMAX</b></a></h4>
For diffraction calculations (→ <a href="keywords.html#DIFFRCALC">DIFFRCALC</a>),
this specifies the maximum number of bins in the reciprocal radial dimension
(<i>r</i> in cylindrical coordinates). The resultant bins will be centered around
zero.<br/>
<h4><a class="NoHi" id="DIFFRZMAX"><b>DIFFRZMAX</b></a></h4>
For diffraction calculations (→ <a href="keywords.html#DIFFRCALC">DIFFRCALC</a>),
this
specifies the maximum number of bins in the reciprocal axial dimension
(<i>z</i> in cylindrical coordinates). The resultant bins will be centered around
zero.<br/>
<h4><a class="NoHi" id="DIFFRRRES"><b>DIFFRRRES</b></a></h4>
For diffraction calculations (→ <a href="keywords.html#DIFFRCALC">DIFFRCALC</a>),
this gives the resolution in the reciprocal radial dimension (<i>r</i> in
cylindrical coordinates) in Å<sup>-1</sup>.<br/>
<h4><a class="NoHi" id="DIFFRZRES"><b>DIFFRZRES</b></a></h4>
For diffraction calculations (→ <a href="keywords.html#DIFFRCALC">DIFFRCALC</a>),
this gives the resolution in the reciprocal axial dimension (<i>z</i> in
cylindrical coordinates) in Å<sup>-1</sup>.<br/>
<h4><a class="NoHi" id="DIFFRJMAX"><b>DIFFRJMAX</b></a></h4>
This defines the maximum order of Bessel functions to use in the
Fourier-Bessel (Hankel) transform to generate the (fiber) diffraction pattern (→ <a href="keywords.html#DIFFRCALC">DIFFRCALC</a>). Note that the
transform takes the product of actual and
reciprocal radial coordinate as its argument. Hence, the maximum order
will determine how meaningful the generated information for
large values of inverse radial dimensions is. This soft cutoff will
scale reciprocally with the size of the system
in the radial dimension. These features arise due to the fact that
Bessel functions of order <i>n</i> only contribute
non-zero values beyond a (unitless) argument value of ca. n. Also note
that the input file for the Bessel functions (see <a href="inputfiles.html#FMCSC_BESSELFILE">FMCSC_BESSELFILE</a>)
needs to provide the tabulated functions up to the necessary order.<br/>
<h4><a class="NoHi" id="DIFFRAXIS"><b>DIFFRAXIS</b></a></h4>
For diffraction calculations (→ <a href="keywords.html#DIFFRCALC">DIFFRCALC</a>),
it is possible (and usually meaningful and necessary) to use a fixed system axis as
the assumed fiber axis. This is (naturally) particularly appropriate for
single-point calculations on specific structures. The axis' x, y, and z
components have to be provided as three floating point numbers. The
length of the vector is not important. The
axis will pass through the point defined (see <a href="keywords.html#DIFFRAXON">DIFFRAXON</a>). If this keyword is not
specified, the program will identify the
longest possible atom-atom distance in the system, and use the
resultant axis. Note that this axis will not be
constant with respect to the absolute (lab) coordinates, but that it
is supposed to cover cases where changes in configuration are allowed
(especially if rigid-body movement is permitted).<br/>
<h4><a class="NoHi" id="DIFFRAXON"><b>DIFFRAXON</b></a></h4>
This keyword specifies the point the (constant) axis (see <a
 href="keywords.html#DIFFRAXIS">DIFFRAXIS</a>)
for diffraction analysis (→ <a href="keywords.html#DIFFRCALC">DIFFRCALC</a>)
will pass through. This will define the zero-point in the
z-coordinate, and hence the origin of the
cylindrical coordinate system. If this keyword is not provided,
CAMPARI will assume the {0.0 0.0 0.0}-point for this
(independent of specifications for the system origin).<br/>
<h4><a class="NoHi" id="REOLCALC"><b>REOLCALC</b></a></h4>
This keyword is only relevant in <a href="keywords.html#REMC">MPI replica exchange calculations</a> (or parallel 
trajectory analysis runs using the same setup). It
instructs CAMPARI to compute various overlap measures between the different Hamiltonians employed in
the REMC/D run
(see <a href="outputfiles.html#N_XXX_OVERLAP.dat">N_XXX_OVERLAP.dat</a>).
Note that this relies on the evaluation of the system energy at
different conditions, <i>i.e.</i>, Hamiltonians. Unless the only exchange dimension is temperature, 
CAMPARI makes the assumption that the energy has to be fully reevaluated for each
condition, which means that there is a significant cost associated with the overlap
calculation. Cutoffs and long-range corrections (see keywords <a href="keywords.html#CUTOFFMODE">CUTOFFMODE</a>, 
<a href="keywords.html#LREL_MC">LREL_MC</a>, and <a href="keywords.html#LREL_MD">LREL_MD</a>)
are always respected by these additional evaluations of cross- (or foreign) energies. 
In <a href="keywords.html#DYNAMICS">dynamics runs</a>, an additional complication arises 
if neighbor list updates are performed infrequently (see <a href="keywords.html#NBL_UP">NBL_UP</a>).
Here, CAMPARI enforces an extra update of neighbor lists that is <i>always</i> out-of-sync with
the schedule of the simulation propagation (this is for technical reasons). The unfortunate
consequence is that for identical <a href="keywords.html#RANDOMSEED">random seed</a>, 
trajectories are not going to be identical if <a href="keywords.html#NBL_UP">NBL_UP</a> is greater than
1 and overlap calculations are performed with different frequencies.<br/>
The user controls whether to calculate foreign energies across all replicas (see
<a href="keywords.html#REOLALL">REOLALL</a>).
If only neighboring conditions are requested, output in <a
 href="outputfiles.html#N_XXX_OVERLAP.dat">N_XXX_OVERLAP.dat</a> may be
truncated or uninformative. It is important to mention that
the MC branch of the energy functions is used only in plain REMC calculations, and that in all other cases
(including hybrid methods → <a href="keywords.html#DYNAMICS">DYNAMICS</a>) the
dynamics branch is used. This is important since cutoff and long-range
treatments can easily be inconsistent between the two (see <a href="keywords.html#LREL_MC">LREL_MC</a> and
<a href="keywords.html#LREL_MD">LREL_MD</a>). Because the main cost of the overlap 
calculation is the evaluation of "foreign" energies, 
CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> can employ
its full parallelization scope for this task.<br/>
<h4><a class="NoHi" id="REOLINST"><b>REOLINST</b></a></h4>
This keyword is only relevant in <a href="keywords.html#REMC">MPI-Replica Exchange calculations</a> (or parallel 
trajectory analysis runs using the same setup). This
keyword requests
instantaneous "foreign" energies to be written (see <a
 href="outputfiles.html#N_XXX_EVEC.dat">N_XXX_EVEC.dat</a>).
"Foreign" or "cross"-energies are simply the energies of the current
structure evaluated at Hamiltonians
different from the one generating the ensemble. Note that the
user controls whether to calculate foreign energies across all replicas
(see <a href="keywords.html#REOLALL">REOLALL</a>). If only neighboring
conditions are requested, a truncated vector
(length 2 or 3) is provided in <a  href="outputfiles.html#N_XXX_EVEC.dat">N_XXX_EVEC.dat</a>.
To facilitate frequent overlap analysis with sparser instantaneous
output, this keyword is interpreted as a subordinated frequency
for <a href="keywords.html#REOLCALC">REOLCALC</a> (as <a
 href="keywords.html#SCATTERCALC">SCATTERCALC</a> is relative to <a href="keywords.html#RHCALC">RHCALC</a>).<br/>
<h4><a class="NoHi" id="REOLALL"><b>REOLALL</b></a></h4>
This keyword is only relevant in <a href="keywords.html#REMC">MPI-Replica Exchange calculations</a>
(or parallel trajectory analysis runs using the same setup). It is interpreted as a
simple logical which determines whether "foreign" energies are computed
over all other
or just the neighboring replicas (see <a
 href="outputfiles.html#N_XXX_EVEC.dat">N_XXX_EVEC.dat</a> and <a
 href="outputfiles.html#N_XXX_OVERLAP.dat">N_XXX_OVERLAP.dat</a>).<br/>
<h4><a class="NoHi" id="TRACEFILE"><b>TRACEFILE</b></a></h4>
This optional keyword is relevant for the post-processing of two types of parallel simulation runs.
First, if a parallel <a href="keywords.html#PDBANALYZE">trajectory analysis</a> run in the RE setup is performed
(&rarr; <a href="keywords.html#REMC">details elsewhere</a>), it allows the user to supply a file
with a running map of replicas to starting conditions. Details of format
and interpretation are given <a href="inputfiles.html#FMCSC_TRACEFILE">elsewhere</a>.
The default map assumed by CAMPARI is the identity mapping 1..<a href="keywords.html#REPLICAS">REPLICAS</a>. 
If a trace file is provided, sets of step number and an updated map for that specific step are read.
This is primarily meant to make replica exchange trajectories that are continuous in condition (<i>i.e.</i>,
have conformational jumps in them) continuous in conformation (<i>i.e.</i>, afterwards they have jumps in
condition in them). In such a case, the trace file is the history of replica exchange moves such as 
<a href="outputfiles.html#N_000_REXTRACE.dat">output by CAMPARI itself</a>. CAMPARI will then recombine 
information from the input trajectories according to the trace. This means that all analyses performed
are on the unscrambled trajectory that can of course also be written (&rarr; <a href="keywords.html#XYZOUT">XYZOUT</a>).
Naturally, this keyword can also be used to specify any other map for other applications, <i>e.g.</i>,
to create trajectories for obtaining bootstrap-type error estimates. The relation of step numbers in the
trace file to frames in the trajectories is handled by keywords <a href="keywords.html#RE_TRAJOUT">RE_TRAJOUT</a>
and <a href="keywords.html#RE_TRAJSKIP">RE_TRAJSKIP</a>.<br/>
Second, if a serial <a href="keywords.html#PDBANALYZE">trajectory analysis</a> run or a parallel trajectory analysis
run using the <a href="keywords.html#MPIAVG">MPI averaging framework</a> is performed, it can be
used to post-process data from an <a href="keywords.html#MPI_PIGS">parallel PIGS</a> run. PIGS runs
provide their own <a href="outputfiles.html#N_000_PIGSTRACE.dat">trace file</a>. For the serial analysis, the 
trajectories from individual replicas must be concatenated in numerical order, otherwise they should be left as is.
Unless the trace file itself is edited (its first column has the step number), keywords <a href="keywords.html#RE_TRAJTOTAL">RE_TRAJTOTAL</a>,
<a href="keywords.html#RE_TRAJOUT">RE_TRAJOUT</a>, and <a href="keywords.html#RE_TRAJSKIP">RE_TRAJSKIP</a> define the
output settings for the original simulation run, and the settings must be matched exactly.
For example, with 4 replicas, <a href="keywords.html#XYZOUT">XYZOUT</a> 50,
<a href="keywords.html#NRSTEPS">NRSTEPS</a> 1000, and <a href="keywords.html#EQUIL">EQUIL</a> 500, 
each trajectory will have 10 snapshots. In trajectory analysis mode, the concatenated trajectory (40 snapshots) can then
be supplied with settings of <a href="keywords.html#RE_TRAJTOTAL">RE_TRAJTOTAL</a> 10, <a href="keywords.html#RE_TRAJOUT">RE_TRAJOUT</a> 50, 
<a href="keywords.html#RE_TRAJSKIP">RE_TRAJSKIP</a> 500, and <a href="keywords.html#NRSTEPS">NRSTEPS</a> 40. Alternatively,
the set of individual trajectories can be supplied to a parallel analysis run using <a href="keywords.html#NRSTEPS">NRSTEPS</a> as 10 instead.
The trace file is processed exclusively in the context of network-based analyses (see <a href="keywords.html#CCOLLECT">CCOLLECT</a>,
<a href="keywords.html#CMODE">CMODE</a>, <a href="outputfiles.html#STRUCT_CLUSTERING.graphml">output file STRUCT_CLUSTERING.graphml</a>,
and so on). Reading in the PIGS trace accomplishes the automatic removal and addition of (conformational) network links 
incurred by the PIGS protocol. Overlapping functionality is provided by keywords 
<a href="keywords.html#TRAJBREAKSFILE">TRAJBREAKSFILE</a> and <a href="keywords.html#TRAJLINKSFILE">TRAJLINKSFILE</a>, but 
these are only available in serial analysis mode. Note that a PIGS analysis run (see <a href="keywords.html#MPIAVG">elsewhere</a> for details)
does of course not process the PIGS trace as it emulates the behavior of only a single PIGS stretch 
(reseeding interval). The presence of this keyword in the input key file is explicitly not allowed  
(results in a halt of the execution) if operating the <a href="keywords.html#netcdf_analysis">NetCDF analysis mode</a>.<br/><br/>
<h4><a class="NoHi" id="RE_TRAJOUT"><b>RE_TRAJOUT</b></a></h4>
This keyword is relevant for some <a href="keywords.html#PDBANALYZE">trajectory analysis</a> runs. 
In particular, those runs relying on an <a href="keywords.html#TRACEFILE">input file with the reseeding/exchange history of a parallel
simulation run</a> need to translate the information about step numbers in this file to the analyzed data.
This keyword therefore lets the user set the trajectory output frequency CAMPARI
is supposed to assume for the supplied <a href="inputfiles.html#FMCSC_PDBFILE">input trajectories (separate or concatenated)</a> being analyzed.
This is important because the trace is meant to use simulation step numbers
that are not preserved in trajectory analysis mode (no step number or time information from input trajectories are read and used).<br/>
If a <a href="keywords.html#REMC">parallel analysis run in the replica exchange setup</a> run is performed,
a successful unscrambling of the trajectories requires that the exchange trace is exhaustive at the level of the output frequency of this keyword.
This means that it is sufficient to provide the current map of condition to starting structure for
every snapshot in the input trajectories (more information can be supplied without harm, less information
will lead to errors). In the replica exchange case, keyword <a href="keywords.html#RE_TRAJSKIP">RE_TRAJSKIP</a> is also essential.
If an analysis run on a PIGS data set is performed (possibly in <a href="keywords.html#MPIAVG">parallel</a>),
the trace must contain information about all reseedings. Here, both keywords <a href="keywords.html#RE_TRAJSKIP">RE_TRAJSKIP</a>   
and <a href="keywords.html#RE_TRAJTOTAL">RE_TRAJTOTAL</a> are processed as well.<br/>
Unlike in the cases outlined above, which are both related to processing a <a href="keywords.html#TRACEFILE">trace file</a>,
this keyword attains a different function in a <a href="keywords.html#MPIAVG">parallel PIGS analysis run</a>. Since such a run
is supposed to emulate the PIGS heuristic, it serves as an output control setting to compute the step number as
<a href="keywords.html#RE_TRAJTOTAL">RE_TRAJTOTAL</a> times RE_TRAJOUT, which is then printed to the output trace file.<br/>
<h4><a class="NoHi" id="RE_TRAJSKIP"><b>RE_TRAJSKIP</b></a></h4>
This keyword is relevant for some <a href="keywords.html#PDBANALYZE">trajectory analysis</a> runs. 
In particular, those runs relying on an <a href="keywords.html#TRACEFILE">input file with the reseeding/exchange history of a parallel
simulation run</a> need to translate the information about step numbers in this file to the analyzed data.
This keyword therefore lets the user set the equilibration period for trajectory output that CAMPARI
is supposed to assume for the supplied <a href="inputfiles.html#FMCSC_PDBFILE">input trajectories (separate or concatenated)</a> being analyzed.
This is important because the trace is meant to use simulation step numbers
that are not preserved in trajectory analysis mode (no step number or time information from input trajectories are read and used).<br/>
Both <a href="keywords.html#RE_TRAJOUT">RE_TRAJOUT</a> and this keyword
are required for CAMPARI to correctly relate the frames in the trajectories to the step numbers
in the trace file. Of course, it is also possible to edit the file with the trace to match the saved trajectory data
exactly, and to then set <a href="keywords.html#RE_TRAJOUT">RE_TRAJOUT</a> and RE_TRAJSKIP to 1 and 0, respectively.
In the case of a PIGS run being analyzed, keyword <a href="keywords.html#RE_TRAJTOTAL">RE_TRAJTOTAL</a> is also essential.<br/>
<h4><a class="NoHi" id="RE_TRAJTOTAL"><b>RE_TRAJTOTAL</b></a></h4>
If a serial <a href="keywords.html#PDBANALYZE">trajectory analysis</a> run or a 
<a href="keywords.html#MPIAVG">parallel trajectory analysis run</a> is performed and 
a <a href="keywords.html#TRACEFILE">file with the PIGS reseeding history (trace)</a> has been provided,
this keyword lets the user set the length in numbers of snapshots per replica that CAMPARI is supposed to assume
for the trajectory input (&rarr; <a href="inputfiles.html#FMCSC_PDBFILE">elsewhere</a>).
In the serial case, this is usually <a href="keywords.html#NRSTEPS">NRSTEPS</a>/<a href="keywords.html#REPLICAS">REPLICAS</a> whereas
in the parallel case it is just <a href="keywords.html#NRSTEPS">NRSTEPS</a>. 
This is important because the trace is meant to use simulation step numbers
that are not preserved in trajectory analysis mode (no step number or time information
from the input trajectory is read and used). <a href="keywords.html#RE_TRAJOUT">RE_TRAJOUT</a>, <a href="keywords.html#RE_TRAJSKIP">RE_TRAJSKIP</a>,
 and this keyword are required for CAMPARI to correctly relate the frames in the trajectories to the step numbers
in the trace file. Note that when using an <a href="keywords.html#FRAMESFILE">input file with subsets of frames</a> in random-access mode
this keyword has to be adjusted to the actual number of selected frames per replica, which still has to be constant.<br/>
Unlike in the processing a <a href="keywords.html#TRACEFILE">trace file</a>,
this keyword attains a different function in a <a href="keywords.html#MPIAVG">parallel PIGS analysis run</a>. Since such a run
is supposed to emulate the PIGS heuristic, it serves as an output control setting to compute the step number as
<a href="keywords.html#RE_TRAJOUT">RE_TRAJOUT</a> times RE_TRAJTOTAL, which is then printed to the output trace file.<br/>
<h4><a class="NoHi" id="CCOLLECT"><b>CCOLLECT</b></a></h4>
This keyword controls the frequency with which a selected set of features (see
<a href="keywords.html#CDISTANCE">CDISTANCE</a> and <a href="keywords.html#CFILE">CFILE</a>)
extracted from the trajectory data (typically in a trajectory analysis run &rarr; <a href="keywords.html#PDBANALYZE">PDBANALYZE</a>)
is stored in a large array in memory for post-processing. Such post-processing currently
consists of different algorithms (&rarr; <a href="keywords.html#CMODE">CMODE</a>), for example to identify structural clusters in the data, and is
performed after the last step of the run has completed. If CCOLLECT is set to something
larger than the number of simulation steps (<a href="keywords.html#NRSTEPS">NRSTEPS</a>), the
clustering analysis is disabled (also the default).<br/>
Various output will be produced aside from information written directly to standard out
or the log-file. At the most basic level, the extracted features themselves, after the various preprocessing steps outlines below,
can be written to disk in an optional output file (see <a href="outputfiles.html#CLUSTERING_FEATURES.nc">CLUSTERING_FEATURES.nc</a>
and keyword <a href="keywords.html#CDUMP">CDUMP</a>). 
The most common output file is a list of cluster annotations per analyzed snapshot 
(&rarr; <a href="outputfiles.html#STRUCT_CLUSTERING.clu">STRUCT_CLUSTERING.clu</a>) that is produced along with a helper 
script for the visualization software VMD (&rarr; <a href="outputfiles.html#STRUCT_CLUSTERING.vmd">STRUCT_CLUSTERING.vmd</a>).
Furthermore, CAMPARI will print a file representing the clustering as a graph in
an xml-based (so-called "graphml") format (&rarr; <a href="outputfiles.html#STRUCT_CLUSTERING.graphml">STRUCT_CLUSTERING.graphml</a>).
Taken together these files allow further analyses of the clustering, primarily
those that take advantage of the fact that the clustering yields a complex network/graph
(<i>e.g.</i>, <a href="outputfiles.html#PFOLD_PLUS_yyy_CFEP_xxxxxxxx.dat">cut-based free energy profiles using
committor probabilities</a>).<br/>
All clustering algorithms and also the progress index algorithm (&rarr; <a href="keywords.html#CMODE">CMODE</a>) will
write a number of diagnostic and reporting summaries to log-output. For clustering algorithms, this includes 
a summary of the determined clusters (usually involving at least the number of contained
snapshots and a measure of size) to log-output. The <a href="keywords.html#CPROGINDMODE">exact progress index method</a> is an
exception as it does not explicitly record a clustering (the three aforementioned output files are missing).
With any progress index method in use, at least one additional <a href="outputfiles.html#PROGIDX_xxxxxxxxxxxx.dat">output file</a>
is obtained. This file is the essential requirement to create plots as in
<a href="references.html#ref24_5">the progress index reference</a>.<br/>
Note that structural clustering breaks the typical CAMPARI paradigm of "on-the-fly" analysis since
the bulk of the CPU time for analysis will be invested only at the very end. Therefore,
structural clustering will most often be used in trajectory analysis runs as it will be
highly undesirable to risk an unclean termination of an actual simulation (certain 
algorithms for structural clustering require large amounts of memory and/or CPU time).
Note as well that structural clustering should not be confused with the (much simpler) analysis
of molecular clusters (see <a href="keywords.html#CLUSTERCALC">CLUSTERCALC</a> and its
corresponding <a href="outputfiles.html#CLUSTERS.dat">output files</a>).
Because structural clustering and related analyses can be CPU time-intensive tasks, they are handled 
by CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a>, <i>i.e.</i>,
many algorithms are tackled by all threads at once. Most importantly, the tree-based clustering 
and the approximate progress index method (options 4 and 5 to keyword <a href="keywords.html#CMODE">CMODE</a>)
as well as iterative algorithms operating on derived graphs (see <a href="keywords.html#MAXTIME_ITERS">MAXTIME_ITERS</a> for details)
have been parallelized this way,
Details are provided below, in particular for keyword <a href="keywords.html#CMODE">CMODE</a>.<br/>
A special remark is required for simulation runs using the <a href="keywords.html#MPIAVG">MPI averaging technique</a>.
Similar to any use of the clustering functionality "on-the-fly", trajectory output should be generated in accordance
with the setting for CCOLLECT (most easily by using <a href="keywords.html#MPIAVG_XYZ">MPIAVG_XYZ</a> and
a matching value of <a href="keywords.html#XYZOUT">XYZOUT</a>). This is so the clustering results
can be annotated and understood at all. In an MPI averaging run, CAMPARI will then at each collection
step gather data from all replicas and store them in an array allocated exclusively by the master process.
The data arrangement is such that trajectories will be continuous and ordered by increasing replica number.
The concatenation introduces spurious transitions that may affect subsequent computations.
Data collection causes a synchronization and communication requirement absent in other types of 
MPI averaging calculations. At the end of the simulation, the resultant concatenated trajectory is analyzed exclusively
by the master process, which - depending on settings and <a href="keywords.html#CMODE">algorithms in use</a> - 
may lead to severe imbalances in terms of both memory consumption and CPU time requirements.
This should be kept in mind when using this approach across machines not sharing any memory.
To enforce the complementary behavior of every identical replica analyzing its own trajectory, it is possible
to use a fake <a href="keywords.html#REMC">replica exchange</a> run by using a single dummy (or irrelevant)
parameter for exchange. In a hybrid MPI/OpenMP calculation, the <a href="keywords.html#NRTHREADS">OpenMP</a> layer
on the master process performing the analysis will be limited to the number of threads granted initially even though
other MPI processes residing on the same shared-memory environment will be idle during this time. Note that
the feature extraction itself, which is the only task performed during the run, does not benefit
from threads parallelization except for the calculation of dynamic weights for options 2 or 4 for keyword
<a href="keywords.html#CDISTANCE">CDISTANCE</a>. Conversely, feature extraction in parallel does occur
in an MPI averaging run as outlined above.
 <br/>
Because the chosen set of degrees of freedom often is a superset of an unknown subspace of particular
interest to the user, CAMPARI offers two common routes for a <a href="keywords.html#CREDUCEDIM">dimensionality reduction</a>.
These rely on standard linear algebra techniques and are available if i) the chosen proximity metric is not circular
(this excludes options 1-2 for <a href="keywords.html#CDISTANCE">CDISTANCE</a>);
ii) the code was linked to a linear algebra library (LAPACK-compliant, see <a href="install.html">installation
instructions</a> for general information on linking libraries); and iii) there are more samples than variables (degrees of freedom).
The reason that circular (periodic) data are currently not supported is that the required measures of
variance and in particular covariance become somewhat empirical and laborious to compute. If this type of
transformation is performed (&rarr; <a href="keywords.html#PCAMODE">PCAMODE</a>),
CAMPARI produces up to two output files, one containing the eigenvectors themselves (<a href="outputfiles.html#PRINCIPAL_COMPONENTS.evs">PRINCIPAL_COMPONENTS.evs</a>)
and another optional one containing the data matrix in the transformed space (<a href="outputfiles.html#PRINCIPAL_COMPONENTS.dat">PRINCIPAL_COMPONENTS.dat</a>). The latter
can be used to derive probability or free energy surfaces in reduced-dimensional spaces.<br/>
<h4><a class="NoHi" id="PCAMODE"><b>PCAMODE</b></a></h4>
If data for structural clustering are collected (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), this keyword instructs CAMPARI to calculate and perform
a linear transformation on the collected data. As mentioned <a href="keywords.html#CCOLLECT">above</a>, this option is not available for 
all measures of <a href="keywords.html#CDISTANCE">conformational distance</a>. The linear algebra works straightforwardly for options 3 and 7
for keyword <a href="keywords.html#CDISTANCE">CDISTANCE</a> and always involves centering the data first (subtraction of dimension-wise means).
For options 4, 9, and 10 (local weights), the locally adaptive weights are averaged, and the input data are scaled by dimension-wise average weights.
The same scaling idea is used for option 8 (global weights). Lastly, the possibility of alignment of 3D coordinates (options 5, 6, and 10 &rarr;
<a href="keywords.html#CALIGN">CALIGN</a>) causes additional complications. The general strategy here is to first align all snapshots
to the last one (static alignment), which may or may not be provide a meaningful description.<br/>
Five options are currently available:<br/>
<ol>
<li>No transformation is performed</li>
<li><a href="references.html#ref23_15">Principal component analysis</a> (PCA) is performed via single-value decomposition (SVD), and the 
eigenvectors of the covariance matrix are written to a <a href="outputfiles.html#PRINCIPAL_COMPONENTS.evs">dedicated output file</a>.
PCA works by identifying linear transforms of the centered data that collect maximal sample variance in as few components as possible. The principal
components are normalized and orthogonal,
<i>i.e.</i>, have unit length and zero (linear) covariance. The latter should not be equated with a lack of correlation. Many nonlinear correlations
between variables yield zero covariance. The amount of variance contained in the first few components can differ dramatically between 
data sets. The printed eigenvectors and eigenvalues are the only result of this analysis, <i>i.e.</i>, the transform is not actually used.
</li>
<li>This is the same as the previous option with an important difference. Here, the original sample data are transformed and centered data in PCA space.
The transformed data set is written to <a href="outputfiles.html#PRINCIPAL_COMPONENTS.dat">an additional output file</a>.
If keyword <a href="keywords.html#CREDUCEDIM">CREDUCEDIM</a> is not zero, the original data are overwritten and lost, and any algorithm relying on conformational
distance evaluations thereafter will treat these as the simplest case (<a href="keywords.html#CDISTANCE">CDISTANCE</a> becomes 7).
This is because the weighting or alignment requests were taken care of before. The benefit of using <a href="keywords.html#CREDUCEDIM">CREDUCEDIM</a>
is to be able to obtain a more informative representation in a space of reduced dimensionality in an unsupervised fashion.
</li>
<li><a href="references.html#ref23_17">Time structure-based independent component analysis</a> (tICA) is performed, which is based on
<a href="references.html#ref23_16">original work from the 90s</a>. tICA solves the matrix equation <b>&Tau;F</b>=<b>&Sigma;F&Lambda;</b>,
where <b>&Sigma;</b> is the covariance matrix, <b>&Tau;</b> is a time-lagged and symmetrized covariance matrix (lag time is set by keyword
<a href="keywords.html#CLAGTIME">CLAGTIME</a>), <b>F</b> is the matrix of eigenvectors, and <b>&Lambda;</b> is a diagonal matrix with
eigenvalues, which correspond to the values of the autocorrelation function at the specified lag time for the transformed variables.
Unlike in PCA, the eigenvectors do not form an orthonormal basis (rather, they satisfy <b>F<sup>T</sup>&Sigma;F</b>=<b>I<sub>D</sub></b>).
This means that unlike PCA the transformed data do not preserve values of Euclidean distances between points even if the full dimensionality is used.
As in option 2, the printed eigenvectors and eigenvalues are the only result of this analysis, <i>i.e.</i>, the transform is not actually used.</li>
<li>This is the same to option 4 as option 3 is to option 2, <i>i.e.</i>, the original sample data are transformed to tICA space 
and centered with the aforementioned options, implications, and consequences.</li>
</ol>
The default option is 1. Note that options 3 and 5 can generate extremely large output files. The use of options 3 and 5 in conjunction with
locally adaptive weights entails the additional complication of when and how weights should be normalized. In contrast to what is described
in the reference publications (see <a href="references.html#ref23_18">here</a>), the weights are now normalized per snapshot before the average per dimensions
is computed (which will typically cause only minor differences).
While PCA is performed via SVD of the data matrix,
the covariance matrices are computed explicitly for tICA, which scales unfavorably with dimensionality. As mentioned above, when choosing options 3 or 5,
CAMPARI also offers to perform a simplified clustering in a space of reduced dimensionality (&rarr; <a href="keywords.html#CREDUCEDIM">CREDUCEDIM</a>).
Supplying data dimensions that are linearly dependent on other dimensions or have zero variance may cause the analysis to fail, in particular for
tICA. An unusual exit from the respective LAPACK routine will be indicated by a warning.
If CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use, the linear transform
is (currently) calculated and applied by the master thread alone.<br/>
<h4><a class="NoHi" id="CDISTANCE"><b>CDISTANCE</b></a></h4>
If data for structural clustering are collected (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), this
keyword defines what type of data to collect and how to define structural proximity.
There are currently 10 supported options:<br/>
<ol>
<li>
This option is tailored toward the intrinsic degrees of freedom of a typical CAMPARI simulation
that are also the essential internal degrees of freedom of most molecular systems, <i>i.e.</i> the molecules' dihedral angles.
The values {&phi;<sub>k</sub>} for a set of K dihedral angles are collected throughout the run.
A list can be provided by using a dedicated input file (&rarr; <a href="keywords.html#CFILE">CFILE</a>), otherwise most of 
CAMPARI's internal degrees of freedom are used (excluding those pertaining to the conformation of five-membered
rings). The details of the set of eligible dihedral angles are controllable by keyword 
<a href="keywords.html#TMD_UNKMODE">TMD_UNKMODE</a>. More information can be found in the 
<a href="inputfiles.html#FYCindexinput">description of the input file</a>. The distance between two states is given as:<br/>
d<sub>l&harr;m</sub> = [ (1.0/K) &#183; &Sigma;<sub>k</sub><sup>K</sup> ( (&phi;<sub>k</sub><sup>l</sup> - &phi;<sub>k</sub><sup>m</sup>) mod 2&pi; )<sup>2</sup>]<sup>1/2</sup><br/>
Because dihedral angles are periodic (circular) quantities, a meaningful metric of proximity must account for boundary 
conditions, hence the "mod 2&pi;" term. Dihedral angles-based clustering poses - aside from periodicity - the challenge
that all considered degrees of freedom are bounded and that the strongest contribution to the signal will come from
those torsions with large variance, which unfortunately are often the ones of least interest (for example sidechain
torsions). Therefore, a careful selection of the subset to use is critical for an informative clustering. Like any other method,
dihedral angle-based clustering is vulnerable to Euclidean distances in high-dimensional spaces becoming uninformative.
Note that all dihedral angle-based proximity criteria are useful primarily for single molecules since relative intermolecular
orientations are not representable whatsoever.
</li>
<li>
This is identical to the previous option only that each dihedral angle is also associated with a locally adaptive weight. Adaptive weights
are those that change from snapshot to snapshot. Initially, the weights for this representation are set to the effective masses (the
associated diagonal element in the mass matrix, <i>i.e.</i>, mass-metric tensor) of a given dihedral angle. Evaluating a distance
requires combining these adaptive weights for 2 respective snapshots l and m, <i>e.g.</i> w<sub>k</sub><sup>lm</sup> = f(IM<sub>k</sub><sup>l</sup>,IM<sub>k</sub><sup>m</sup>).
The distance between two states will then be given as:<br/>
d<sub>l&harr;m</sub> = [ (&Sigma;<sub>k</sub><sup>K</sup> w<sub>k</sub><sup>lm</sup> ) <sup>-1</sup> &#183; &Sigma;<sub>k</sub><sup>K</sup> w<sub>k</sub><sup>lm</sup> &#183; ( (&phi;<sub>k</sub><sup>l</sup> - &phi;<sub>k</sub><sup>m</sup>) mod 2&pi; )<sup>2</sup>]<sup>1/2</sup><br/>
The actual values for the weights for individual snapshots, e.g., IM<sub>k</sub><sup>l</sup>, can be altered using keyword
<a href="keywords.html#CMODWEIGHTS">CMODWEIGHTS</a>. The function for combining the weights to yield w<sub>k</sub><sup>lm</sup> is 
selected with the help of keyword <a href="keywords.html#CWCOMBINATION">CWCOMBINATION</a>. Adaptive weights are generally normalized per 
snapshot (such that &Sigma;<sub>k</sub><sup>K</sup> IM<sub>k</sub><sup>l</sup> evaluates to 1.0 for all l). This is different from what is described
in 2 reference publications (see <a href="references.html#ref23_4">here</a> and <a href="references.html#ref23_18">here</a>).
Any type of weighting scheme (static or adaptive) can be used to remedy the problem with the previous one regarding the impact of "uninteresting" degrees of 
freedom. The weighting with the effective masses ensures that slow degrees of freedom (<i>e.g.</i> central backbone torsions)
will contribute much more to the overall signal than sidechain torsions. This effect becomes exacerbated for long chains.
There are two additional caveats. First, the initial mass matrix-based weights are affected by the choice for <a href="keywords.html#ALIGN">ALIGN</a>.
Second, Dihedral angles describing disulfide bonds are supported but the presence of disulfide bonds destroys
the notion of the effective masses (see <a href="keywords.html#CRLK_MODE">CRLK_MODE</a>
for some background). The default weights for the C<sub>&alpha;</sub>-C<sub>&beta;</sub>-S-S and C<sub>&beta;</sub>-S-S-C<sub>&beta;</sub>
torsions are simply set to 1.0. This means that a meaningful use of this option while selecting disulfide bonds as part of 
the representation requires setting <a href="keywords.html#CMODWEIGHTS">CMODWEIGHTS</a> to something other than 0.
</li>
<li>
This option is largely identical to option 1. It carries all the same caveats with the exception of the periodicity
of dihedral angles. Here, we expand each dihedral angle into its sine and cosine terms to construct a distance metric as follows:<br/>
d<sub>l&harr;m</sub> = [ (0.5/K) &#183; &Sigma;<sub>k</sub><sup>K</sup> (sin(&phi;<sub>k</sub><sup>l</sup>) - sin(&phi;<sub>k</sub><sup>m</sup>))<sup>2</sup> + (cos(&phi;<sub>k</sub><sup>l</sup>) - cos(&phi;<sub>k</sub><sup>m</sup>))<sup>2</sup>]<sup>1/2</sup><br/>
Note that the sine and cosine terms of the same angle are nonlinearly but strictly correlated. This has consequences for the interpretation
of dimensionality in this representation.  
</li>
<li>
This is the analogous modification of the previous option by introducing locally adaptive weights that are initially composed from the effective masses
and can be altered by keyword <a href="keywords.html#CMODWEIGHTS">CMODWEIGHTS</a>:<br/>
d<sub>l&harr;m</sub> = [ 0.5 (&Sigma;<sub>k</sub><sup>K</sup> w<sub>k</sub><sup>lm</sup>) <sup>-1</sup> &#183; &Sigma;<sub>k</sub><sup>K</sup>  w<sub>k</sub><sup>lm</sup> &#183; ( (sin(&phi;<sub>k</sub><sup>l</sup>) - sin(&phi;<sub>k</sub><sup>m</sup>) )<sup>2</sup> + (cos(&phi;<sub>k</sub><sup>l</sup>) - cos(&phi;<sub>k</sub><sup>m</sup>) )<sup>2</sup> ) ]<sup>1/2</sup><br/>
Note that this implies the presence of only a single weight per pair of Fourier terms.
</li>
<li>
This option is probably the most commonly used variant, the positional RMSD. The 
Cartesian position vectors {<b>r</b><sub>k</sub>} for a set of K atoms 
are collected throughout the run. A list can be provided by using a dedicated input file
(&rarr;  <a href="keywords.html#CFILE">CFILE</a>), otherwise all atoms in the system are used.
The distance between two states is then given as:<br/>
d<sub>l&harr;m</sub> = [ (1.0/K) &#183; &Sigma;<sub>k</sub><sup>K</sup> ( <b>r</b><sub>k</sub><sup>l</sup> - <b>RoTr</b>(<b>r</b><sub>k</sub><sup>m</sup>) )<sup>2</sup>]<sup>1/2</sup><br/>
Here, <b>RoTr</b> is meant to indicate rotation and translation operators that superpose the {<b>r</b><sub>k</sub>}<sup>m</sup>
optimally with the frame provided by the {<b>r</b><sub>k</sub>}<sup>l</sup>. This alignment uses the same
quaternion-based algorithm mentioned <a href="keywords.html#ALIGNCALC">elsewhere</a>. Superposition (alignment) implies 
that the atomic RMSD is not necessarily a <i>bona fide</i> metric of distance as it is not guaranteed to satisfy d<sub>l&harr;m</sub> &le;
d<sub>l&harr;p</sub> + d<sub>p&harr;m</sub>, <i>i.e.</i>, the triangle inequality. This is because the operator
<b>RoTr</b> is different for computing d<sub>p&harr;m</sub> than it is for computing the other two distances. In reality,
for similar structures, this is never really a problem in the context of clustering. RMSD-based clustering
is - like any other method - vulnerable to Euclidean distances in high-dimensional spaces becoming uninformative and 
- in particular - to obscuring of the signal by uneven variances (a reason why very commonly terminal parts of
polymer are excluded from such analyses). The alignment step for both this and the next option can be disabled with the
help of keyword <a href="keywords.html#CALIGN">CALIGN</a> (<b>RoTR</b> is then simply the identity operator).
Without alignment external degrees of freedom become part of the distance criterion. The coordinate-based RMSD is generally
difficult to use for sets of atoms spanning multiple molecules since intermolecular motion can easily provide most of the variance
in the signal. In <a href="keywords.html#BOUNDARY">periodic boundary conditions</a>, there is a particular difficulty of
which image of a molecule to use. Keyword <a href="keywords.html#XYZ_REFMOL">XYZ_REFMOL</a> is supported in this context and can be
use to circumvent this problem (although it should be kept in mind that there is no unique solution for assemblies of more than 2 molecules). 
</li>
<li>
This is similar to the previous option, and is only relevant if <a href="keywords.html#CALIGN">alignment</a> is performed.
Then, this option allows the user to split the atomic index sets used for alignment and distance computation, <i>i.e.</i>, the
alignment operator, <b>RoTr</b>, minimizes pairwise distances computed over an independent set of atoms that can either be a superset,
subset or completely different set of atoms than the one specified via <a href="keywords.html#CFILE">CFILE</a>.
Then, if we term the distance set {D} and the alignment set {A}, with {A} to be provided via 
<a href="keywords.html#ALIGNFILE">ALIGNFILE</a>, the distance between two states will be given as:<br/>
d<sub>l&harr;m</sub> = [ (1.0/|D|) &#183; &Sigma;<sub>d</sub><sup>|D|</sup> ( <b>r</b><sub>d</sub><sup>l</sup> - <b>RoTr<sub>{A}</sub></b>(<b>r</b><sub>d</sub><sup>m</sup>) )<sup>2</sup>]<sup>1/2</sup><br/>
Note that choosing disparate sets can easily destroy the fundamental meaning of alignment, <i>i.e.</i>, the removal
of differences caused purely by external (rigid-body) degrees of freedom. This in turn would almost certainly lead to violations
of the assumption that members of different clusters are dissimilar, and can also eliminate the notion of
similarity amongst members of the same cluster. Conversely, it can be useful in improving the signal-to-noise ratio
for cases where one is interested in states populated by a specific part of a much larger system that moves as a single entity
(specifically, states characterized by relative arrangements of parts of a system may emerge more clearly if 
alignment is performed on the whole entity, but distances are computed only over a small portion of interest).
Note that errors in calculations relying on mean cluster properties computed for example in the tree-based algorithm or
hierarchical clustering (&rarr; <a href="keywords.html#CMODE">CMODE</a>) using <a href="keywords.html#CLINKAGE">mean linkage</a>
can easily become large if the two atom sets have little overlap. Specifically, a cluster of similar snapshots
as determined by the distance set, which is constituted by elements with large differences in the alignment set,
will produce deteriorating accuracy of, for example, computing a snapshot's mean distance to it.
This is because the heterogeneity of the alignment operator is masked by the simplified algebra used to compute these properties
in constant time. The general caveats for RMSD-based clustering mentioned for option 5 above remain relevant as well.
</li>
<li>
Let us define a set of K interatomic distances, {r<sub>ij</sub>} over unique atom pairs i and j. These distances
are collected throughout the run. A list can be provided by using a dedicated input file
(&rarr;  <a href="keywords.html#CFILE">CFILE</a>), otherwise a subset of randomly selected but unique interatomic distances
is used. The number of randomly selected degrees of freedom is usually set to 3<i>N</i> where <i>N</i> is the number
of atoms (it can be smaller for small <i>N</i>). Because the {r<sub>ij</sub>} are geometric distances, they are also positive
and potentially large. CAMPARI allows a <a href="keywords.html#CDISTRANSFORM">functional transform</a> to be applied during data collection
to, which, generally speaking, allows focusing the sensitivity to particular distance regimes. If we consider this transformed
set of distances, {<i>f</i>(r<sub>ij</sub>)} (<i>f</i>(x) can be the identity function of course, which is also the default),
the distance between two states will then be given as:<br/>
d<sub>l&harr;m</sub> = [ (1.0/K) &#183; &Sigma;<sub>k</sub><sup>K</sup> [ <i>f</i>(r<sub>ij(k)</sub><sup>l</sup>) - <i>f</i>(r<sub>ij(k)</sub><sup>m</sup>) ]<sup>2</sup>]<sup>1/2</sup><br/>
<i>I.e.</i>, the chosen distance metric is simply the root mean square deviation across the set of
transformed interatomic distances. Distance-based clustering inherently removes external degrees of freedom from
the proximity measure, and it is therefore suitable to most applications. As with any other measure,
Euclidean distances in high-dimensional spaces may become uninformative and results may be obscured
by uneven variances.
</li>
<li>
This is identical to the previous option only that each distance, which is <a href="keywords.html#CDISTRANSFORM">potentially transformed</a>,
is subjected to a static weight. This weight is computed initially from the combined mass of 
the constituting atoms. The distance between two states would then be given as:<br/>
d<sub>l&harr;m</sub> = [ (&Sigma;<sub>k</sub><sup>K</sup> (m<sub>i(k)</sub>+m<sub>j(k)</sub>) ) <sup>-1</sup> &#183; &Sigma;<sub>k</sub><sup>K</sup> (m<sub>i(k)</sub>+m<sub>j(k)</sub>) &#183; [ <i>f</i>(r<sub>ij(k)</sub><sup>l</sup>) - <i>f</i>(r<sub>ij(k)</sub><sup>m</sup>) ]<sup>2</sup>]<sup>1/2</sup><br/>
Here, m<sub>i</sub> denotes the mass of atom i, and <i>f</i>(x) is the function used for transformation (defaults to the identity function).
These (static) weights are not particularly useful in the default form
but can be altered by changing masses, <i>e.g.</i>, by a <a href="keywords.html#MPATCHFILE">suitable patch</a>, or by means of
the dedicated facility (keyword <a href="keywords.html#CMODWEIGHTS">CMODWEIGHTS</a>). They are normalized such that similar distance thresholds
can be used as in the unweighted case.
</li>
<li>
This is identical to option 7 above only that each interatomic distance, which is <a href="keywords.html#CDISTRANSFORM">potentially transformed</a>,
 is subjected to a locally adaptive weight (as in options 2 and 4 above).
These weights increase the corresponding memory demands by a factor of 2 and are all initialized to be unity. 
It is necessary to use the dedicated facility (keyword <a href="keywords.html#CMODWEIGHTS">CMODWEIGHTS</a>) to make
them meaningful. All localized weights available for interatomic distances require at least a <a href="keywords.html#CWINDOWSIZE">window size parameter</a>
and a rule for how to combine weights from different snapshots. The latter is expressed as function g(x1,x2) specified by keyword <a href="keywords.html#CWCOMBINATION">CWCOMBINATION</a>.
The resultant functional form for pairwise distance between snapshots is:<br/>
d<sub>l&harr;m</sub> = [ (&Sigma;<sub>k</sub><sup>K</sup> g(&Omega;<sub>k</sub><sup>l</sup>,&Omega;<sub>k</sub><sup>m</sup>) ) <sup>-1</sup> &#183; &Sigma;<sub>k</sub><sup>K</sup> g(&Omega;<sub>k</sub><sup>l</sup>,&Omega;<sub>k</sub><sup>m</sup>) &#183; ( [<i>f</i>(r<sub>ij(k)</sub><sup>l</sup>) - <i>f</i>(r<sub>ij(k)</sub><sup>m</sup>) ]<sup>2</sup> ) ]<sup>1/2</sup><br/>
Here, &Omega;<sub>k</sub><sup>l</sup> is the locally adaptive weight for the k<sup>th</sup> feature and the l<sup>th</sup> snapshot, and
<i>f</i>(x) is the function used for transformation (defaults to the identity function).
The same general caveats apply as for options 2 and 4 above. In particular, it is important to reemphasize that all locally adaptive weights
are now normalized per snapshot in contrast to the descriptions found in the literature
(see <a href="references.html#ref23_4">here</a> and <a href="references.html#ref23_18">here</a>).
</li>
<li>
This is similar to options 5 and 9 above. Here, each of the 3K Cartesian coordinates, <b>X</b>, of a system of K selected atoms is subjected to a separate, locally adaptive weight.
Due to the presence of these weights, <a href="keywords.html#CALIGN">pairwise alignment</a> is currently not 
supported for this option. CAMPARI computes the Euclidean distance between snapshots, which means that any type of input data
can be analyzed straightforwardly by transcribing the data set into a fake trajectory of atoms with each Cartesian coordinate
corresponding to an input data dimension.  
The locally adaptive weights increase the corresponding memory demands by a factor of 2 and are all initialized to be unity. 
It is necessary to use the dedicated facility (keyword <a href="keywords.html#CMODWEIGHTS">CMODWEIGHTS</a>) to make
them meaningful. As for option 9, weights require at least a <a href="keywords.html#CWINDOWSIZE">window size parameter</a>
and a rule for how to combine them for different snapshots. The latter is expressed as function g(x1,x2) specified by keyword <a href="keywords.html#CWCOMBINATION">CWCOMBINATION</a>.
The resultant functional form for pairwise distance between snapshots is:<br/>
d<sub>l&harr;m</sub> = [ 3(&Sigma;<sub>k</sub><sup>3K</sup> g(&Omega;<sub>k</sub><sup>l</sup>,&Omega;<sub>k</sub><sup>m</sup>) ) <sup>-1</sup> &#183; &Sigma;<sub>k</sub><sup>3K</sup> g(&Omega;<sub>k</sub><sup>l</sup>,&Omega;<sub>k</sub><sup>m</sup>) &#183; ( (X<sub>(k)</sub><sup>l</sup> - X<sub>(k)</sub><sup>m</sup> )<sup>2</sup> ) ]<sup>1/2</sup><br/>
For the weighting aspect, the same caveats apply as for options 2, 4, and 9 above. Due to the distance definition relying on absolute coordinates,
the caveats mentioned for option 5, which relate to atoms sets encompassing multiple molecules, remain relevant as well.
</li>
</ol>
The CAMPARI units for options 1-2 above are &deg;, while the units for options 5-10 are all &#8491; (more generally,
in <a href="keywords.html#PDBANALYZE">trajectory analysis mode</a>, the units for options 5-10 will be those of the input data).
This is relevant in understanding values of cluster sizes and similar parameters reported to standard log-output.
Options 3-4 have no formal unit.<br/>
<h4><a class="NoHi" id="CFILE"><b>CFILE</b></a></h4>
If data for structural clustering or related analyses are to be collected (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), this keyword
provides the path and location to an input file selecting a subset of the possible coordinates.
For options 1-4 of the <a href="keywords.html#CDISTANCE">proximity measure</a>, this file is a single
column list of indices specifying specific system torsions (see <a href="inputfiles.html#FYCindexinput">elsewhere</a>). For options 5, 6, and 10 it is a single column list
of atomic indices (see <a href="inputfiles.html#Atomindexinput">elsewhere</a>). Lastly, for options 7-9, it is
a list of pairs of atomic indices (two columns, see <a href="inputfiles.html#Atompairindexinput">elsewhere</a>). The keyword can take 
on an additional meaning if instantaneous output of RMSD values is requested through <a href="keywords.html#ALIGNCALC">ALIGNCALC</a>. In
this context, CFILE specifies an atomic index set as for option 6 of <a href="keywords.html#CDISTANCE">CDISTANCE</a>.<br/>
<h4><a class="NoHi" id="CALIGN"><b>CALIGN</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), and an atomic
RMSD variant is chosen as the proximity measure (&rarr; <a href="keywords.html#CDISTANCE">CDISTANCE</a>),
this keyword can be used to specifically disable the alignment step that occurs before the actual
RMSD of the two coordinate sets is computed. To achieve this, provide any value other than 1 (the default) for
this on/off-type keyword. Note that alignment must be disabled for option 10 to be available for <a href="keywords.html#CDISTANCE">CDISTANCE</a>.<br/>

<h4><a class="NoHi" id="CDISTRANSFORM"><b>CDISTRANSFORM</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), and the raw features are interatomic distances
(<a href="keywords.html#CDISTANCE">CDISTANCE</a> is 7, 8, or 9), this keyword can be used to specify a function that stores a
transformation of the interatomic distance as the feature (this is the function <i>f</i>(x) in the <a href="keywords.html#CDISTANCE">description above</a>).
Options are as follows:<br/>
<ol start="0">
<li><i>f</i>(x) = x: This is the identity function and the default.</li>
<li><i>f</i>(x) = 1.0 - [1.0 + exp(-(x-&chi;)/&tau;)]<sup>-1</sup>: This is a sigmoidal function decaying from a maximum value of 1.0 to 0.0
with increasing distance. The step is centered at <a href="keywords.html#CDISTRANS_P1">&chi;</a>
and the sharpness is given by <a href="keywords.html#CDISTRANS_P2">&tau;</a>. Vanishing values for &tau; give a transform that is equivalent
to a <a href="keywords.html#CONTACTCALC">contact map</a> transform. For larger values of &tau;, the values of <i>f</i>(x) when x is small
will increasingly deviate from 1.0 (be smaller).</li>
<li><i>f</i>(x) = [x + r<sub>buf</sub>]<sup>-1.0/h<sub>exp</sub></sup>: This is a hyperbolic function. At an interatomic distance of
1.0-<a href="keywords.html#CDISTRANS_P1">r<sub>buf</sub></a>,
the value is always 1.0. Smaller values will diverge, which should be avoided by choosing at least 1.0 for this parameter. At larger distances
the values are very small and approach 0.0 asymptotically. The rate of approach is controlled by <a href="keywords.html#CDISTRANS_P2">h<sub>exp</sub></a>,
and smaller values give a faster approach. Note that the so-called DRID metric (<a href="references.html#ref23_23">reference</a>)
fundamentally relies on hyperbolic transforms where r<sub>buf</sub> is 0.0 and h<sub>exp</sub> is 1, 1/2, or 1/3.</li>
<li><i>f</i>(x) = 1.0 if x &gt; r<sub>cut</sub> and <i>f</i>(x) = sin(x&#183;0.5&pi;/r<sub>cut</sub>) otherwise: This is a piecewise function that for
small distances resembles the identify function (with an effective scale) before tapering off to a constant value. The point where the function
becomes 1.0 exactly is <a href="keywords.html#CDISTRANS_P1">r<sub>cut</sub></a>.</li>
</ol>
Note that all options except the identity transform have a plateau region for large interatomic distances. This means that the differences
between snapshots will be dominated by those interatomic distances where in at least one of the two snapshots the distance is small.
The either 1 or 2 parameters required are set by keywords <a href="keywords.html#CDISTRANS_P1">CDISTRANS_P1</a> and
<a href="keywords.html#CDISTRANS_P2">CDISTRANS_P2</a>. Note that all of these transforms severely alter the scale 
of the features, which means that values for <a href="keywords.html#CRADIUS">CRADIUS</a> or <a href="keywords.html#CMAXRAD">CMAXRAD</a>
must generally be adjusted accordingly.<br/>
<h4><a class="NoHi" id="CDISTRANS_P1"><b>CDISTRANS_P1</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), the raw features are interatomic distances
(<a href="keywords.html#CDISTANCE">CDISTANCE</a> is 7, 8, or 9), and a <a href="keywords.html#CDISTRANSFORM">transform other than the identity 
function</a> is used, this keyword sets a shift parameter. For the sigmoidal function, this is the parameter &chi;, for 
the hyperbolic function, it is the parameter r<sub>buf</sub>, and for the sine transform, it is the parameter r<sub>cut</sub>.
The equations are given <a href="keywords.html#CDISTRANSFORM">above</a>. The value is to be provided in &#8491; and
can be zero or positive.<br/>
<h4><a class="NoHi" id="CDISTRANS_P2"><b>CDISTRANS_P2</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), the raw features are interatomic distances
(<a href="keywords.html#CDISTANCE">CDISTANCE</a> is 7, 8, or 9), and either a sigmoidal or a hyperbolic <a href="keywords.html#CDISTRANSFORM">transform</a> is used,
this keyword sets a scale (or width) parameter. For the sigmoidal function, this is the parameter &tau; and for 
the hyperbolic function it is the parameter h<sub>exp</sub>. The equations are given <a href="keywords.html#CDISTRANSFORM">above</a>.
The value is either to be given in &#8491; (sigmoidal) or unitless (hyperbolic) and must be positive.<br/>
<h4><a class="NoHi" id="CWCOMBINATION"><b>CWCOMBINATION</b></a></h4>
If data for structural clustering or related analyses are collected (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>) and locally adaptive
weights are in use, this keyword sets the function to be used for combining locally adaptive weights from different snapshots.
This is relevant for options 2, 4, 9, and 10 for
 <a href="keywords.html#CDISTANCE">CDISTANCE</a>. The input is interpreted identically to that for keyword
<a href="keywords.html#ISQM">ISQM</a>, <i>i.e.</i>, values of -1, 0, and 1 give harmonic, geometric, and arithmetic means, respectively.
Values outside of this range can be expected to degrade performance due to expensive powers being evaluated. 
Special options avoiding most arithmetics altogether simply use the smaller or larger of the two values.
In reality, these correspond to the limits of negative and positive infinity, and they are available by selecting -999 and 999, respectively.<br/>
<h4><a class="NoHi" id="CPREPMODE"><b>CPREPMODE</b></a></h4>
If data for structural clustering or related analyses are collected (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), this keyword
offers the user a choice to perform simple data preprocessing operations. Specific options are as follows and are
all applied independently for all data dimensions:<br/>
<ol start="0">
<li>The data are untouched.</li>
<li>The data are centered (subtraction of the means).</li>
<li>The data are centered and scaled by the inverse standard deviation. The resultant data are often referred to as standard or Z-scores.</li>
<li>The data are smoothed by cardinal B-splines of specified <a href="keywords.html#CSMOOTHORDER">order</a>. This operation scales linearly with this order,
and it is therefore computationally wasteful to specify very large values (the long tails of the polynomial functions contribute little
to the smoothing). Note that virtually no result obtainable from these data is preserved upon smoothing (except the mean), which means that
results may become difficult to interpret.</li>
<li>The data are centered and smoothed.</li>
<li>The data are converted to Z-scores and then smoothed.</li>
</ol>
Note that centering leaves distance relations untouched. Centered data generally offer improved precision when computing dependent 
quantities relying on summation. If CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
these transformations are (currently) applied by the master thread alone.<br/>
<h4><a class="NoHi" id="CSMOOTHORDER"><b>CSMOOTHORDER</b></a></h4>
If data for structural clustering or related analyses are collected (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), data smoothing
may be in use. It is enabled by certain choices for keywords <a href="keywords.html#CMODWEIGHTS">CMODWEIGHTS</a> and <a href="keywords.html#CPREPMODE">CPREPMODE</a>.
Smoothing currently relies on cardinal B-splines, and this keyword lets the user specify the order of these functions. 
Cardinal B-splines are also used elsewhere (keywords <a href="keywords.html#BSPLINE">BSPLINE</a> for the PME method and
<a href="keywords.html#EMBSPLINE">EMBSPLINE</a> for structural density restraints), but the keywords are completely independent.<br/> 
<h4><a class="NoHi" id="CMODWEIGHTS"><b>CMODWEIGHTS</b></a></h4>
If data for structural clustering or related analyses are collected (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), and either static or locally
adaptive weights are in use (options 2, 4, 8-10 for <a href="keywords.html#CDISTANCE">CDISTANCE</a>), it is possible to override the
default weights with data-derived information obtained in post-processing. This is required for options 9 and 10 to be meaningful (the locally
adaptive weights for these cases are all initialized to be 1.0). Depending on the chosen option, additional parameters may be required.
A detailed list is as follows:<br/>
<ol start="0">
<li>This leaves all weights unchanged.</li>
<li>This option computes local estimates of the root mean square fluctuation (RMSF) and takes the inverse as the resultant, locally adaptive weight.
The <a href="keywords.html#CWINDOWSIZE">window size</a> is chosen by the user. The definition of "local" by proximity in the trajectory itself implies
that the data are ordered, usually along a time or similar progress axis. Note that this option is invariant only to data translation (centering).
The windowed MSF are computed using an incremental algorithm that has constant cost with window size.</li>
<li>This replaces weights with weights derived from the autocorrelation function (ACF) evaluated at fixed <a href="keywords.html#CLAGTIME">lag time</a>.
The weights are static, <i>i.e.</i>, they can be understood as a pre-scaling of the data. For dimensions with a negative ACF at the chosen lag time,
the weight is explicitly adjusted to zero, which means that the effective dimensionality can be reduced considerably. As second moments, ACF 
values are noisy and generally more reliable at short lag time. For
options 2 and 4 for <a href="keywords.html#CDISTANCE">CDISTANCE</a>, the resultant weight is always the larger of the two obtained
for sine and cosine terms. The ACF is invariant under data translation and global scaling operations.</li>
<li>This option computes a composite weight by taking the square root of the product of the ACF at fixed <a href="keywords.html#CLAGTIME">lag time</a>
(as for option 2) and the inverse RMSF over a window of specified <a href="keywords.html#CWINDOWSIZE">size</a> (as for option 2).</li>
<li>This option defines locally adaptive weights based on crossings of the global mean. Specifically, for each dimension, the global data
mean is computed. Over a window of a <a href="keywords.html#CWINDOWSIZE">user-defined size</a>, it is then counted how many times the 
value of that dimension crosses the mean. Each data point receives a weight based on a window centered at this point in terms of the trajectory.
The definition of "local" by proximity in the trajectory itself implies that the data are ordered, which is most often but not necessarily by time.
Because it is possible that the count is zero, the resultant, locally adaptive weights are computed as (n<sub>cross</sub>+a)<sup>-1</sup>,
where "n<sub>cross</sub>" is the aforementioned number of crossings of the global mean and "a" is a user-defined buffer parameter
(see keyword <a href="keywords.html#CTRANSBUF">CTRANSBUF</a>). For
options 2 and 4 for <a href="keywords.html#CDISTANCE">CDISTANCE</a>, the resultant weight is always the larger of the two obtained
for sine and cosine terms. The idea behind this type of weight is to deemphasize data dimensions sampling roughly symmetric distributions
with a single peak and to emphasize data dimensions sampling multimodal distributions with locally small variance. False negatives can be produced
if the global mean happens to coincide with one of the peaks of a multimodal distribution. These weights are exceptionally simple, can be computed efficiently and with
high accuracy for large data sets, and require no additional parameters beyond the <a href="keywords.html#CWINDOWSIZE">window size</a>.
They are also invariant for data translation and global scaling.</li>
<li>This option is the same as the previous one (#4) except that the data are smoothed for the purpose of generating weights. This leaves the
original data untouched, <i>i.e.</i>, it does
<i>not</i> imply data smoothing in general (see <a href="keywords.html#CPREPMODE">CPREPMODE</a> for the latter).
The smoothing entails an additional parameter, <i>viz.</i>, <a href="keywords.html#CSMOOTHORDER">CSMOOTHORDER</a>.</li>
<li>This option is a combinations of options #2 and #4. The final, locally adaptive weights correspond to the square root of the 
static weights derived from the ACF at fixed <a href="keywords.html#CLAGTIME">lag time</a> and the weights derived from
crossings of the global means within windows of <a href="keywords.html#CWINDOWSIZE">user-defined size</a>.</li>
<li>This option is the same as the previous one (#6) except that the data are smoothed for the purpose of generating the local component
of the weights (based on crossings of the mean). This does
<i>not</i> imply data smoothing in general. The smoothing entails an additional parameter, <i>viz.</i>, <a href="keywords.html#CSMOOTHORDER">CSMOOTHORDER</a>.</li>
<li>Similar to option #4, this defines locally adaptive weights based on counting crossings. Here, a histogram is created for each data dimension (fixed
number of 100 bins). From the histogram, CAMPARI automatically locates minima in the histogram (at least 3 bins to either side have to have larger counts).
Over a window of <a href="keywords.html#CWINDOWSIZE">user-defined size</a>, crossings of any of these minima are counted, and the weight is constructed
as w<sub>max</sub>/(n<sub>cross</sub>+1). Here, w<sub>max</sub> is an adjusting weight. Each minimum splits the data into two fractions of unequal size, 
and w<sub>max</sub> is the maximum of the smaller fractional populations across all minima. If no minima are found, this option reverts to option #4 
for the dimension in question. The histogram construction and minima parsing mask many parameters that cannot be controlled by the user
at the moment. Histograms are constructed in a way that makes these weights invariant for shifted and scaled data.
This option is marred primarily by the lack of both robustness and significance of the minima detection procedure.
The meaning of keyword <a href="keywords.html#CTRANSBUF">CTRANSBUF</a> is preserved in exactly the same way as for option #4.</li>
<li>This option is the same as the previous one (#8) except that the data are smoothed for the purpose of generating weights. This leaves the
original data untouched, <i>i.e.</i>, it does
<i>not</i> imply data smoothing in general. The smoothing entails an additional parameter, <i>viz.</i>, <a href="keywords.html#CSMOOTHORDER">CSMOOTHORDER</a>.</li>
</ol>
Note that a conversion of locally adaptive weights to static ones by means of this keyword will not reduce CAMPARI's memory footprint. When using any 
of the above options computing locally adaptive weights in conjunction with option 8 for <a href="keywords.html#CDISTANCE">CDISTANCE</a>, the
assumed window size is taken to be the entire trajectory, <i>i.e.</i>, the weights remain static.
If CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
the weights are (currently) calculated by the master thread alone.<br/>
<h4><a class="NoHi" id="CWINDOWSIZE"><b>CWINDOWSIZE</b></a></h4>
If data for structural clustering or related analyses are collected (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), and certain types of
locally adaptive weights are in use, this keyword sets the window size (in numbers of snapshots) from which to obtain the weight. Each snapshot is given a weight
derived from data in a window centered around that point. This makes sense primarily if the data are in a specific order, most often
they are assumed to be sorted by time. Points toward the beginning (or end) of the data set all obtain the same weight as the first (or last) snapshot to
have access to a complete window. This implies that windows should generally be much smaller than the data set length (they can at most
extend to half the data set length). This keyword is relevant for locally adaptive weights based on variances and transition counts that
can be selected via <a href="keywords.html#CMODWEIGHTS">CMODWEIGHTS</a>.<br/>
<h4><a class="NoHi" id="CLAGTIME"><b>CLAGTIME</b></a></h4>
If data for structural clustering or related analyses are collected (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), the autocorrelation function (ACF)
at fixed lag time can play a role, and this lag time is set by CLAGTIME. This is relevant if either static or locally
adaptive weights are in use (options 2, 4, 8-10 for <a href="keywords.html#CDISTANCE">CDISTANCE</a>), or if time structure-based independent
component analysis (tICA) is performed (see <a href="keywords.html#PCAMODE">PCAMODE</a>). This keyword sets the time (in numbers of snapshots) to be used for
this purpose.<br/>
In the case of weighted distance functions, the ACF is evaluated for each dimension independently and assumes a single, generating process:<br/>
ACF(&tau;) = [ &Sigma;<sup>N-&tau;</sup>(X<sub>(k)</sub>(n)-&mu;<sub>(k)</sub>)(X<sub>(k)</sub>(n+&tau;)-&mu;<sub>(k)</sub>) ] / [&sigma;<sub>(k)</sub><sup>2</sup>(N-&tau;)]<br/>
Here, the global data mean and variance, &mu;<sub>(k)</sub> and &sigma;<sub>(k)</sub><sup>2</sup>, are estimated directly from the data for each dimension.
Note that fewer data are available for large &tau;. Importantly, negative values for the ACF are all set exactly to zero meaning that
these data dimensions are eliminated from distance evaluations. When applied to dihedral angles (options 2 or 4), the ACF is always evaluated
separately for sine and cosine terms to avoid ambiguous definitions of variance for circular variables. The weight is then set to the larger of the two
values. In case of tICA, the ACF features as a time-lagged covariance matrix that is computed for simple, centered data (no circular variables, no pairwise alignment,
no locally adaptive weights). No corrections and truncations are applied to this matrix.<br/>
<h4><a class="NoHi" id="CREDUCEDIM"><b>CREDUCEDIM</b></a></h4>
If data for structural clustering are collected (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), and a linear transformation
is computed and applied (&rarr; <a href="keywords.html#PCAMODE">PCAMODE</a>), this keyword allows the user to elect
to run all further post-processing (&rarr; <a href="keywords.html#CMODE">CMODE</a>) on a data set of reduced dimensionality
that corresponds to the first <i>N<sub>V</sub></i> data vectors in the transformed space, where <i>N<sub>V</sub></i> is
set by the choice for this keyword. The components are sorted from largest to smallest eigenvalues 
such that the maximum amount of variance (<a href="keywords.html#PCAMODE">PCAMODE</a> is 3) or autocorrelation
(<a href="keywords.html#PCAMODE">PCAMODE</a> is 5) is included.<br/>
Note that the transformed data are interpreted as simple, aperiodic signals, <i>i.e.</i>, none of the
peculiarities for different choices of <a href="keywords.html#CDISTANCE">CDISTANCE</a> are considered any longer
(CAMPARI internally converts everything to <a href="keywords.html#CDISTANCE">CDISTANCE</a> being 7, which may
lead to confusing output regarding units, <i>etc</i>).
Specifically, for options 4, 9, and 10 for <a href="keywords.html#CDISTANCE">CDISTANCE</a>, the underlying locally
adaptive weights are averaged, and the data are pre-scaled by these averages. This means that use of this
keyword for those cases changes more than just the dimensionality. Similarly, for options 5 and 6, if 
<a href="keywords.html#CALIGN">alignment is requested</a>, this alignment is performed as a preprocessing step,
and the last snapshot of the data is used as reference. Furthermore, for option 6, only the atom set chosen for
distance evaluations is retained, and this is the set to eliminate further dimensions from with the help of this keyword.
Note that Euclidean distances are invariant for the full-dimensional transformed data set relative to the original data set in
PCA (<a href="keywords.html#PCAMODE">PCAMODE</a> is 3) but not in tICA (<a href="keywords.html#PCAMODE">PCAMODE</a> is 5).
This of course applies only to the linear transformation and not to any possible preprocessing operations.<br/>
If no linear transform is computed, or if the choice for <a href="keywords.html#PCAMODE">PCAMODE</a> implies that the data transform is not
actually computed, this keyword can be used to simply discard dimensions at the end of the internal list of dimensions.
This is supported for specialized applications and should not be used unless absolutely needed (use
<a href="keywords.html#CFILE">CFILE</a> to control dimensionality precisely). This option does not work with 
any distance measure requiring <a href="keywords.html#CALIGN">alignment</a>. 
In all cases, if CREDUCEDIM is not specified or set to too large a value, data processing will proceed with the original
data and the original size. If linear transforms have been computed, the transformed data are simply written to output file
<a href="outputfiles.html#PRINCIPAL_COMPONENTS.dat">PRINCIPAL_COMPONENTS.dat</a>
but not used otherwise.<br/>
<h4><a class="NoHi" id="CTRANSBUF"><b>CTRANSBUF</b></a></h4>
If data for structural clustering or related analyses are collected (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), and
weights are in use (options 2, 4, 8-10 for <a href="keywords.html#CDISTANCE">CDISTANCE</a>), it is possible to use alter
the definition of weights relying on counts of crossings (see option #4 and following for <a href="keywords.html#CMODWEIGHTS">CMODWEIGHTS</a>).
In a general functional form of w = (n+a)<sup>-1</sup>, the offset or buffer parameter a is set by this keyword.
The default value is 1. Large values will lead to weights with low sensitivity. The limit of CTRANSBUF approaching 
zero will lead to cases with n=0 receiving all the weight, which is not generally useful.<br/>
<h4><a class="NoHi" id="CDUMP"><b>CDUMP</b></a></h4>
If data for structural clustering or related analyses are collected (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), this simple
logical keyword instructs CAMPARI to write the <a href="keywords.html#CPREPMODE">preprocessed</a> set of features along with
<a href="keywords.html#CMODWEIGHTS">possible weights</a> and after eventual <a href="keywords.html#CREDUCEDIM">dimensionality reduction</a>
to a <a href="outputfiles.html#CLUSTERING_FEATURES.nc">binary output file</a>. This file
can later be reused in <a href="keywords.html#netcdf_analysis">CAMPARI's data mining mode</a>. 
<h4><a class="NoHi" id="CMODE"><b>CMODE</b></a></h4>
If data for structural clustering are to be collected (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), this keyword
allows the user the specify the algorithm by which the accumulated data are to be clustered.
Before going into detailed options, a few general words are in order:<br/>
<ol type='a'>
<li>CAMPARI strives to allow the geometric and other net quantities of a collection of snapshots to be computable irrespective
of which metric of proximity is chosen (&rarr; <a href="keywords.html#CDISTANCE">CDISTANCE</a>). For options 3 and 7 this
is trivial. For option 1, periodicity has to be accounted for. This is solved approximately by i) making sure the proper image
of an added snapshot is considered, ii) adding appropriate periodic shifts to the geometric center
increments each time a boundary violation is found after updating. Other transforms are corrected accordingly. Options
2 and 4 incur the use of several additional cluster sums (means) due to the dynamic weights (for details, the reader
is referred to the source code in <a href="../source/clustering_utils.f90">clustering_utils.f90</a>: key subroutines
are "clustering_distance" or "cluster_addsnap").
For option 5 (atomic coordinate RMSD), the first member of a cluster defines a reference frame. This frame is used for alignment of all
subsequently added frames (therefore, the definition and all derived quantities are approximate although the error is
usually small for small clusters). Option 6 is a generalization of this allowing for a split of the set of
coordinates into an alignment and a distance subset. Option 8 is a mass-weighted equivalent of option 7.
Options 9 and 10 are extensions of 7 and 5 to use dynamic weights as for options 2 and 4, which again requires maintaining
additional cluster sums.</li>
<li>With the geometric center being defined, certain properties of a cluster are computable at constant cost with respect
to cluster size. For example, the square of the average distance from the center ("radius") is, in the simplest case, given as:
R<sup>2</sup> = D<sup>-1</sup> N<sup>-2</sup> &#183; [ N &#183; &Sigma;<sub>k</sub><sup>N</sup> <b>x</b><sub>k</sub><sup>2</sup> - 
&Sigma;<sub>k</sub><sup>N</sup><b>x</b><sub>k</sub> &#183; &Sigma;<sub>k</sub><sup>N</sup><b>x</b><sub>k</sub>]<br/>
<b>x</b><sub>k</sub> denotes the coordinate vector belonging to the k<sup>th</sup> member of the cluster, D is the number
of coordinates, and N is the number of members of the cluster.
Other properties such as the mean snapshot-to-snapshot distance ("diameter") are similarly available. All that is required
is that each cluster accumulates the necessary cluster sums.</li>
</ol>
The ability to compute properties of clusters in constant time was introduced in the <a href="references.html#ref23_3">BIRCH clustering algorithm</a>. 
It is a crucial advance when attempting to provide a scalable assessment/annotation of the results and/or
to implement scalable refinement steps. It does, however, imply the Euclidean metric as the functional form for
measuring dissimilarity.<br/>
The currently implemented options for CMODE are as follows (the short discussion above applies to all of them
except option 4 when <a href="keywords.html#CPROGINDMODE">CPROGINDMODE</a> is 1):
<ol>
<li>
The data are clustered according to the leader algorithm. This is a very simple algorithm that sequentially scans the
data. Each new snapshot is compared to the center snapshots of preexisting clusters and added to the first one for which
a provided distance threshold is satisfied (&rarr; <a href="keywords.html#CRADIUS">CRADIUS</a>). If no such cluster is found, a new
cluster is spawned. Results will be input order dependent and clusters will have ill-defined "centers" since the central
snapshot is set at the time the cluster is spawned and remains unchanged. Processing direction(s) can be chosen
with the auxiliary keyword <a href="keywords.html#CLEADER">CLEADER</a>. The leader algorithm has not been parallelized
and is executed by a single thread when CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
It generally offers no obvious benefit over the tree-based algorithm below (option 5). The performance of the leader algorithm
deteriorates with decreasing <a href="keywords.html#CRADIUS">threshold</a> because the number of spawned clusters will eventually
become significant relative to the number of snapshots.
</li>
<li>
The data are clustered according to a modified leader algorithm. This works very similarly to the standard leader algorithm
with two important modifications. First, each new snapshot is compared to the <i>current geometric center</i> of preexisting clusters
to evaluate the threshold criterion. Second, the result is (optionally &rarr; <a href="keywords.html#CREFINE">CREFINE</a>) post-processed and snapshots belonging to smaller clusters that would
also satisfy the threshold criterion for a larger cluster are transferred to that larger cluster. There are exactly two passes
over the data of this refinement step (iteration is difficult and time-consuming due to continuously changing cluster centers). 
Processing direction(s) can be chosen with the auxiliary keyword <a href="keywords.html#CLEADER">CLEADER</a>
and the threshold criterion is set via <a href="keywords.html#CRADIUS">CRADIUS</a>. Modified leader-based clustering
tends to generate fewer clusters compared to the standard leader algorithm due to better cluster centers. Due to
centers changing position, the maximum snapshot-to-snapshot distance is no longer guaranteed to be below
twice the value for <a href="keywords.html#CRADIUS">CRADIUS</a> (although in typical scenarios violations are
very rare). The modified leader algorithm has not been parallelized
and is executed by a single thread when CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use,
It generally offers no obvious benefit over the tree-based algorithm below (option 5).
</li>
<li>
The data are clustered according to a hierarchical algorithm. In theory, a hierarchical algorithm works by first creating
a sorted list of all N(N-1)/2 unique snapshot-to-snapshot distances. Starting with the shortest distance, the two constituting
snapshots do one of the following:<ol type='a'>
  <li>They spawn a new cluster (if they are both unassigned and the threshold criterion is fulfilled).</li>
  <li>They merge the two clusters they belong to (if they are both assigned and the threshold criterion is fulfilled).</li>
  <li>The cluster the previously assigned snapshot is part of is appended with the unassigned snapshot (if one of them is unassigned
and the threshold criterion is fulfilled).</li>
  <li>They terminate the algorithm (if the threshold criterion is not fulfilled).</li></ol>
In theory, it is possible to terminate the algorithm after a certain number of clusters has been generated, but CAMPARI
does not offer this (yet). Termination occurs strictly by size threshold, <i>i.e.</i>, as soon as the next considered
distance is larger than twice the value for <a href="keywords.html#CRADIUS">CRADIUS</a>. Note that the threshold criteria
mentioned above for what happens to the two constituting snapshots rely on the setting for <a href="keywords.html#CLINKAGE">CLINKAGE</a>.
All snapshots that remain unassigned after clustering are interpreted to spawn their own clusters of size 1.<br/>
Because the problem as stated is intractable for large data sets, CAMPARI uses a dedicated scheme to help keep the computation 
as feasible as possible. In the first step, a snapshot neighbor list is generated that uses a truncation cutoff set by
<a href="keywords.html#CCUTOFF">CCUTOFF</a>. The neighbor list generation uses a pre-processing trick that aims to reduce
the number of required distance calculations. This pre-processing step relies on a truncated leader algorithm whose target (threshold)
cluster size is set by the (borrowed) keyword <a href="keywords.html#CMAXRAD">CMAXRAD</a>. The resultant clusters are then used
to screen groups of snapshot pairs and to exclude them from distance computations. Unfortunately, the problem of dimensionality
often renders this procedure worthless. In high-dimensional spaces &rarr; <a href="keywords.html#CFILE">CFILE</a>, volume grows
with distance so quickly that the distance spectrum becomes increasingly &delta; function-like, and in turn becomes unsuitable
for exploiting additive relationships. This stems from conformational distances having a rigorous upper bound for systems in finite
volume and with fixed topology. The situation is obfuscated further if many of the dimensions are tightly correlated (such that
the effective number of dimensions is indeed lower).
 Alternatively, this neighbor list can be read in from a previously obtained
file (&rarr; <a href="keywords.html#NBLFILE">NBLFILE</a>). The neighbor list is then further truncated to exactly match the size threshold specified via <a href="keywords.html#CRADIUS">CRADIUS</a>.
For the algorithm to work properly, <a href="keywords.html#CCUTOFF">CCUTOFF</a> has to be at least twice the value of
<a href="keywords.html#CRADIUS">CRADIUS</a>. From this truncated list, a global list is created and sorted according to size.
This can be quite memory-demanding. The global list is then fed into the algorithm as described. The results of hierarchical clustering
depend very strongly on the linkage criterion (&rarr; <a href="keywords.html#CLINKAGE">CLINKAGE</a>). For many real and high-dimensional
data sets, the limitations in both processing time and memory footprint mean that analyses are restricted to thousands of snapshots.
The hierarchical algorithm has not been parallelized and is executed by a single thread when CAMPARI's
<a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use, This is in part because such a parallelization would
not solve the memory problem.
</li>
<li>
The data are arranged according to the so-called progress index method described in detail elsewhere (&rarr; <a href="references.html#ref23_5">reference</a>).
The progress index is a rearrangement of the snapshots such that a given snapshot at position <i>i</i> is added on account of it having
the shortest available distance to any snapshot <i>j&lt;i</i>. In its exact form, this is resemblant of the hierarchical clustering 
described directly above. In technical terms, the main (and only real) (hyper)parameter is a specified
<a href="keywords.html#CDISTANCE">criterion of distance</a>. Using this criterion, either the exact minimum spanning tree (MST) or an
approximation to it is constructed for the underlying complete graph constituted by all trajectory snapshots (vertices) and
the N&#183;(N-1)/2 unique, pairwise distances (weighted edges) between them. The spanning tree is a convenient data structure
for deriving the progress index but it is not conceptually fundamental to the algorithm.
Provided a certain starting snapshot, the spanning tree is mined to generate a sequence of snapshots (progress index)
with the above property, <i>i.e.</i>, the snapshot added next is the one that has the minimum distance
to any other snapshot already added. The complete progress index has the desirable property that it is likely to group similar objects together
without overlap. In order to work, it requires the sampling density to be sufficiently inhomogeneous, <i>i.e.</i>,
there are enclosed regions (basins) that are sampled preferentially and that consequently have higher point density than the regions 
connecting them. It is important to keep in mind that the chosen <a href="keywords.html#CFILE">features</a> along with any
preprocessing steps (<i>e.g.</i>, <a href="keywords.html#CMODWEIGHTS">weights</a>) may project/distort the full, underlying phase space.<br/>
The method provides an annotation function for the progress index that contains kinetic (or effectively kinetic) information.
This function assumes that the evolution of the system is incremental and happens on a continuous manifold. Therefore, apparent jumps in phase
space such as those introduced by the <a href="keywords.html#REMC">replica-exchange methodology</a> may diminish the value of this
annotation. There are alternative annotation functions, and some are discussed further in the documentation of the
corresponding <a href="outputfiles.html#PROGIDX_xxxxxxxxxxxx.dat">output file</a>.
For practical concerns, there is a methodological choice to pick either the exact or the approximate scheme (&rarr; <a href="keywords.html#CPROGINDMODE">CPROGINDMODE</a>)
in addition to providing a starting snapshot (&rarr; <a href="keywords.html#CPROGINDSTART">CPROGINDSTART</a>). There are further keywords 
associated exclusively with this methodology, the most important one being <a href="keywords.html#CPROGINDRMAX">CPROGINDRMAX</a>,
which sets the number of search attempts per snapshot per iteration for the approximate scheme (this is the
primary controllable determinant of computational cost). 
Keyword <a href="keywords.html#CPROGINDWIDTH">CPROGINDWIDTH</a> is a parameter related to annotations while 
<a href="keywords.html#CBASINMIN">CBASINMIN</a> and <a href="keywords.html#CBASINMAX">CBASINMAX</a> are related to
automatic ways of finding starting snapshots. The approximate
scheme runs almost entirely in parallel with excellent efficiency when CAMPARI's
<a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use.
Compared to the <a href="references.html#ref23_5">published algorithm</a>, there are a few technical tweaks to allow this
parallelization: these pertain to the auxiliary clustering (see option 5 below as well as keyword
<a href="keywords.html#BIRCHMULTI">BIRCHMULTI</a>), to search exhaustiveness (&rarr; <a href="keywords.html#CPROGRDEPTH">CPROGRDEPTH</a>),
to the handling of points in low-density regions that are not between basins (&rarr; <a href="keywords.html#CPROGMSTFOLD">CPROGMSTFOLD</a>),
and to the parallel random search procedure itself (&rarr; <a href="keywords.html#CPROGRDBTSZ">CPROGRDBTSZ</a>),
</li>
<li>
The data are clustered according to a tree-based algorithm (&rarr; <a href="references.html#ref23_4">reference</a>) that
shares architectural similarities with the <a href="references.html#ref23_3">BIRCH clustering algorithm</a>. 
The tree algorithm implemented in CAMPARI is not focused on memory efficiency but instead keeps the entire data set stored in memory.
The tree is assumed to be of a set height (number of hierarchical levels &rarr; <a href="keywords.html#BIRCHHEIGHT">BIRCHHEIGHT</a>) that span a provided
range of threshold criteria (upper and lower bounds set by <a href="keywords.html#CMAXRAD">CMAXRAD</a> and
<a href="keywords.html#CRADIUS">CRADIUS</a>, respectively) for cluster sizes. In the process of 
providing a parallel version for CAMPARI's
<a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a>, a few minor modifications relative to the
<a href="references.html#ref23_4">published algorithm</a> were also introduced for the serial version. These modifications
are included in the description below.
Briefly, the algorithm consists of three phases. In the first phase, the levels are looped over starting at the root of the tree (the coarsest level)
and going up to the penultimate level.
At each level, every snapshot is added to an existing cluster (if the nearest distance is below the threshold for that level) or it spawns a new one
(if it is not). The metric is defined
by the <a href="keywords.html#CDISTANCE">criterion of distance</a> applied to the snapshot and the geometric center of the cluster.
The key trick is that the search space (in terms of clusters) for a given snapshot is only the (growing) set of children of the cluster
this snapshot belongs to on the previous level. By spacing the thresholds accordingly, it can thus be achieved that the
number of clusters searched per level and snapshot is constant irrespective of data set size. During the first phase, cluster centroids
move on account of snapshots being added (compare the modified leader algorithm above). The first phase can be understood
as "learning the tree" from the data. In the second phase, cluster centroids are frozen and all snapshots are reassigned
to the nearest existing cluster. This again loops over the same levels as phase 1. The second phase can be understood as "binning"
all snapshots into the learned tree. In the third and last phase, the results from phase 2 are used as follows. For a given
cluster on a given level, all the snapshots it contains after phase 2 are subjected to a "local" reclustering at the next finer level, <i>i.e.</i>,
the search space is restricted to the binning results at the next coarser level. Phase 3 is executed for the penultimate level,
which gives rise to the finest (leaf level) clustering, and potentially additional levels (see <a href="keywords.html#BIRCHMULTI">BIRCHMULTI</a>).
As for refinement, the challenge is to find protocols that do not exceed the time/space complexity of the algorithm itself.
Currently, there is only one type of <a href="keywords.html#CREFINE">optional refinement step</a> that will locally merge leaf clusters
that have different but proximal parent clusters if the diameter of the joint cluster decreases upon merging (relative to
the individual values).<br/>
Except refinement, the tree-based algorithm has been fully <a href="keywords.html#NRTHREADS">OpenMP-parallelized</a>. While phases 2 and 3
are relatively straightforward in this regard, phase 1 is more tricky. To achieve stable results that are identical to those of the
(slightly modified) serial version, the coarsest level can only be addressed by a single thread at a time, which obviously impairs
load balance. This requires keyword <a href="keywords.html#BIRCHCHUNKSZ">BIRCHCHUNKSZ</a> to be 1, which is the default. 
In parallel, the clustering can alternatively try to achieve better load balance by a divide-and-merge scheme described 
in the context of keywords <a href="keywords.html#BIRCHCHUNKSZ">BIRCHCHUNKSZ</a> and <a href="keywords.html#CMERGEDIAM">CMERGEDIAM</a>.
In general, the tree-based algorithm is extremely fast and will generate more clusters 
than, for example, the leader algorithm with the same setting for <a href="keywords.html#CRADIUS">CRADIUS</a>. However, the cluster distribution
is altered nonuniformly (the largest clusters in the tree-based algorithm will often be <i>larger</i>, but the number of very
small clusters (1-5 snapshots) will increase substantially, especially for large <a href="keywords.html#BIRCHHEIGHT">height</a>).
Overall, the clusters tend to be substantially tighter. In essence, the multiple hierarchical levels act, metaphorically speaking,
as a layered array of filters that creates a resultant net pore size that is smaller than any one of the filters by themselves.
</li>
<li>The data are assumed to be clustered already, and the clustering is read from a <a href="inputfiles.html#FMCSC_CLUFILE">dedicated input file</a>.
This takes a list of snapshot-to-cluster mappings that is identical to the simple output produced in
<a href="outputfiles.html#STRUCT_CLUSTERING.clu">STRUCT_CLUSTERING.clu</a>. This mode is obviously redundant unless further
operations dependent on the clustering are performed, <i>e.g.</i>, obtaining a <a href="outputfiles.html#STRUCT_CLUSTERING.graphml">graph output file</a>,
 <a href="keywords.html#CREWEIGHT">network-based reweighting</a>, calculating a <a href="keywords.html#CMSMCFEP">cut-based free energy profile</a>, and so on.
The actual data are read and fully processed. This has two important consequences. First, the clustering is completely reconstructed
including information about geometric sizes and distances. Second, the time savings relative to redoing the clustering may not
be significant (<i>e.g.</i>, for typical applications with large data sets, the tree-based clustering itself takes little time
compared to reading and processing the input trajectory).</li>
<li>This is the same as the previous option, <i>i.e.</i>, the data are assumed to be clustered already, and the clustering is read
from a <a href="inputfiles.html#FMCSC_CLUFILE">dedicated input file</a>. The important difference is that the actual data are not read.
This means that information about geometric sizes and distances of clusters and snapshots is not present, and any options relying
on this information are either disabled or redundant. This option is useful if repeated graph-based operations are to be performed
on a fixed clustering, <i>e.g.</i>, changing the <a href="keywords.html#CLAGT_MSM">lag time of a Markov state model</a> and
<a href="keywords.html#CREWEIGHT">recalculating the steady state</a>. It can reduce both execution time and memory usage dramatically.
In this mode, CAMPARI's normal functionality is entirely skipped (although it is still required to define a(n arbitrary) system, which
can lead to (irrelevant) warnings and messages being printed).</li> 
</ol>
All methods mentioned above, with the exception of the <a href="keywords.html#CPROGINDMODE">exact progress index method</a>, 
create either as the final product or as a by-product a clustering. If this clustering is interpreted as a continuous trajectory of discrete states
in a propagation variable such as time, it can make sense to derive a <a href="keywords.html#TMAT_MD">transition matrix (network model or MSM)</a> from it. For this,
the snapshot-to-snapshot transitions in the original trajectory are mapped to state-to-state transitions, from which the count matrix
is derived (see <a href="keywords.html#TMAT_MD">elsewhere</a> for details).
The network model is written to a <a href="outputfiles.html#STRUCT_CLUSTERING.graphml">graph output file</a>
and can be used in further analyses (<i>e.g.</i>, <a href="keywords.html#CREWEIGHT">network-based reweighting</a>,
<a href="keywords.html#CMSMCFEP">cut-based free energy profiles</a>, <a href="keywords.html#DOPFOLD">committor probabilities</a>,
and so on). The count matrix generally assumes that snapshots are directly connected (<i>i</i> to <i>i+1</i>). This map can be 
altered by reading a <a href="keywords.html#TRAJBREAKSFILE">file with additional breaks</a>, by a 
<a href="keywords.html#TRACEFILE">trace file from a PIGS run</a>, and by a <a href="keywords.html#TRAJLINKSFILE">file with additional links</a>.
An additional modification is the introduction of <a href="keywords.html#CLAGT_MSM">lag time</a> different from unity. The first
two file-based modifications respond to lag time while the additional links do not. There are also link modifications at the network
level supported through keyword <a href="keywords.html#CADDLINKMODE">CADDLINKMODE</a>.<br/>
Note that the connectivity map for snapshots <i>always</i> refers to the actual data that ends up in memory. This is controlled
by <a href="keywords.html#NRSTEPS">NRSTEPS</a>, <a href="keywords.html#CCOLLECT">CCOLLECT</a>, <a href="keywords.html#EQUIL">EQUIL</a>,
and, if present, an <a href="keywords.html#FRAMESFILE">input file with subsets of frames</a>. It is consequently up to the user
to ensure that the constructed network model remains meaningful.<br/>
<h4><a class="NoHi" id="CLUFILE"><b>CLUFILE</b></a></h4>
If data for structural clustering are to be collected (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>),
this keyword lets the user provide the name and location of a file containing a series of integers to be interpreted 
as the main input for <a href="keywords.html#CMODE">file-based clustering</a>. This file should be formatted identically
to the output file <a href="outputfiles.html#STRUCT_CLUSTERING.clu">STRUCT_CLUSTERING.clu</a> written by CAMPARI itself.
The associated keyword <a href="keywords.html#CLUFILECOL">CLUFILECOL</a> can be used to pick from the possibly more than one columns 
in the input file. Some more details are provided <a href="inputfiles.html#FMCSC_CLUFILE">elsewhere</a>.<br/>
The limitations are as follows. First, <a href="keywords.html#PDBANALYZE">trajectory analysis mode</a> has to be enabled.
Second, no MPI support exists if the data are not also read. Third, the file should be analyzed with settings that pertain
to the underlying data and are not remapped to the file itself (<i>i.e.</i>, if the file is produced by CAMPARI itself, input settings should be the same as 
the settings for the original clustering). For example: Using <a href="keywords.html#NEQUIL">NEQUIL</a> 1000 and <a href="keywords.html#CCOLLECT">CCOLLECT</a> 10, 
a trajectory of <a href="keywords.html#NRSTEPS">10000</a> snapshots would give rise to 900 entries for the output in
 <a href="outputfiles.html#STRUCT_CLUSTERING.clu">STRUCT_CLUSTERING.clu</a> (corresponding 1010, 1020, 1030, ..., 10000).
While it would be possible to reset <a href="keywords.html#NEQUIL">NEQUIL</a> to 0, <a href="keywords.html#NRSTEPS">NRSTEPS</a> to 900,
and <a href="keywords.html#CCOLLECT">CCOLLECT</a> to 1
to read these data back in, doing so would destroy the validity of any auxiliary input file that refers to snapshot numbers in the
original trajectory. Files that do so irrespective of the setting for <a href="keywords.html#CCOLLECT">CCOLLECT</a> and other modifiers are 
<a href="keywords.html#TRAJBREAKSFILE">files with additional breaks</a>, 
<a href="keywords.html#TRACEFILE">trace files from PIGS runs</a>, or <a href="keywords.html#TRAJLINKSFILE">files with additional links</a>.
Instead, keywords should be left at their original settings. This is because the snapshot connectivity structure is inferred
independently and before the clustering (irrespective of algorithm) is performed or (if <a href="keywords.html#CMODE">CMODE</a> is not 7)
the data are even read.<br/>
<h4><a class="NoHi" id="CLUFILECOL"><b>CLUFILECOL</b></a></h4>
If data for structural clustering are to be collected (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>),
and file-based clustering has been selected (<a href="keywords.html#CMODE">CMODE</a> is either 6 or 7), this keyword
allows the user to pick a particular column (default is 1) from the <a href="keywords.html#CLUFILE">input file</a>.
The input file format is the same as that of output file <a href="outputfiles.html#STRUCT_CLUSTERING.clu">STRUCT_CLUSTERING.clu</a>,
and some more details are provided <a href="inputfiles.html#FMCSC_CLUFILE">elsewhere</a>.<br/>
If the clustering was generated by the tree-based clustering with a number of informative resolutions 
(see keywords <a href="keywords.html#BIRCHHEIGHT">BIRCHHEIGHT</a> and <a href="keywords.html#BIRCHMULTI">BIRCHMULTI</a>),
CLUFILECOL can be used to quickly calculate network-derived properties for a number of resolutions, which can be used
to assess the robustness of a result or to find the best resolution given a target property.<br/>
<h4><a class="NoHi" id="CCUTOFF"><b>CCUTOFF</b></a></h4>
If data for structural clustering are to be collected (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), and an algorithm is
used that requires a rigorous snapshot neighbor list (currently either hierarchical clustering or the exact variant
of the progress-index based scheme &rarr; <a href="keywords.html#CMODE">CMODE</a>), this keyword defines the cutoff distance for said neighbor list.
It is very critical to choose an appropriate (as small as possible) value for this parameter as otherwise CAMPARI will both run out
of (virtual) memory and create humongous files that are written to disk. Note that even with a minimal setting,
the problem of computing and storing the neighbor list can very easily become intractable. Often simulation
data in high-dimensional spaces will be clustered very unevenly in space meaning that multiple "length scales"
in distance space matter. This is detrimental to a neighbor list relying on defining a single, specific length
scale through CCUTOFF. 
<h4><a class="NoHi" id="NBLFILE"><b>NBLFILE</b></a></h4>
If data for structural clustering are to be collected (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), and an algorithm is
used that requires a rigorous snapshot neighbor list (currently either hierarchical clustering or the exact variant
of the progress-index based scheme &rarr; <a href="keywords.html#CMODE">CMODE</a>), this keyword can be used to provide name
and location of an input file in the appropriate format. CAMPARI uses the versatile binary NetCDF format
for this purpose, and consequently the code needs to be linked to the NetCDF library for this option
to be available (see <a href="install.html">installation instructions</a>). Most commonly,
this type of file will have been created by CAMPARI itself (it is automatically written if the
code is linked against NetCDF and if an algorithm is used that requires a neighbor list &rarr;
<a href="outputfiles.html#FRAMES_NBL.nc">corresponding documentation</a>). This keyword
is primarily meant to circumvent the costly neighbor list generation in subsequent applications of
the algorithm (for instance, with different settings for  <a href="keywords.html#CRADIUS">CRADIUS</a>).<br/>
<h4><a class="NoHi" id="CRADIUS"><b>CRADIUS</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), and an algorithm is
used that uses a distance (span) threshold criterion (&rarr; <a href="keywords.html#CMODE">CMODE</a>),
this keyword sets the value for said threshold criterion.
For leader-based clustering this is either the distance from the center snapshot (standard leader) or from the current geometric
center (modified leader) and therefore constitutes a maximum cluster radius. For hierarchical clustering, twice this
value is the maximum distance of any two snapshots to be part of the same cluster, so again CRADIUS will control
the maximum cluster radius. For tree-based clustering, this keyword again sets the maximum distance from the
current geometric center. Values are to be provided in &#197; for proximity measures 5-10, unitless for 3-4, and in 
degrees for 1-2 (&rarr; <a href="keywords.html#CDISTANCE">CDISTANCE</a>).<br/>
<h4><a class="NoHi" id="CREFINE"><b>CREFINE</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), this simple logical
keyword lets the user control whether to apply any possible refinement strategies to the initial clustering
results. Currently, there are two such procedures: for the modified leader algorithms, a refinement procedure
is available which redistributes polyvalent snapshots to larger clusters. For the tree-based algorithm
(for descriptions of these methods see <a href="keywords.html#CMODE">elsewhere</a>), a possible refinement
consists of a (noniterative) merging of clusters with sufficient overlap. They are largely experimental procedures
and can have a strong negative impact on performance. In particular, in the <a href="keywords.html#NRTHREADS">OpenMP parallel execution</a>
of the tree-based algorithm, only a single thread does the refinement.<br/>
<h4><a class="NoHi" id="CRESORT"><b>CRESORT</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), this simple logical
keyword lets the user control whether to break ties in the sorting of clusters by size in a systematic way.
If set to 1, CAMPARI will resort clusters with identical sizes by the indices of their centroid representatives
or origin snapshots in increasing order. This is useful primarily in <a href="keywords.html#NRTHREADS">OpenMP parallel executions</a>
of the tree-based clustering (<a href="keywords.html#CMODE">CMODE</a> is 4 or 5) when clustering consistency
is achieved (the <a href="keywords.html#BIRCHCHUNKSZ">batch size parameter</a> is 1). Under these circumstances,
results are technically identical across multiple runs with more than one thread, but can differ in the order
of clusters of identical sizes. This inconvenience can be avoided using keyword CRESORT.<br/>
<h4><a class="NoHi" id="CLEADER"><b>CLEADER</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), and a leader-based
algorithm is used (&rarr; <a href="keywords.html#CMODE">CMODE</a>), this keyword allows the user
to alter the processing directions of the leader algorithm by the following codes:<br/>
<ol>
<li>The collected trajectory data are processed forward. Clusters are searched backward (starting with the most recently
spawned one).</li>
<li>The collected trajectory data are processed forward. Clusters are searched forward (starting with the one spawned first).</li>
<li>The collected trajectory data are processed backward. Clusters are searched backward (starting with the most recently
spawned one).</li>
<li>The collected trajectory data are processed backward. Clusters are searched forward (starting with the one spawned first).</li>
</ol>
Note that the default is option 1, <i>i.e.</i> to process trajectory data forward, but to search clusters backwards.
If the underlying data are continuous in time this may be more appropriate as it favors kinetic proximity in addition
to the structural proximity criterion defined by <a href="keywords.html#CRADIUS">CRADIUS</a>. Note that this
keyword also controls the trajectory processing direction in tree-based clustering (&rarr; <a href="keywords.html#CMODE">CMODE</a>).<br/>
<h4><a class="NoHi" id="CLINKAGE"><b>CLINKAGE</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), and the hierarchical
algorithm is used (&rarr; <a href="keywords.html#CMODE">CMODE</a>), this keyword allows the user
to choose between different linkage criteria:<br/>
<ol>
<li>Maximum linkage: Appending a cluster with a snapshot implies that the new snapshot is less than twice the value
for <a href="keywords.html#CRADIUS">CRADIUS</a> away from all snapshots currently part of the cluster. For merging
two clusters, maximum linkage implies that all possible inter-cluster distances satisfy the threshold condition. This
creates clusters with an exact upper bound for their diameter (maximum intra-cluster distance) and therefore resembles
leader clustering.</li>
<li>Minimum linkage: Appending a cluster with a snapshot implies that the new snapshot is within a distance of 
twice the value for <a href="keywords.html#CRADIUS">CRADIUS</a> of at least one snapshot already contained in the cluster.
Merging two clusters implies that at least one inter-cluster distance satisfies the threshold condition. With a minimum
linkage criterion clusters no longer have a well-defined radius and tend to get very large unless tiny values are used
for <a href="keywords.html#CRADIUS">CRADIUS</a>. This is rarely a useful option for molecular simulation data.</li>
<li>Mean linkage: Appending a cluster with a snapshot implies that the snapshot is within a distance of 
<a href="keywords.html#CRADIUS">CRADIUS</a> of the current geometric center of the cluster. Merging two clusters
implies that their respective geometric centers are within a distance of <a href="keywords.html#CRADIUS">CRADIUS</a> of
one another. This will create clusters that no longer have a rigorous upper bound for the intra-cluster distance
and therefore resembles the modified leader algorithm.</li>
</ol>
Note that the default is option 1, <i>i.e.</i> to use maximum linkage.<br/>
<h4><a class="NoHi" id="CMAXRAD"><b>CMAXRAD</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), and the tree-based
algorithm or the approximate progress index-based scheme is used (&rarr; <a href="keywords.html#CMODE">CMODE</a>), this keyword sets the upper distance threshold value
for the hierarchical tree, <i>i.e.</i>, it corresponds to the coarsest threshold used outside of the (virtual) root
(see <a href="keywords.html#BIRCHHEIGHT">BIRCHHEIGHT</a> for additional details).<br/>
<h4><a class="NoHi" id="BIRCHHEIGHT"><b>BIRCHHEIGHT</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), and the tree-based
algorithm or the approximate progress index-based scheme is used (&rarr; <a href="keywords.html#CMODE">CMODE</a>),
this keyword sets the number of hierarchy levels in the clustering algorithm.
Briefly, the tree-based algorithm works by defining a series of threshold criteria (set by interpolating between <a href="keywords.html#CRADIUS">CRADIUS</a>
and <a href="keywords.html#CMAXRAD">CMAXRAD</a>) that define hierarchical levels. An initial clustering tree is learned from
the data (phase 1), the snapshots are reassigned to the learned clusters (phase 2), and the reassignment
is used to recluster at the next finer level (phase 3). In all phases, the fundamental trick is to restrict the search
space for adding snapshots to clusters with the help of the tree structure (parent-child relations).
The base of the tree is never counted toward BIRCHHEIGHT as it always encloses all snapshots.
By specifying 1 for BIRCHHEIGHT one can thus recover an algorithm that is
- in its basic outline - very similar to the modified leader scheme (see <a href="keywords.html#CMODE">CMODE</a>).<br/>
Larger numbers of levels generally lead to the formation of more clusters. This is because of a specific characteristic that
is linked to the fact that children of a cluster (<i>i.e.</i>, a set of clusters at the next finer level) can occupy similar space as the children from
a nearby parent. If a snapshot explores only the children of a single 
cluster, inevitably the chances increase that an actual appropriate target cluster at finer levels is missed. In phase 3, this leads to 
the creation of tight clusters that are "too small" with respect to the desired <a href="keywords.html#CRADIUS">threshold</a>, <i>i.e.</i>,
this new cluster could theoretically be combined with one or more nearby clusters without
the maximum intracluster distance ever exceeding the distance threshold. The offered <a href="keywords.html#CREFINE">refinement</a>
option is meant precisely to combat these errors. However, this merging scheme cannot extend arbitrarily far toward 
the root without destroying the computational efficiency of the algorithm. It also needs to apply stringent criteria.
In practical terms, the value of BIRCHHEIGHT
is a relatively free parameter if the smaller clusters can be tolerated (their quality is not compromised). In particular
it can be used, in conjunction with <a href="keywords.html#BIRCHMULTI">BIRCHMULTI</a>, to create a high-quality
multi-resolution clustering, which is a desirable starting point for network model optimization. At coarser resolutions,
if a <a href="keywords.html#NRTHREADS">multi-threaded executable</a> is in use, the divide-and-merge strategy
(see <a href="keywords.html#BIRCHCHUNKSZ">BIRCHCHUNKSZ</a>) actually offers a separate handle on this characteristic.<br/>
<h4><a class="NoHi" id="BIRCHMULTI"><b>BIRCHMULTI</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), and the tree-based
algorithm or the approximate progress index-based scheme is used (&rarr; <a href="keywords.html#CMODE">CMODE</a>),
this keyword sets the number of hierarchy levels to refine during the second stage of the algorithm. Normally, only
the most fine-grained (so-called leaf) level is populated in phase 3 of the algorithm. This leaves all levels closer toward the 
root in a less refined state. By specifying a value for BIRCHMULTI that is larger than the default of zero, the user
requests CAMPARI to extend phase 3 to additional levels toward the root. The (virtual) root (single cluster)
and the level with the coarsest actual threshold are both excluded from this refinement. The output in output file
<a href="outputfiles.html#STRUCT_CLUSTERING.clu">STRUCT_CLUSTERING.clu</a> is adjusted to provide the correct number
of coarse-grained trajectory annotations. Other analyses, unless specified otherwise, are only performed for the leaf
level clustering (network). With appropriate settings for <a href="keywords.html#CRADIUS">CRADIUS</a>, <a href="keywords.html#CMAXRAD">CMAXRAD</a>,
and <a href="keywords.html#BIRCHHEIGHT">BIRCHHEIGHT</a>, BIRCHMULTI can be used to create
a high-quality multi-resolution clustering. The output in <a href="outputfiles.html#STRUCT_CLUSTERING.clu">STRUCT_CLUSTERING.clu</a>
can then be used to perform graph-based analyses for all resolutions by choosing <a href="keywords.html#CMODE">CMODE</a> to be 6 or 7
and relying on keywords <a href="keywords.html#CLUFILE">CLUFILE</a> and <a href="keywords.html#CLUFILECOL">CLUFILECOL</a>,
which is an efficient way of overcoming the aforementioned limitation.<br/>
<h4><a class="NoHi" id="BIRCHCHUNKSZ"><b>BIRCHCHUNKSZ</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), the tree-based
algorithm or the approximate progress index-based scheme is used (&rarr; <a href="keywords.html#CMODE">CMODE</a>),
and the <a href="keywords.html#NRTHREADS">multi-threaded executable</a> is in use, this keyword controls an important
aspect of the parallel clustering algorithm. To avoid load imbalance and scaling limitations, the first phase of
the algorithm can, optionally, employ a divide-and-merge strategy for the determination of clusters at tree levels
with few clusters overall. This divide-and-merge strategy can be enabled by choosing an integer value larger than 1 for this keyword
(the default is 1). As a result of the divide-and-merge approach, clustering results become dependent on the number
of threads in use. Only a setting of 1 guarantees that the clustering result will be the same as in single-threaded execution.<br/>
The precise role of this keyword is to set a threshold of <i>N<sub>s</sub></i>/BIRCHCHUNKSZ for coarse clusters (including
the tree's root, where all snapshots are in a single cluster) to enable the divide-and-merge approach. Here, <i>N<sub>s</sub></i>
is the total number of snapshots. Larger values will favor further divides and can improve load balance and scalability.
The merging procedure is of course associated with a cost itself. The amount of merging is tunable by the associated keyword
<a href="keywords.html#CMERGEDIAM">CMERGEDIAM</a>. This in itself is a viable approach to controlling the 
properties of the clustering at coarser levels (see <a href="keywords.html#BIRCHHEIGHT">BIRCHHEIGHT</a> for additional information).<br/>
<h4><a class="NoHi" id="CMERGEDIAM"><b>CMERGEDIAM</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), the tree-based
algorithm or the approximate progress index-based scheme is used (&rarr; <a href="keywords.html#CMODE">CMODE</a>),
and the <a href="keywords.html#NRTHREADS">multi-threaded executable</a> is in use, this keyword controls an important
aspect of the parallel clustering algorithm. To avoid load imbalance and scaling limitations, the first phase of
the algorithm can, optionally, employ a divide-and-merge strategy for the determination of clusters at tree levels
with few clusters overall. This divide-and-merge strategy is enabled by the associated keyword
<a href="keywords.html#BIRCHCHUNKSZ">BIRCHCHUNKSZ</a>. Applying the divide-and-merge approach implies that clustering results
become dependent on the number of threads in use.<br/>
The precise role of CMERGEDIAM is to define a leniency on a criterion for merging clusters in the divide-and-merge approach.
This is necessary because individual threads will likely have produced clusters with very substantial overlap.
A merging of a smaller into a larger cluster is accepted whenever two conditions hold. First, the centroid-to-centroid distance 
is required to be less than CMERGEDIAM times a data-derived mean cluster radius at the same tree level. Second, 
the normalized difference of joint radius and mean snapshot-to-snapshot distance must be less than CMERGEDIAM-1.0.
The default value of 1.0 therefore provides a stringent merging criterion. Smaller values make this even more stringent 
whereas larger values increase leniency. Note that only clusters part of a divide-and-merge block and being created
by different threads are considered for merging. This makes this functionality complimentary to 
<a href="keywords.html#CREFINE">refinement</a>, which operates at the leaf level.<br/>
<h4><a class="NoHi" id="CPROGINDMODE"><b>CPROGINDMODE</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), and the progress index-based
algorithm is used (&rarr; <a href="keywords.html#CMODE">CMODE</a>), this keyword allows the user to choose between the
exact (1) and the approximate scheme (2 = default). The two cases differ as follows:
<ol>
<li>In the exact scheme, CAMPARI attempts to construct the true minimum spanning tree (MST) for the trajectory of interest. This is
achieved by following the same setup procedure used in hierarchical clustering (described under option 3 to <a href="keywords.html#CMODE">CMODE</a>),
<i>i.e.</i>, a heuristics-based scheme is used to construct a neighbor list in snapshot space up to a certain
<a href="keywords.html#CCUTOFF">hard cutoff</a>. Alternatively, the neighbor list can be read from a <a href="keywords.html#NBLFILE">
dedicated input file</a>. From this list, a globally sorted list of near distances is constructed. This setup work provides the foundation
to construct the MST without additional parameters via <a href="references.html#ref23_8">Kruskal's algorithm </a>.
The high cost (both in terms of time and memory) makes the exact
scheme impractical for large data sets. Note that the neighbor list <b>must be sufficient</b> for the algorithm
to run. This means that all the edges for the MST have to occur in the neighbor list, which is unfortunately not guaranteed even
if each snapshot has multiple neighbors listed. Potential failures are therefore difficult to predict.
When using CAMPARI's <a href="keywords.html#NRTHREADS">threads parallelization</a>, the exact scheme is carried out by a single
thread alone. This limitation is in part due to the same reasons as the same limitation for hierarchical clustering: threads
parallelization does not solve the memory problem.</li>
<li>In the approximate scheme, CAMPARI utilizes a two-stage approach. The goal is to improve upon the large computational
cost associated with the exact scheme without sacrificing too much information encoded in the progress index. This is done by replacing
the calculation of the minimum spanning tree with an approximation, called a short spanning tree (SST). First, the trajectory data
are clustered using the highly efficient tree-based algorithm (described under option 5 to <a href="keywords.html#CMODE">CMODE</a>).
For clarity, the hierarchical tree of groups of snapshots (clusters) is not to be confused with the spanning tree we wish to generate. Because
the tree-based clustering is used, keywords <a href="keywords.html#CRADIUS">CRADIUS</a>, <a href="keywords.html#CMAXRAD">CMAXRAD</a>, and
<a href="keywords.html#BIRCHHEIGHT">BIRCHHEIGHT</a> are all relevant. The hierarchical tree is then used as follows. For every snapshot,
a fixed number (sometimes an upper limit) of guesses is made to find the shortest available distance to any other eligible snapshot. Rather than 
searching exhaustively among all snapshots (as would be required for the MST), we restrict the search to pairs of eligible snapshots belonging to
the same cluster at the finest possible level of the clustering tree. The shortest guess for every snapshot becomes a candidate
edge for the SST. At every one of the ~log<i>N</i> iterations a number of guesses are discarded because they would introduce cycles. The algorithm is continued
until the SST is complete. At any given stage, the eligible snapshots are those belonging to different subtrees of the SST.
The SST will be formed primarily by connections between snapshots in the same clusters at the finest level.
This procedure emulates <a href="references.html#ref23_6">Borůvka's algorithm</a> with a search space limited by the hierarchical
tree. Because the spanning tree thus constructed is not strictly minimal, it is important to update component memberships after
each merging operation.<br/>
The algorithm is dependent on two parameters. The first regulates the maximum number of search attempts used for
finding the next-nearest and eligible neighbor for any snapshot (the minimum across a spanning tree component then becomes
the candidate edge for that component). It is set by keyword <a href="keywords.html#CPROGINDRMAX">CPROGINDRMAX</a>. The respective clusters
at the finest level of the hierarchical tree offering any eligible candidate edges may not offer <a href="keywords.html#CPROGINDRMAX">CPROGINDRMAX</a>
guesses. In this case, the second parameter becomes relevant. It controls a depth as to how many additional levels of the hierarchical tree
to descend into in order to satisfy the maximum number of guesses. This second parameter is set by keyword
<a href="keywords.html#CPROGRDEPTH">CPROGRDEPTH</a>. There is a third parameter, <a href="keywords.html#CPROGRDBTSZ">CPROGRDBTSZ</a>,
which is a technical setting controlling how a cluster is searched randomly. This is only necessary if the number of eligible
candidates in a cluster exceeds the number of missing guesses requested by <a href="keywords.html#CPROGINDRMAX">CPROGINDRMAX</a>.
Then, <a href="keywords.html#CPROGRDBTSZ">CPROGRDBTSZ</a> can be used to reduce the number of required random numbers.
Depending on the settings, the algorithm is expected to run in approximately <i>N</i>log<i>N</i> time with the constant prefactor determined
by the clustering and the choice for <a href="keywords.html#CPROGINDRMAX">CPROGINDRMAX</a>. Similarly, the quality of the generated spanning tree
depends nontrivially on both aforementioned search parameters as well as on the properties of the tree-based clustering.
It is of course unlikely that the SST be in fact the true MST for trajectories
of appreciable length. By using appropriately large values for both <a href="keywords.html#CPROGINDRMAX">CPROGINDRMAX</a> and
<a href="keywords.html#CPROGRDEPTH">CPROGRDEPTH</a> one can create an asymptotic limit for recovering the true MST.
This limit can be of practical use even though a guaranteed MST computed this way requires at least O(<i>N</i><sup>2</sup>) time,
which is worse than the time complexity of the exact form (aided by safe heuristics). However, the space (memory) complexity
of this approach is much superior (linear rather than O(<i>N</i><sup>1.5</sup>) to O(<i>N</i><sup>2</sup>)).<br/>
The above description reveals some minor differences relative to the original <a href="references.html#ref23_5">published algorithm</a>.
The change associated with keyword <a href="keywords.html#CPROGRDBTSZ">CPROGRDBTSZ</a> is directly related to the
parallelization of the SST construction. When CAMPARI's <a href="keywords.html#NRTHREADS">thread-parallel version</a> is in use,
this operation offers excellent scaling properties, and limiting the number of required random numbers is beneficial for large numbers
of threads. Because threads access the random number generator in nondeterministic order, keyword <a href="keywords.html#RANDOMSEED">RANDOMSEED</a>
cannot be used to ensure that the SST in two successive executions is exactly identical for more than one thread. The second 
modification relative to the original publication is the straightforward generalization offered by keyword
<a href="keywords.html#CPROGRDEPTH">CPROGRDEPTH</a> (in essence, the previous algorithm implied this keyword to always be 0).</li>
</ol>
In both cases, the resultant (short or minimum) spanning tree is used to determine the progress index <i>per se</i>. This is achieved
using Jarník's (Prim's) algorithm on the spanning tree (note that a slightly different class of algorithms is used to construct it in the first
place) either with a starting vertex (snapshot) selected via <a href="keywords.html#CPROGINDSTART">CPROGINDSTART</a> or on
an automatically determined set of starting vertices. At this stage, keyword  <a href="keywords.html#CPROGMSTFOLD">CPROGMSTFOLD</a> may
become relevant. It allows preprocessing of the spanning tree to alter the edge lengths considered by Jarník's algorithm in a way that
incorporates leaf vertices before any other connected vertex. This is a feature not present in the
<a href="references.html#ref23_5">original publication</a> but that was used already in
<a href="references.html#ref23_18">this reference</a>. Application of Jarník's algorithm will usually require linear time.<br/>
<h4><a class="NoHi" id="CPROGINDSTART"><b>CPROGINDSTART</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), and the progress index-based
algorithm is used (&rarr; <a href="keywords.html#CMODE">CMODE</a>), this keyword allows the user to pick a specific snapshot
to serve as starting point for the generation of the progress index.
Because, like <a href="keywords.html#INISYNSNAP">INISYNSNAP</a>, the keyword uses a snapshot index,
it is important to point out that the value of this keyword must 
always be specified in absolute terms of the input data, <i>i.e.</i>, generally speaking, no corrections must be applied
in case <a href="keywords.html#CCOLLECT">CCOLLECT</a> is greater than 1, a sequential access
<a href="keywords.html#FRAMESFILE">file with user-selected input frames</a> is specified, 
or <a href="keywords.html#EQUIL">frames are discarded at the beginning</a> (this was different in previous versions). CAMPARI takes care of
this automatically. The use of a frames file requires particular care. If the file accesses the trajectory in random access ("as is") mode,
the snapshot index is assumed to refer to the line number in the frames file rather than the index of the frame on that line. This is 
a general change of interpretation inherent to <a href="keywords.html#FRAMESFILE">FMCSC_FRAMESFILE</a> with certain 
<a href="keywords.html#PDB_FORMAT">input file formats</a>. Conversely, if the file accesses the trajectory in strictly sequential
mode, step numbers continue to refer to the <i>original</i> trajectory.<br/>
As a special option, specifying zero instructs CAMPARI to find a set of suitable starting snapshots. These are generally
found by generating a sample profile (discussed <a href="outputfiles.html#PROGIDX_xxxxxxxxxxxx.dat">elsewhere</a>) that 
is then scanned for extrema using an automated detection system that can be tuned with two additional keywords,
<a href="keywords.html#CBASINMAX">CBASINMAX</a> and <a href="keywords.html#CBASINMIN">CBASINMIN</a>. The idea behind
this is to generate profiles starting from a complete set of putative basins. If this automatic detection is 
unsuccessful, CAMPARI will revert to using the first snapshot as a starting point.<br/>
As a further option that is only available in the approximate scheme (&rarr; <a href="keywords.html#CPROGINDMODE">CPROGINDMODE</a>),
a specified value of "-1" instructs CAMPARI to use as starting snapshot the central snapshot of the largest cluster
found during the preparatory tree-based clustering. The default options are -1 in the approximate scheme and 0 in the
exact scheme.<br/>
<h4><a class="NoHi" id="CPROGMSTFOLD"><b>CPROGMSTFOLD</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), and the progress index-based
algorithm is used (&rarr; <a href="keywords.html#CMODE">CMODE</a>), this keyword allows the user to modify the 
spanning tree underlying the progress index before the index is computed. The modification consists of "folding" or 
collapsing the leaves into their parent vertex, which means that they are added first as soon as the index encounters
the parent in question. By specifying a positive integer, the user requests CPROGMSTFOLD applications of this inward folding
procedure (each of which scales linearly with the number of snapshots in terms of computational cost).
After each iteration, the identity of vertices
as leaf vertices is updated, which means that branches are continuously folded inward. Note that already a single
iteration will fold a large number of edges (the actual number is reported to log output). For multiple folded vertices
connected to the same parent CAMPARI preserves the expected order (shortest distance first).<br/>
The reasoning behind this modification is the following. When operating on the (minimum) spanning tree, Prim's algorithm
proceeds by always finding the shortest distance available. As long as basins are sampled densely and transitions are rare,
this has the desired effect of arranging snapshots in a way that allows identification of basins by suitable annotation.
However, it is common for basins to have "fringe" regions where sampling density becomes low (and distances are large).
Points in these regions will often be missed by the progress index and placed at the end (far away from "their" parent basin). 
Points in these regions are also likely to correspond to leaf vertices in the spanning tree. Therefore, it can be 
assumed that collapsing them into their parent will partially ameliorate this issue (they will occur in the correct basin).
Users should keep in mind that this alters the rule that the progress index is built to track local density as much as possible.<br/>
<h4><a class="NoHi" id="CPROGRDEPTH"><b>CPROGRDEPTH</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), and the approximate progress index-based
algorithm is used (&rarr; <a href="keywords.html#CMODE">CMODE</a> and <a href="keywords.html#CPROGINDMODE">CPROGINDMODE</a>),
this keyword allows the user to control the maximum search depth for random guesses. In this method, a hierarchical tree
is used in conjunction with a parameter, <a href="keywords.html#CPROGINDRMAX">CPROGINDRMAX</a>, to restrict the search space for
finding edges of a short spanning tree. The hierarchical tree is based on the tree-based clustering algorithm, and its height
is set by keyword <a href="keywords.html#BIRCHHEIGHT">BIRCHHEIGHT</a>. For each snapshot, the algorithm will start searching for putative edges 
within the cluster the snapshot is part of at the finest level offering any eligible candidates. Often, the number of candidates
is smaller than the setting for <a href="keywords.html#CPROGINDRMAX">CPROGINDRMAX</a>. Then, CAMPARI will descend the 
hierarchical tree toward the root by at most CPROGRDEPTH levels to fulfill the requested number of guesses per snapshot. 
The reason for offering this restriction is that the search at additional levels is often inefficient. This is because 
it introduces additional redundancy (the same candidates are evaluated more than once), and the candidates at a coarser-than-necessary
level are unlikely to be better guesses than the ones at the finest available level. The default for CPROGRDEPTH is zero.
Note that, with a meaningful clustering in place, the default setting will prevent the spanning tree from approaching the correct
minimum spanning tree in almost all cases. This is because of the hard search space restrictions. At considerable cost,
this keyword can overcome the impact of these restrictions.<br/>
<h4><a class="NoHi" id="CBASINMAX"><b>CBASINMAX</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), the progress index-based
algorithm is used (&rarr; <a href="keywords.html#CMODE">CMODE</a>), and an automatic determination of multiple
starting snapshots for profiles is requested (&rarr; <a href="keywords.html#CPROGINDSTART">CPROGINDSTART</a>), this 
keyword controls how a test profile using the standard annotation function described
<a href="outputfiles.html#PROGIDX_xxxxxxxxxxxx.dat">elsewhere</a> is parsed to automatically identify minima in
this function. Specifically, around each eligible point in the profile, environments of varying sizes are considered, and the following
criteria are used:<br/>
<ul>
<li>The sum of values to the left over a stretch of <i>n<sub>e</sub></i> points must be greater than the
sum of values over a stretch of <i>n<sub>e</sub></i> points centered at the point currently considered.</li>
<li>The sum of values to the right over a stretch of <i>n<sub>e</sub></i> points must be greater than the
sum of values over a stretch of <i>n<sub>e</sub></i> points centered at the point currently considered.</li>
<li>The sum of values to the left and right over a stretch of <i>n<sub>e</sub></i> points each must be greater than a
reference sum that is given as twice the sum of values over a stretch of <i>n<sub>e</sub></i> points centered at the point currently considered
plus 4<i>n<sub>e</sub></i>.</li>
<li>The left (far) half of the sum of values to the left over a stretch of <i>n<sub>e</sub></i> points must be greater than the
right (near) one.</li>
<li>The right (far) half of the sum of values to the right over a stretch of <i>n<sub>e</sub></i> points must be greater than the
left (near) one.</li>
<li>No point toward the left over a stretch of <i>n<sub>e</sub></i> points must be greater than or equal to the point
currently considered.</li>
<li>No point toward the right over a stretch of <i>n<sub>e</sub></i> points must be greater than the point
currently considered.</li>
</ul>
CBASINMAX controls the maximum value considered for <i>n<sub>e</sub></i> in the above rules.
<br/>
<h4><a class="NoHi" id="CBASINMIN"><b>CBASINMIN</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), the progress index-based
algorithm is used (&rarr; <a href="keywords.html#CMODE">CMODE</a>), and an automatic determination of multiple
starting snapshots for profiles is requested (&rarr; <a href="keywords.html#CPROGINDSTART">CPROGINDSTART</a>), this
keyword controls the minimum value considered for <i>n<sub>e</sub></i> as explained in the documentation
of keyword <a href="keywords.html#CBASINMAX">CBASINMAX</a>.
<br/>
<h4><a class="NoHi" id="CPROGINDRMAX"><b>CPROGINDRMAX</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), the progress index-based
algorithm is used (&rarr; <a href="keywords.html#CMODE">CMODE</a>), and the approximate version is chosen 
(&rarr; <a href="keywords.html#CPROGINDMODE">CPROGINDMODE</a>), this keyword controls the maximum number of attempts for a
search of the next correct spanning tree neighbor of a growing spanning tree component. 
Depending on the choice for keyword <a href="keywords.html#CPROGRDEPTH">CPROGRDEPTH</a>, such a search first exhausts the
possibilities within a given cluster of the hierarchical tree underlying the approximate algorithm and will only consider
a limited amount of clusters at coarser-than-necessary levels. Therefore, the parameter is interpreted as  
a maximum and not generally an actual value. Whenever the number of eligible candidate snapshots in a cluster is less
than the missing amount of guesses for the snapshot in question, the search becomes deterministic. Otherwise, it is random
(with replacement). In both cases, the eligible snapshot with the minimum distance to the
spanning tree component under consideration is becomes a candidate for the next link of the approximate MST.
If CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use, the choice for this
keyword affects parallel performance at most weakly. This is because the parallelization is at the level of snapshots
and not at the level of guesses.<br/>
<h4><a class="NoHi" id="CPROGRDBTSZ"><b>CPROGRDBTSZ</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), the progress index-based
algorithm is used (&rarr; <a href="keywords.html#CMODE">CMODE</a>), and the approximate version is chosen 
(&rarr; <a href="keywords.html#CPROGINDMODE">CPROGINDMODE</a>), this keyword controls the structure of the random
search in a cluster with a number of eligible candidates that exceeds the remaining number of
<a href="keywords.html#CPROGINDRMAX">required guesses</a> for all but the first stage of
<a href="references.html#ref23_6">Borůvka's algorithm</a>. The default is 1 meaning that every single random guess requires a random number.
Values larger than 1 imply that the random search proceeds in systematic stretches of length
CPROGRDBTSZ in the contiguous stretch of eligible candidates starting from a member selected with uniform probability. 
The specified value is an upper limit, <i>i.e.</i>, the number of guesses is never exceeded. Use in the first
stage is forbidden so as to avoid bias from the input order, which can still be present in the list of snapshots
constituting a cluster. In later stages, cluster snapshot lists have been reordered by subtree memberships, and
systematic biases become increasingly unlikely. The keyword is relevant primarily if CAMPARI's
<a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> is in use. In this scenario,
the cost of random number production can become significant relative to distance evaluations because the individual
threads share the same random number generator (which leads to minor waiting times).
Consequently, if the cost of the distance evaluations is high
to begin with (dependent on <a href="keywords.html#CDISTANCE">features and metric</a>), the default should not be changed.
<br/>
<h4><a class="NoHi" id="CPROGINDWIDTH"><b>CPROGINDWIDTH</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), and the progress index-based
algorithm is used (&rarr; <a href="keywords.html#CMODE">CMODE</a>), this keyword controls the auxiliary annotation function
defined <a href="outputfiles.html#PROGIDX_xxxxxxxxxxxx.dat">elsewhere</a>. Specifically, it corresponds to the parameter
<i>l<sub>p</sub></i> in the documentation found by following the link.
<br/>
<!-- ************************************************************************************************* -->
<!-- **************************************** TMAT_MD ************************************************ -->
<h4><a class="NoHi" id="TMAT_MD"><b>TMAT_MD</b></a></h4>
This important keyword lets the user set the time direction(s) for the inferred transition matrix to be used in all related analyses, 
which may be iterative solutions of the steady state (see <a href="keywords.html#CREWEIGHT">CREWEIGHT</a>), mean first passage times 
(see <a href="keywords.html#CMSMCFEP">CMSMCFEP</a>), the generation of synthetic trajectories (or random walks, see <a href="keywords.html#SYNTRAJ_MD">SYNTRAJ_MD</a>) 
and/or, if the code was compiled and linked with HSL support (→ <a href="install.html">installation instructions</a>), 
the achievement of committor probabilities (<a href="keywords.html#DOPFOLD">DOPFOLD</a> and <a href="keywords.html#CMSMCFEP">CMSMCFEP</a>) 
and/or the computation of the spectral properties of the transition matrix itself (<a href="keywords.html#EIGVAL_MD">EIGVAL_MD</a>). 
For the present keyword and related analyses to have an effect, a clustering analysis must be performed (see <a href="keywords.html#CCOLLECT">CCOLLECT</a> 
and <a href="keywords.html#CMODE">CMODE</a>). In case  <a href="keywords.html#CMODE">CMODE</a> is set to 4, the approximated 
version of the progress index algorithm must be used (<a href="keywords.html#CPROGINDMODE">CPROGINDMODE</a> set to 2). In this case, or if <a href="keywords.html#CMODE">CMODE</a> 
is set to 5, the underlying state space used for the evaluation of the matrix is always the one at the leaf level (&rarr; <a href="keywords.html#BIRCHHEIGHT">BIRCHHEIGHT</a>).<br/>
In general, the analysis of transition matrix-derived properties will be done exclusively for those states that form the reference strongly connected 
component, which is identified by the cluster selected with the keyword <a href="keywords.html#INISYNSNAP">INISYNSNAP</a>. Some algorithms may provide
solutions for all eligible components individually (see <a href="keywords.html#INISYNSNAP">INISYNSNAP</a>). Results of all analyses that explicitly reference user-selected
snapshots (<i>e.g.</i> <a href="keywords.html#DOPFOLD">committor probabilities</a> for <a href="keywords.html#CLUFOLDFILE">folded</a> and <a href="keywords.html#CLUUNFOLDFILE">unfolded</a> sets)
are obtained over this reference strongly connected component only. 
The reference component is isolated from all the other ones (if any) by removing all the one-way transitions.
The transition matrices can be requested to be written to file with the specialized keyword <a href="keywords.html#TMATREPORT">TMATREPORT</a>.
For the present keyword, the relevant options are:
<ol>
<li>Only data derived from one transition matrix are calculated, <i>i.e.</i>, the one that uses the forward-time transitions between the clusters of the reference component (default). 
In the simplest scenario - <i>viz.</i> <a href="keywords.html#CLAGT_MSM">CLAGT_MSM</a> set to 1, no <a href="keywords.html#TRAJBREAKSFILE">breaks</a>, 
no <a href="keywords.html#TRAJLINKSFILE">links</a> and no <a href="keywords.html#TRACEFILE">trace</a> 
files specified - these transitions are simply reflected in the output file <a href="outputfiles.html#STRUCT_CLUSTERING.clu">STRUCT_CLUSTERING.clu</a> 
when processed line by line from top to bottom.</li>
<li>Only data derived from one transition matrix are calculated, <i>i.e.</i>, the one that uses the backward-time transitions between the clusters. <a href="keywords.html#TRAJBREAKSFILE">Breaks</a> 
and <a href="keywords.html#TRAJLINKSFILE">links</a> are interpreted by reversing the time-information in the relevant input files. 
Similar to option 1, in the simplest situation, the transitions for this case are reflected in the <a href="outputfiles.html#STRUCT_CLUSTERING.clu">STRUCT_CLUSTERING.clu</a> 
output file when processed line by line from bottom to top.</li>
<li>Both types of transition matrices (<i>i.e.</i> forward and backward time) are constructed and most subsequent analyses 
are performed twice, once per type of transition matrix.</li>
</ol>
A transition matrix is probably the most common mathematical representation of a transition network and is - here a 
right - stochastic matrix (most likely sparse) that ultimately models the jumps between the states of the transition 
network, or Markov State Model (MSM). MSMs have recently become an important tool for the analysis of MD data, and for 
the details of this technique we refer the reader to the literature (<a href="references.html#ref23_19">Prinz <i>et al.</i></a>). Briefly, a 
single entry <i>t<sub>ij</sub>(&tau;)</i> of the matrix is referred to as a "transition probability" as it reflects the (conditional) probability that the associated 
stochastic process (Markov Chain) jumps from state <i>i</i> to state <i>j</i> within <a href="keywords.html#CLAGT_MSM">a time window or lag time &tau;</a>
and given that the chain is valued in state <i>i</i> initially. The mathematical definition used in CAMPARI to infer <i>t(&tau;)<sub>ij</sub></i> is simply: 
t<sub>ij</sub>(&tau;) = n<sub>ij</sub>(&tau;) / &Sigma;<sub>j=1</sub><sup>N<sub>clu</sub></sup> n<sub>ij</sub>(&tau;), where n<sub>ij</sub>(&tau;) 
is the number of transitions from node <i>i</i> to <i>j</i> evaluated at a time distance equal to &tau;
along the coarse-grained trajectory <a href="outputfiles.html#STRUCT_CLUSTERING.clu">STRUCT_CLUSTERING.clu</a>, and N<sub>clu</sub> 
is the number of nodes. This means that the transition matrix that CAMPARI evaluates is always, and exclusively, the maximum-likelihood estimate.
At the level of states (clusters), the maximum likelihood structure of the transition matrix can be altered by keyword
 <a href="keywords.html#CADDLINKMODE">CADDLINKMODE</a>, for example to impose detailed balance.<br/>
Since the basic inference of the transition matrix is based on the count matrix, the initial estimate depends on the assumptions
of snapshot-to-snapshot connectivity in the input trajectory. The default assumption (subsequent snapshots are connected in time)
can be altered by several keywords. The general time spacing (lag time) can be changed with keyword <a href="keywords.html#CLAGT_MSM">CLAGT_MSM</a>.
Custom links and breaks can be added with specific input files 
<a href="keywords.html#TRAJBREAKSFILE">TRAJBREAKSFILE</a> and <a href="keywords.html#TRAJLINKSFILE">TRAJLINKSFILE</a>. In addition, a special automatic 
handling of rerouted transitions is offered in case the input trajectory has been generated using the <a href="keywords.html#MPI_PIGS">PIGS protocol</a>
and the associated <a href="keywords.html#TRACEFILE">trace file</a> is provided as input. Importantly, these snapshot-based modifications
can be handled and analyzed by CAMPARI at the beginning of the run. Obviously, all changes to the transition matrix impact 
all the routines that use it subsequently. Keyword <a href="keywords.html#BRKLNKREPORT">BRKLNKREPORT</a> can be used to
instruct CAMPARI to print a summary of rerouted (or all) snapshot transitions.<br/>
<!-- ************************************************************************************************* -->
<!-- **************************************** FMCSC_TMATREPORT *************************************** -->
<h4><a class="NoHi" id="TMATREPORT"><b>TMATREPORT</b></a></h4>
This keyword is interpreted as a simple logical.  When set to 1, it asks CAMPARI to write one or more files (see 
<a href="outputfiles.html#TMAT_xxxxxx_yyy.dat">TMAT_xxxxxx_yyy.dat</a> for details on formatting)
the non-zero entries of the processed transition matrix(ces) (see <a href="keywords.html#TMAT_MD">TMAT_MD</a>).
For this option to be available, structural clustering analysis must be performed (see <a href="keywords.html#CCOLLECT">CCOLLECT</a> 
and <a href="keywords.html#CMODE">CMODE</a>). If any method is used that relies on keyword 
<a href="keywords.html#INISYNSNAP">INISYNSNAP</a>, which includes 
<a href="keywords.html#SYNTRAJ_MD">synthetic trajectories</a>, 
<a href="keywords.html#EIGVAL_MD">spectral decomposition</a>, and <a href="keywords.html#DOPFOLD">committor probabilities</a>, 
this snapshot will be used to identify the strongly connected component, for which the file(s) are written.<br/>
<!-- ************************************************************************************************* -->
<!-- ********************************** CLAGT_MSM **************************************************** -->
<h4><a class="NoHi" id="CLAGT_MSM"><b>CLAGT_MSM</b></a></h4>
This integer value specifies the lag time &tau; to be used to compute the transition matrix for any relevant analysis
based on a network (graph, Markov state model) derived from a <a href="keywords.html#CCOLLECT">structural clustering</a>, <i>e.g.</i>,
 <a href="keywords.html#SYNTRAJ_MD">SYNTRAJ_MD</a>, 
<a href="keywords.html#EIGVAL_MD">EIGVAL_MD</a> and <a href="keywords.html#DOPFOLD">DOPFOLD</a>. 
Setting its value to any number greater than 1 (default) entails superimposing all the transition counts between clusters as derived
at fixed time distance &tau; along the coarse-grained trajectory (<a href="outputfiles.html#STRUCT_CLUSTERING.clu">STRUCT_CLUSTERING.clu</a>), 
an approach that is often called "sliding window" in the <a href="references.html#ref23_19">relevant literature</a>
This way, there are as many superposition steps as the integer value of the lag time. CLAGT_MSM strictly refers to
the spacing (in number of frames) of the data actually stored for clustering, which depend on <a href="keywords.html#EQUIL">EQUIL</a>,
 <a href="keywords.html#CCOLLECT">CCOLLECT</a>, and, possibly, <a href="keywords.html#FRAMESFILE">an input file with user-selected frames</a>.
The actual distance in units of time that CLAGT_MSM corresponds to has to be computed by considering the actual spacing
of the underlying data set (<i>e.g.</i>, for a CAMPARI molecular dynamics trajectory, this would have been controlled by <a href="keywords.html#TIMESTEP">TIMESTEP</a>
and <a href="keywords.html#XYZOUT">XYZOUT</a>). Because CLAGT_MSM ultimately edits the way snapshots (frames) of the
input trajectory are linked together, it is also relevant for the output of the <a href="keywords.html#CPROGINDMODE">progress index method</a>
(see output file <a href="outputfiles.html#PROGIDX_xxxxxxxxxxxx.dat">PROGIDX_000000000001.dat</a>).<br/>
The sliding window mode of operation will automatically propagate modifications to the connectivity introduced by input files 
<a href="keywords.html#TRAJBREAKSFILE">TRAJBREAKSFILE</a> and <a href="keywords.html#TRACEFILE">TRACEFILE</a>.
Conversely, any <a href="keywords.html#TRAJLINKSFILE">manually added links</a> are always kept "as is."
If the user is interested in processing all the trajectories that are superimposed this way as separate
entities, it is necessary to prepare as many dedicated input <a href="keywords.html#FRAMESFILE">frames files</a>
as the integer value of the lag time and to perform a separate analysis for each of them. 
It is worth pointing out that the independent clustering on each input <a href="keywords.html#FRAMESFILE">frames file</a> 
may introduce some inconsistencies in this workaround.<br/>
<h4><a class="NoHi" id="CADDLINKMODE"><b>CADDLINKMODE</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), this keyword allows the user
to request different modifications of the link (edge) structure of the derived network (graph). This is unavailable
if the <a href="keywords.html#CPROGINDMODE">exact progress index method</a> has been selected. Modifying the link structure can be useful 
because the transition counts usually suffer from poor statistics for many if not most links. This can cause problems, <i>e.g.,</i>
by splitting the graph into several strongly connected components or by creating dramatic sensitivities of network-derived
properties (such as the steady state) on very few elements of the transition matrix. For small values of chosen
<a href="keywords.html#CLAGT_MSM">lag times</a>, networks are assumed to be locally connected only (sparse). While this
potentially reduces the impact of statistical errors, a large number of subsequent analyses (whether in CAMPARI or elsewhere)
unfortunately assume a memory-less evolution, which is difficult to fulfill. Conversely, for large values of chosen
<a href="keywords.html#CLAGT_MSM">lag times</a>, the memory-free nature of the dynamics may become appropriate, but
the number of relevant transition matrix elements grows dramatically while the counts available for inference decrease 
considerably.<br/>
These joint concerns mean that it is unfortunately not at all simple to identify the optimal transition matrix based on counts.
The available options are meant to deal with this problem as follows:<br/>
<ol start="0">
<li>The network is left as is, <i>i.e.</i>, all transition matrices will be inferred directly from the observed
transition counts. This is the statistically optimal estimator if the system is truly Markovian. It can lead to fractured
graphs, which introduce arbitrary probability relationships between subgraphs.</li>
<li>Strongly connected components are identified using Tarjan's algorithm. They can result from supplying a 
<a href="keywords.html#TRAJBREAKSFILE">file with trajectory breaks</a> or a <a href="keywords.html#TRACEFILE">trace file</a>
for an <a href="keywords.html#MPI_PIGS">MPI PIGS</a> calculation. Any one-way links between different components
are augmented with the reverse transition. The floating point weight for this reverse link is set by keyword 
<a href="keywords.html#CLINKWEIGHT">CLINKWEIGHT</a>. If there is no link in either direction, multiple components 
will remain as in option 0.</li>
<li>Any clusters (vertices) without any observed self-transitions (self-loops) are augmented with a self-transition
with a floating point weight of <a href="keywords.html#CLINKWEIGHT">CLINKWEIGHT</a>. In a Markov model sense, this will increase
residence times and populations for the augmented nodes. It also removes deterministic chains of singleton clusters, which
often occur in high resolution networks in fringe regions (regions of low sampling density).</li>
<li>This is a combination of options 1 and 2.</li>
<li>The count matrix is symmetrized. If one of the two corresponding elements is zero, this creates a new reverse link with the
same properties as the existing forward one. If both directions are already populated, this means that the transition with
a lower number of observed counts is augmented to match the exact count number of the more populated one. This option ignores
keyword <a href="keywords.html#CLINKWEIGHT">CLINKWEIGHT</a>. This is different from symmetrization achieved by adding the entire
transition count matrix obtained from the same trajectory reversed in time. Both variants imply detailed balance. Again,
if no link exists in either direction, nothing is done, and multiple strongly connected components may persist as in option 1.</li>
<li>This is a combination of options 2 and 4.</li>
<li>Symmetrization of the count matrix is a crude way to impose detailed balance. In particular, it is almost certainly 
suboptimal in a statistical likelihood sense. If we assume the likelihood of the inferred transition matrix as
&Pi;<sub>i,j</sub>T<sub>ij</sub><sup>c<sub>ij</sub></sup>, where c<sub>ij</sub> is the number of observed counts for the 
transition from i to j, and T<sub>ij</sub> is the inferred transition matrix element, then it is possible to solve a constrained
problem that maximizes this likelihood while maintaining row normalization and detailed balance as constraints on the T<sub>ij</sub>.
It is important that the particular form of the likelihood function is a strong imposition, <i>i.e.</i>, the transition
counts are assumed independent, which is equivalent to asserting Markovianity. Markovianity is a very challenging 
property to achieve with sufficient accuracy (in the sense of a true statistical test). This means that in many applications
the resultant transition matrix does not actually maximize a meaningful quantity. This holds as much for the non-augmented
inference (option 0) as for this option, which includes the added constraint of maintaining detailed balance. 
<a href="references.html#ref23_22">Bowman <i>et al.</i></a> derived an iterative estimator solving this constrained problem. This estimator was subsequently 
simplified by <a href="references.html#ref23_19">Prinz <i>et al.</i></a>, and their version, which works on the log-likelihood
as usual, is implemented in CAMPARI. Also with this method, links with weight zero in both directions will remain empty, which
again means that multiple strongly connected components may persist. This iterative algorithm benefits from CAMPARI's
<a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a> and is under <a href="keywords.html#MAXTIME_ITERS">time control</a>
(the procedure can be slow).
Parallelization is such that the results should always be identical to serial execution.</li>
</ol>
None of the above options destroys an existing link. However, on occasion it may also be desirable to split different strongly
coupled components completely (rather than linking them). This implies that most subsequent analyses are restricted to the 
reference component (see keyword <a href="keywords.html#INISYNSNAP">INISYNSNAP</a> below). Consequently, CAMPARI offers the 
following compatibility options:<br/>
<ol>
<li value="-1">All links connecting different strongly coupled components are removed completely. This can create separate
graphs (networks).</li> 
<li value="-2">This is currently redundant (it is exactly the same as option 2 above).</li>
<li value="-3">This is the same as option 3 above only that all links connecting different strongly coupled components
are removed completely (this does not affect self-transitions).</li>
graphs (networks).</li> 
<li value="-4">This is the same as option 4 above only all links connecting different strongly coupled components are removed
before imbalanced transitions are symmetrized. This removal creates symmetry and will thus leave the components 
separate.</li> 
<li value="-5">This is the same as option 5 above only all links connecting different strongly coupled components are removed
before imbalanced transitions are symmetrized (this does not affect self-transitions).</li> 
<li value="-6">This is the same as option 6 above only all links connecting different strongly coupled components are removed
before the iterative procedure is performed on the individual networks.</li> 
</ol>
Note that some properties reported in output file <a href="outputfiles.html#STRUCT_CLUSTERING.graphml">STRUCT_CLUSTERING.graphml</a>
will be inferred for added links. In particular, the reported mean square displacement values are copied (minimally required
reverse transitions in options 1 and 3), set to half the value of <a href="keywords.html#CRADIUS">CRADIUS</a> squared
(self transitions in options 2, 3, and 5), or constructed as a weighted average (reverse transitions in option 4 and 5).
Most importantly, any substantial change to the link structure means that the network-derived equilibrium distribution
(steady state) is altered. It therefore recommended to use <a href="keywords.html#CREWEIGHT">CREWEIGHT</a> in
conjunction with this keyword. This ensures that information about the updated steady state is contained in output files
such as <a href="outputfiles.html#STRUCT_CLUSTERING.graphml">STRUCT_CLUSTERING.graphml</a> or
<a href="outputfiles.html#MFPT_yyy_CFEP_xxxxxxxx.dat">MFPT_yyy_CFEP_xxxxxxxx.dat</a>, <i>etc.</i>. Because these links are at the state network
level, CADDLINKMODE has no influence on the results of the  <a href="keywords.html#CPROGINDMODE">progress index</a> method.<br/>
<h4><a class="NoHi" id="CLINKWEIGHT"><b>CLINKWEIGHT</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), and the addition of
links (edges) to the derived network (graph) is requested (&rarr; <a href="keywords.html#CADDLINKMODE">CADDLINKMODE</a>),
this keyword sets the floating-point weight for some of the added links (see <a href="keywords.html#CADDLINKMODE">above</a>
for details). Note that the basic unit is an (integer) count of observed transitions in the input trajectory. The default
is therefore 1.0.<br/>
<h4><a class="NoHi" id="TRAJBREAKSFILE"><b>TRAJBREAKSFILE</b></a></h4>
If any type of structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), or if the exact progress index-based
algorithm is used (&rarr; <a href="keywords.html#CMODE">CMODE</a>), the resultant trajectory is used to infer the properties of a network.
Essentially, the sequence of events
in the trajectory defines a transition matrix. However, not all transitions in a trajectory may be equally valid, as they may be caused by 
trajectory concatenation (<i>e.g.</i>, when using structural clustering with the <a href="keywords.html#MPIAVG">MPI averaging technique</a>,
by <a href="keywords.html#REMC">replica exchange</a> swaps, by <a href="keywords.html#movesetcontrols">nonlocal Monte Carlo moves</a> and so on).
It may therefore be appropriate to remove such spurious transitions from the analysis in order to keep inferences regarding the underlying
dynamics accurate. This is what this file accomplishes, and the input and its interpretation are described in detail
<a href="inputfiles.html#FMCSC_TRAJBREAKSFILE">elsewhere</a>.<br/>
The removal of links is relevant for a number of output files, most obviously in <a href="outputfiles.html#STRUCT_CLUSTERING.graphml">STRUCT_CLUSTERING.graphml</a>
and <a href="outputfiles.html#TMAT_xxxxxx_yyy.dat">TMAT_xxxxxx_yyy.dat</a> (the mesostate (cluster) network and implied transition matrix).
All output files that depend on the transition matrix (&rarr; <a href="keywords.html#TMAT_MD">TMAT_MD</a>) and
the <a href="outputfiles.html#PROGIDX_xxxxxxxxxxxx.dat">output of the progress index method</a> are affected as well.
There are two additional notes. First, CAMPARI will not remove any transitions by default,
and it may sometimes be difficult to obtain or preserve the required information (<i>e.g.</i>, the <a href="outputfiles.html#FMCSC_RETRACE">replica exchange
trace file</a> must be used to extract the exact history of accepted swaps). Second, there is no guarantee that the graph remains intact (it may
fracture into multiple, disconnected subgraphs), and this may impact the interpretability of the data in the aforementioned output files.
Conversely, the native processing of a
PIGS trace via keyword <a href="keywords.html#TRACEFILE">TRACEFILE</a> is both more convenient and more universally supported.<br/> 
<h4><a class="NoHi" id="TRAJLINKSFILE"><b>TRAJLINKSFILE</b></a></h4>
If any type of structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), or if the exact progress index-based
algorithm is used (&rarr; <a href="keywords.html#CMODE">CMODE</a>), the resultant trajectory is used to infer the properties of a network.
Essentially, the sequence of events
in the trajectory defines a transition matrix. However, trajectory concatenation may give rise to scenarios where some links 
are spurious (&rarr; <a href="keywords.html#TRAJBREAKSFILE">TRAJBREAKSFILE</a>) and others are missing, <i>e.g.</i>, if
multiple trajectories are branched off from a common starting point and simply appended for analysis purposes. 
This keyword can be used to add such missing links at the snapshot (frame) level. This function can overlap with
keyword <a href="keywords.html#CADDLINKMODE">CADDLINKMODE</a>, which operates at the cluster level. It also overlaps
with the use of keyword <a href="keywords.html#TRACEFILE">TRACEFILE</a> for managing the reseeding operations
of a <a href="keywords.html#MPI_PIGS">PIGS</a> calculation, which is a type of simulation yielding such a set of branched
trajectories. The input format is described in detail <a href="inputfiles.html#FMCSC_TRAJLINKSFILE">elsewhere</a>.<br/>
The addition of links is relevant for a number of output files, most obviously in <a href="outputfiles.html#STRUCT_CLUSTERING.graphml">STRUCT_CLUSTERING.graphml</a>
and <a href="outputfiles.html#TMAT_xxxxxx_yyy.dat">TMAT_xxxxxx_yyy.dat</a> (the mesostate (cluster) network and implied transition matrix).
All output files that depend on the transition matrix (&rarr; <a href="keywords.html#TMAT_MD">TMAT_MD</a>) and
the <a href="outputfiles.html#PROGIDX_xxxxxxxxxxxx.dat">output of the progress index method</a> are affected as well.
We emphasize that considerable care is required to manage the links in a conformational space network through 
keywords (TRAJLINKSFILE, <a href="keywords.html#TRAJBREAKSFILE">TRAJBREAKSFILE</a>,
<a href="keywords.html#CADDLINKMODE">CADDLINKMODE</a>, <a href="keywords.html#TRACEFILE">TRACEFILE</a>, and
<a href="keywords.html#CLAGT_MSM">CLAGT_MSM</a>).
This is mostly due to the fact that data generation and post-processing (necessarily) are usually separate operations, 
which makes it difficult to achieve a compromise between controllability and ease of use.<br/>
<h4><a class="NoHi" id="BRKLNKREPORT"><b>BRKLNKREPORT</b></a></h4>
This is a simple keyword that allows the user to request information on the snapshot-to-snapshot connectivity map
CAMPARI assumes for all network-based analyses (&rarr; <a href="keywords.html#TMAT_MD">TMAT_MD</a> and
the <a href="outputfiles.html#PROGIDX_xxxxxxxxxxxx.dat">output of the progress index method</a>). Options are as follows:<br/>
<ol start="0">
<li>No report is printed.</li>
<li>Rerouted snapshot-to-snapshot links with a step spacing that is different from the requested <a href="keywords.html#CLAGT_MSM">lag time</a>
are printed to log-output at the beginning of the run (before any data are read). Indexing both relative to the stored data and relative to
the original input is provided (the latter depends on <a href="keywords.html#CCOLLECT">CCOLLECT</a> and <a href="keywords.html#EQUIL">EQUIL</a> and,
possibly, the presence of a <a href="keywords.html#FRAMESFILE">file with user-selected frames</a>). During post-processing, for the same
links, the geometric distance for the two snapshots in question is printed as well.</li>
<li>This is the same as the previous option only that all links are printed.</li>
</ol>
The main purpose of this keyword to allow the user an additional level of control that any rerouting of the snapshot connectivity
by means of <a href="keywords.html#TRAJBREAKSFILE">custom breaks</a>, <a href="keywords.html#TRAJLINKSFILE">custom links</a>, and
a possible <a href="keywords.html#TRACEFILE">trace file</a> is correct. The information being printed refers to the
<a href="keywords.html#TMAT_MD">forward time</a> setting and the map is simply reversed (columns switched) for the backward time case.
BRKLNKREPORT does not report on other link modifications, <i>e.g.</i>, by <a href="keywords.html#CADDLINKMODE">CADDLINKMODE</a>.<br/>
<h4><a class="NoHi" id="CREWEIGHT"><b>CREWEIGHT</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), which includes the case of 
the approximate progress index method, the resultant coarse-grained trajectory serves to define a network (graph) of clusters
(vertices). If the original trajectory carries strong initial state (but no energetic) bias (for example, if it is a concatenation of many
short trajectories), it may be of interest to attempt to quantify the bias in the data. This is what this keyword is meant for,
and it currently supports the following options:<br/>
<ol start="0">
<li>No network-based reweighting is undertaken.</li>
<li>The steady state (equilibrium probability distribution) of the underlying (and assumed!) Markov state model is computed using an iterative algorithm.
As alluded to, the resultant graph may not be strongly connected or even fractured. Any modification to the link (edge) structure of
the network (&rarr; <a href="keywords.html#CADDLINKMODE">CADDLINKMODE</a>,
<a href="keywords.html#TRAJBREAKSFILE">TRAJBREAKSFILE</a>, <a href="keywords.html#TRACEFILE">TRACEFILE</a>, <a href="keywords.html#TRAJLINKSFILE">TRAJLINKSFILE</a>,
<a href="keywords.html#CLAGT_MSM">CLAGT_MSM</a>) can influence the steady state and
any other network-derived properties profoundly. Even for a single continuous trajectory, the observed probability
distribution in cluster space does not exactly agree with the network-derived prediction due to the imbalance
caused by having a beginning and an end. Consequently, a simultaneous use of network-dependent properties
such as <a href="keywords.html#CMSMCFEP">mean first passage times</a> or <a href="keywords.html#SYNTRAJ_MD">synthetic (state-based) trajectories</a>
and the raw sampling weight per state will be inconsistent. This is why the steady state - if computed - will be used in 
the subsequent <a href="keywords.html#CMSMCFEP">computation of cut-based free energy profiles</a>. Note that the steady state
can also be computed using linear algebra (&rarr; <a href="keywords.html#EIGVAL_MD">EIGVAL_MD</a>) and is 
required in the <a href="keywords.html#DOPFOLD_MINUS">computation of the (-) committor</a>.</li>
<li>This option is the same as the previous one only that all edges are first scaled by their geometric lengths. XXXXXXXXXXXXXXX</li>
</ol>
Like any method based on the transition matrix, this functionality is available <a href="keywords.html#TMAT_MD">for forward and backward time</a>.
 In case of multiple strongly connected components, use of CREWEIGHT
requests all the individual components to be equilibrated separately (preserving their relative weights set directly by the trajectory).<br/>
The computation of the steady state
uses an iterative algorithm that can become quite time-consuming due to the slow convergence behavior. There is a
<a href="keywords.html#MAXTIME_ITERS">time control</a> for all iterative schemes of this type. The algorithm
is also numerically weak in that the convergence measure is unable to estimate the deviation of the current from the exact solution
accurately and in that the convergence properties can differ across the network. The algorithm does detect periodicity, which 
generally prevents convergence (the easiest example is a system of two mutually connected states with no self-transitions),
and will eventually report this and terminate. Unfortunately, the difficult cases for the iterative scheme are the same as those
for the <a href="keywords.html#EIGVAL_MD">linear algebra solution</a>. It can be illustrative to compute both solutions if possible
and compare them (&rarr; <a href="outputfiles.html#STRUCT_CLUSTERING.graphml">STRUCT_CLUSTERING.graphml</a>). The steady state
also provides a route toward reweighting a set of simulation data biased by initial conditions, <i>i.e.</i>, an ensemble of short
trajectories. The resultant weights are written by default to <a href="outputfiles.html#basename_yyy.fwts">dedicated output file(s)</a>
unless CREWEIGHT is 0, and these files can usually be used as an input to <a href="keywords.html#FRAMESFILE">FRAMESFILE</a> for
subsequent weighted analysis. The iterative algorithm has the advantage over the linear algebra solution that it
benefits from CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a>. Parallelization is such
that the results should always be identical to serial execution.<br/>
<h4><a class="NoHi" id="MAXTIME_ITERS"><b>MAXTIME_ITERS</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), which includes the
<a href="keywords.html#CPROGINDMODE">approximate progress index method</a>, this keyword can be set to define a maximum execution time (in seconds)
of any iterative scheme computing convergent properties of/from the <a href="keywords.html#TMAT_MD">transition matrix</a>, which are currently 
used for the steady state (&rarr; <a href="keywords.html#CREWEIGHT">CREWEIGHT</a>), the mean first passage times
(&rarr; <a href="keywords.html#CMSMCFEP">CMSMCFEP</a>) to a reference cluster, and the iterative maximum likelihood inference
(&rarr; <a href="keywords.html#CADDLINKMODE">CADDLINKMODE</a> is 6).  The normal convergence threshold 
for these algorithms must for accuracy reasons be set to such a small number that the execution can easily time out (without a printed solution) 
on time-limited resources if the network is large and not well-connected. This is why this keyword, which defaults to an unlimited execution time,
can be set to force a solution after a given time irrespective of convergence. Note that the execution time specified here refers
to a single execution of an individual algorithm, and that multiple invocations as well as the remainder of CAMPARI's execution time must be
estimated independently and corrected for. Note that all 3 of the aforementioned iterative algorithms can take advantage
of CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a>. The efficiency of this depends on the size
and connectedness of the network (larger is better for both).<br/>
<!-- ************************************************************************************************* -->
<!-- **************************************** INISYNSNAP ********************************************* -->
<h4><a class="NoHi" id="INISYNSNAP"><b>INISYNSNAP</b></a></h4>
If any type of structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), the underlying trajectory
is used to infer a <a href="keywords.html#TMAT_MD">transition network</a>. With this keyword, the user indicates the snapshot that is
used for the selection of the reference cluster (and reference strongly connected component) 
in a number of related analyses (<a href="keywords.html#SYNTRAJ_MD">SYNTRAJ_MD</a>, <a href="keywords.html#EIGVAL_MD">EIGVAL_MD</a>, <a href="keywords.html#DOPFOLD">DOPFOLD</a>,
and <a href="keywords.html#CMSMCFEP">CMSMCFEP</a>). 
The reference cluster is simply that cluster that contains the snapshot indicated by the value of this keyword and 
the reference component is the one the reference cluster belongs to. 
In the case of the generation of <a href="keywords.html#SYNTRAJ_MD">random walks</a> on the network, the reference 
cluster will be the starting node for options 1 and 2. This keyword also becomes relevant when committor 
probabilities are requested (<a href="keywords.html#DOPFOLD">DOPFOLD</a>) 
but no input file for the reference set <i>B</i> (see <a href="keywords.html#DOPFOLD">DOPFOLD</a> for definitions) 
is specified or found (<a href="inputfiles.html#CLUFOLDFILE">CLUFOLDFILE</a>). In this case, CAMPARI reverts 
to use as the only cluster of the set <i>B</i> the cluster selected here. If no value is specified, the default 
will take the cluster with the largest number of frames and its component as reference (option 0 described below).<br/>
Because the keyword uses a snapshot index, it is important to point out that the value of this keyword must 
always be specified in absolute terms of the input data, <i>i.e.</i>, generally speaking, no corrections must be applied
in case <a href="keywords.html#CCOLLECT">CCOLLECT</a> is greater than 1, a sequential access
<a href="keywords.html#FRAMESFILE">file with user-selected input frames</a> is specified, 
or <a href="keywords.html#EQUIL">frames are discarded at the beginning</a>. CAMPARI takes care of
this automatically. The use of a frames file requires particular care. If the file accesses the trajectory in random access ("as is") 
mode, the snapshot index is assumed to refer to the line number in the frames file rather than the index of the frame on that line. 
This is a general change of interpretation inherent to <a href="keywords.html#FRAMESFILE">FMCSC_FRAMESFILE</a> with certain 
<a href="keywords.html#PDB_FORMAT">input file formats</a>. Conversely, if the file accesses the trajectory in strictly sequential
mode, step numbers continue to refer to the <i>original</i> trajectory. If the selected reference snapshot is not present in the 
data to be finally extracted, the program will terminate at the very beginning.<br/>
<br/><br/>
As special values we have:
<ul>
<li>0 (default) : The cluster with the largest number of frames is selected as reference one for <a href="keywords.html#SYNTRAJ_MD">SYNTRAJ_MD</a>, 
     <a href="keywords.html#EIGVAL_MD">EIGVAL_MD</a>, and possibly <a href="inputfiles.html#CLUFOLDFILE">reference set B</a>.<br/>
     Only the <a href="keywords.html#CMSMCFEP">pseudo free energy profile</a>
     for the corresponding strongly connected component is calculated (depends also on <a href="keywords.html#TMAT_MD">TMAT_MD</a>), 
     if requested.<br/><br/>
<li>-1 : The cluster with the largest number of snapshots is selected as reference one for <a href="keywords.html#SYNTRAJ_MD">SYNTRAJ_MD</a>, 
     <a href="keywords.html#EIGVAL_MD">EIGVAL_MD</a>, and possibly <a href="inputfiles.html#CLUFOLDFILE">reference set B</a>.<br/>
     CAMPARI will (if possible) utilize all strongly connected components of the underlying graph and use the largest
     cluster within each component (subgraph) as reference for multiple, distinct <a href="keywords.html#CMSMCFEP">pseudo free energy profiles</a> 
     (separate output files), if requested.<br/><br/>
<li>-2 : The cluster with the largest number of snapshots within the largest strongly connected component 
     is selected as reference one for <a href="keywords.html#SYNTRAJ_MD">SYNTRAJ_MD</a>, <a href="keywords.html#EIGVAL_MD">EIGVAL_MD</a>, 
     and possibly <a href="inputfiles.html#CLUFOLDFILE">reference set B</a>.<br/>
     Only the <a href="keywords.html#CMSMCFEP">pseudo free energy profile</a>
     for the corresponding strongly connected component is calculated (depends also on <a href="keywords.html#TMAT_MD">TMAT_MD</a>), 
     if requested.<br/><br/>
</ul>
<!-- ************************************************************************************************* -->
<!-- **************************************** EIGVAL_MD ********************************************** -->
<h4><a class="NoHi" id="EIGVAL_MD"><b>EIGVAL_MD</b></a></h4>
If any type of structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), and CAMPARI was compiled and linked
with HSL support (→ <a href="install.html">installation instructions</a>), 
it is possible to perform a spectral analysis of the transition matrix(ces) derived from clustering (&rarr; <a href="keywords.html#TMAT_MD">TMAT_MD</a>), 
providing that the rank N of the transition matrix is &gt; 3.
The HSL library deputed to this task is the FORTRAN double precision version of <a href="http://www.hsl.rl.ac.uk/catalogue/eb13.html">EB13</a>, 
<i>viz.</i> calls to EB13ID, EB13AD, and possibly EB13BD are made in CAMPARI whenever required. Those routines implement the Arnoldi method 
for large sparse matrices and the user is invited to read up on the relevant documentation (<a href="http://www.hsl.rl.ac.uk/catalogue/eb13.html">EB13</a>). 
CAMPARI hides, however, some of the functionality 
offered by the HSL library itself. For example, referring to the relevant documentation (<a href="http://www.hsl.rl.ac.uk/catalogue/eb13.html">EB13</a>), 
the Arnoldi method used by CAMPARI is always the one with Chebychev acceleration 
of the starting vectors, <i>i.e.</i>, ICNTL(9) is hard-coded to 2, which is the only 
option we have tested. Currently, this choice can be altered only by modifying the source code whewre the relevant 
initialization happens (subroutine calc_eigs_msm(...) in source file <a href="../source/graph_algorithms.f90">graph_algorithms.f90</a>).
With the present keyword, the user
can decide whether or not to perform  
the spectral decomposition of the transition matrix and, in case it is performed, how to sort 
the eigenvalues of the transition matrix (with this keyword the "IND" variable of 
EB13AD is set to the same value with an offset of -1). The following options are available:<br/>
<ol start="0">
<li>No spectral decomposition is performed (default).</li>
<li>A selected number (&rarr; <a href="keywords.html#NEIGV">NEIGV</a>) of eigenvalues with largest absolute values are 
computed.</li>
<li>A selected number (&rarr; <a href="keywords.html#NEIGV">NEIGV</a>) of right-most eigenvalues are 
computed. These are the eigenvalues with the largest real parts. 
This option is probably the only useful option for the spectral analysis of a transition matrix as complex eigenvalues
are not generally interpretable to begin with.</li>
<li>A selected number (&rarr; <a href="keywords.html#NEIGV">NEIGV</a>) of eigenvalues with largest imaginary parts are 
computed.</li>
</ol>
The eigenvalues of the transition matrix (<a href="keywords.html#TMAT_MD">TMAT_MD</a>), 
with the exception of the one with the largest real part (which is always 1), can provide information on the transition time scales of the 
Markov process and the trend of such implied time scales as a function of the lag-time (<a href="keywords.html#CLAGT_MSM">CLAGT_MSM</a>) 
is often sought after to establish the (minimum) time scale at which the random walker dynamics may be truly Markovian on the state 
space defined by the clustering (see, <i>e.g.</i>, <a href="keywords.html#CDISTANCE">CDISTANCE</a> and <a href="keywords.html#CMODE">CMODE</a>). 
To achieve such an informative trend of the time scales (eigenvalues in decreasing order by their 
real part), this keyword must be set to 2, which is the only recommended option. Eigenvalues that are complex or negative
obviously violate this interpretation as the time scale <i>t</i> associated with
an eigenvalue is defined as <i>t</i> = -&tau;/ln(&lambda;), where &tau; is the lag time (&rarr; <a href="keywords.html#CLAGT_MSM">CLAGT_MSM</a>)
and &lambda; the eigenvalue in question.<br/>
If the spectral analysis of the transition matrix is requested, several dependent keywords controlling the task to be solved as well
as parameters of the Arnoldi method become relevant. The number of eigenvalues to be computed is set with <a href="keywords.html#NEIGV">NEIGV</a>, 
while keyword <a href="keywords.html#DOEIGVECT">DOEIGVECT</a> lets the user request the computation of the eigenvectors associated 
with the <a href="keywords.html#NEIGV">NEIGV</a> eigenvalues as well. The Arnoldi method is controlled by keywords
<a href="keywords.html#NEIGBLOCKS">NEIGBLOCKS</a>, <a href="keywords.html#NEIGSTEPS">NEIGSTEPS</a>, 
<a href="keywords.html#NEIGRST">NEIGRST</a>, and <a href="keywords.html#EIGTOL">EIGTOL</a>. The output produced by the use
of this keyword is always written to a dedicated output file (<a href="outputfiles.html#EIGEN_XXX.dat">EIGEN_XXX.dat</a>). In addition,
if the chosen option is 2 and the <a href="keywords.html#DOEIGVECT">eigenvectors are available</a>, output file
<a href="outputfiles.html#STRUCT_CLUSTERING.graphml">STRUCT_CLUSTERING.graphml</a> will contain the first
eigenvector as well. Lastly, note that the same routines may be called in case the <a href="keywords.html#DOPFOLD_MINUS">computation of the (-) committor</a>
was requested. In this particular case, the options are not directly controllable by the user, however.<br/>
Because the HSL routines are not (currently) threads-parallel, this functionality does not benefit from CAMPARI's
<a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a>, which is a limitation.<br/>
<!-- ************************************************************************************************* -->
<!-- **************************************** NEIGV ************************************************** -->
<h4><a class="NoHi" id="NEIGV"><b>NEIGV</b></a></h4>
If any type of structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), CAMPARI was compiled and linked
with HSL support (→ <a href="install.html">installation instructions</a>), and <a href="keywords.html#EIGVAL_MD">EIGVAL_MD</a> is not zero,
this integer value defines how many eigenvalues should be returned by the spectral decomposition (<a href="keywords.html#EIGVAL_MD">EIGVAL_MD</a>) 
of the transition matrix(ces) (<a href="keywords.html#TMAT_MD">TMAT_MD</a>). The returned eigenvalues are maximal in some sense, and this is defined
by the choice for <a href="keywords.html#EIGVAL_MD">EIGVAL_MD</a>.
This keyword effectively sets the value of variable "NUMEIG" in the underlying HSL routine <a href="http://www.hsl.rl.ac.uk/catalogue/eb13.html">EB13</a>.
The value for this keyword influences the choice for <a href="keywords.html#NEIGSTEPS">NEIGSTEPS</a> and <a href="keywords.html#NEIGBLOCKS">NEIGBLOCKS</a>, 
since it is required that min(N, NEIGV) &le; <a href="keywords.html#NEIGSTEPS">NEIGSTEPS</a>&#183;<a href="keywords.html#NEIGBLOCKS">NEIGBLOCKS</a> &le; N, where N is the rank of the
transition  matrix (N &gt; 3). It is worth to note that the cost for the Arnoldi steps at each iteration scales as
(<a href="keywords.html#NEIGBLOCKS">NEIGBLOCKS</a>&#183;<a href="keywords.html#NEIGSTEPS">NEIGSTEPS</a>)<sup>2</sup>&#183;N, 
while the cost of computing the Hessenberg matrix is proportional to (<a href="keywords.html#NEIGBLOCKS">NEIGBLOCKS</a>&#183;<a href="keywords.html#NEIGSTEPS">NEIGSTEPS</a>)<sup>3</sup> 
and the memory requirements are proportional to (<a href="keywords.html#NEIGBLOCKS">NEIGBLOCKS</a>&#183;<a href="keywords.html#NEIGSTEPS">NEIGSTEPS</a>)<sup>2</sup>,
as outlined in the documentation for <a href="http://www.hsl.rl.ac.uk/catalogue/eb13.html">EB13</a>.
Therefore, increasing the number of eigenvalues to be computed can impact both the achievement of the desired convergence criterion (<a href="keywords.html#EIGTOL">EIGTOL</a>), 
which may be addressed by keyword <a href="keywords.html#NEIGRST">NEIGRST</a>,  
and can have a dramatic effect on execution time and memory footprint.<br/>
<!-- ************************************************************************************************* -->
<!-- **************************************** DOEIGVECT ********************************************** -->
<h4><a class="NoHi" id="DOEIGVECT"><b>DOEIGVECT</b></a></h4>
If any type of structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), CAMPARI was compiled and linked
with HSL support (→ <a href="install.html">installation instructions</a>), and <a href="keywords.html#EIGVAL_MD">EIGVAL_MD</a> is not zero,
this simple logical (1 is true) allows the user to request CAMPARI to compute eigenvectors along with eigenvalues, which are 
added to the same output file, <i>viz.</i>, <a href="outputfiles.html#EIGEN_XXX.dat">EIGEN_XXX.dat</a>. If <a href="keywords.html#EIGVAL_MD">EIGVAL_MD</a> 
is set to 2, the first eigenvector contains the steady state of the transition network (<a href="keywords.html#TMAT_MD">TMAT_MD</a>), 
which is also reported in the output file <a href="outputfiles.html#STRUCT_CLUSTERING.graphml">STRUCT_CLUSTERING.graphml</a>.
In case the network is fractured into multiple, strongly connected components, the computation and output are limited 
to the strongly connected component the reference cluster (<a href="keywords.html#INISYNSNAP">INISYNSNAP</a>) 
resides in. Additional eigenvectors (&rarr; <a href="keywords.html#NEIGV">NEIGV</a>),  which refer to the eigenvalues smaller than 1, are 
often interpreted to report on the involvement of each cluster in the transition associated with a characteristic time scale, which is given by the 
corresponding eigenvalue &lambda; as t = - &tau;/ln(&lambda;) where &tau; is the lag time (&rarr; <a href="keywords.html#CLAGT_MSM">CLAGT_MSM</a>).<br/>
<!-- ************************************************************************************************* -->
<!-- **************************************** NEIGBLOCKS ********************************************* -->
<h4><a class="NoHi" id="NEIGBLOCKS"><b>NEIGBLOCKS</b></a></h4>
If any type of structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), CAMPARI was compiled and linked
with HSL support (→ <a href="install.html">installation instructions</a>), and <a href="keywords.html#EIGVAL_MD">EIGVAL_MD</a> is not zero,
this keyword lets the user set the number of blocks for the Arnoldi method.
It corresponds to the variable "NBLOCKS" in the reference library documentation (<a href="http://www.hsl.rl.ac.uk/catalogue/eb13.html">EB13</a>).
NEIGBLOCKS must be &ge; 1 and the conditions min(N, <a href="keywords.html#NEIGV">NEIGV</a>) &le; <a href="keywords.html#NEIGSTEPS">NEIGSTEPS</a>&#183;NEIGBLOCKS &le; 
N must always hold true, with N being the rank of the transition matrix (<a href="keywords.html#TMAT_MD">TMAT_MD</a>), N &gt; 3. 
If NEIGBLOCKS is set to 1, the unblocked Arnoldi method is used (<a href="http://www.hsl.rl.ac.uk/catalogue/eb13.html">EB13</a>).
If this keyword is not found, the current default choice is to set NEIGBLOCKS to <a href="keywords.html#NEIGV">NEIGV</a> + 2. 
However, the best choice for this value together with the value for <a href="keywords.html#NEIGSTEPS">NEIGSTEPS</a> 
depends on the problem. In the reference documentation (<a href="http://www.hsl.rl.ac.uk/catalogue/eb13.html">EB13</a>),
the suggestion is to set NEIGBLOCKS to at least the value of <a href="keywords.html#NEIGV">NEIGV</a> and to set <a href="keywords.html#NEIGSTEPS">NEIGSTEPS</a> 
such that <a href="keywords.html#NEIGSTEPS">NEIGSTEPS</a>&#183;NEIGBLOCKS lies in the range between 
3&#183;<a href="keywords.html#NEIGV">NEIGV</a> and 10&#183;<a href="keywords.html#NEIGV">NEIGV</a>.<br/>
<!-- ************************************************************************************************* -->
<!-- **************************************** NEIGSTEPS ********************************************** -->
<h4><a class="NoHi" id="NEIGSTEPS"><b>NEIGSTEPS</b></a></h4>
If any type of structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), CAMPARI was compiled and linked
with HSL support (→ <a href="install.html">installation instructions</a>), and <a href="keywords.html#EIGVAL_MD">EIGVAL_MD</a> is not zero,
this integer variable sets the number of steps for the Arnoldi method and corresponds to 
the variable "NSTEPS" in the reference library documentation (<a href="http://www.hsl.rl.ac.uk/catalogue/eb13.html">EB13</a>). 
The minimum allowed value is 2 and the requirements min(N, <a href="keywords.html#NEIGV">NEIGV</a>) &le; NEIGSTEPS&#183;<a href="keywords.html#NEIGBLOCKS">NEIGBLOCKS</a> &le; 
N must always be respected, with N being the rank of the transition matrix (<a href="keywords.html#TMAT_MD">TMAT_MD</a>), N &gt; 3. 
The current default choice is to set this variable to ceiling((8.&#183;<a href="keywords.html#NEIGV">NEIGV</a>)/(<a href="keywords.html#NEIGV">NEIGV</a> + 2)), 
if no specifications are given from the user. However, the best choice for this value together with the value for <a href="keywords.html#NEIGBLOCKS">NEIGBLOCKS</a> 
is dependent on the problem. In the reference documentation (<a href="http://www.hsl.rl.ac.uk/catalogue/eb13.html">EB13</a>),
the suggestion is to set <a href="keywords.html#NEIGBLOCKS">NEIGBLOCKS</a>
to at least the value of <a href="keywords.html#NEIGV">NEIGV</a> and to set NEIGSTEPS
such that NEIGSTEPS&#183;<a href="keywords.html#NEIGBLOCKS">NEIGBLOCKS</a> lies in the range between 
3&#183;<a href="keywords.html#NEIGV">NEIGV</a> and 10&#183;<a href="keywords.html#NEIGV">NEIGV</a>.<br/>
<!-- ************************************************************************************************* -->
<!-- **************************************** NEIGRST ************************************************ -->
<h4><a class="NoHi" id="NEIGRST"><b>NEIGRST</b></a></h4>
If any type of structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), CAMPARI was compiled and linked
with HSL support (→ <a href="install.html">installation instructions</a>), and <a href="keywords.html#EIGVAL_MD">EIGVAL_MD</a> is not zero,
this keyword lets the user select the number of restarts of the Arnoldi's method before the 
execution is terminated in case the wanted convergence (<a href="keywords.html#EIGTOL">EIGTOL</a>)
has not been achieved in the previous <a href="keywords.html#NEIGSTEPS">set of steps</a>.
The default value is set to 10, which means that the execution is aborted after 10 restarts from the possible intermediate and not yet converged solution.
For the sake of completeness and clarity, the hard-coded value for the number of iteration within <a href="http://www.hsl.rl.ac.uk/catalogue/eb13.html">EB13</a>, 
<i>viz.</i> ICNTL(11), is 999, and that is not the value set by this keyword.<br/>
<!-- ************************************************************************************************* -->
<!-- **************************************** EIGTOL ************************************************ -->
<h4><a class="NoHi" id="EIGTOL"><b>EIGTOL</b></a></h4>
If any type of structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), CAMPARI was compiled and linked
with HSL support (→ <a href="install.html">installation instructions</a>), and <a href="keywords.html#EIGVAL_MD">EIGVAL_MD</a> is not zero,
this keyword sets the tolerance on the residuals that needs to be achieved before the computed solution of the 
eigenvalue problem on the transition matrix(ces) (&rarr; <a href="keywords.html#TMAT_MD">TMAT_MD</a>) 
is deemed appropriate. It defaults to 10<sup>3</sup>&#183;"machine precision" and corresponds 
to CNTL(1) in the library documentation (<a href="http://www.hsl.rl.ac.uk/catalogue/eb13.html">EB13</a>). 
For completeness, we mention here that ICNTL(7) is hard-coded to 1, which means that convergence 
is checked against the Frobenius norm of the matrix, which is computed by default.<br/>
<h4><a class="NoHi" id="CMSMCFEP"><b>CMSMCFEP</b></a></h4>
If structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), which includes the case of 
the approximate progress index method, this keyword allows the user to select a type of cut-based pseudo free energy
profile to be computed (<a href="references.html#ref23_12">reference</a>). The target node for this profile can
be chosen with keyword <a href="keywords.html#INISYNSNAP">INISYNSNAP</a>, which is snapshot-based and includes
the selection of the largest cluster(s) (by sampling weight). Depending on the assumed direction of time
(&rarr; <a href="keywords.html#TMAT_MD">TMAT_MD</a>) and the choice below more than 1 profile may be generated (separate
output files).
Currently, there are 4 fully supported options producing output (some hidden options exist, which will not be disabled):<br/>
<ol start="0">
<li>No cut-based free energy profiles are computed.</li>
<li>The mean-first passage times to the reference node in the Markov state model approximation are computed iteratively.
After sorting all clusters according to these mean first passage times, partitions can be defined as a function of 
a threshold time. The cut-based pseudo free energy profile associates each threshold time with the total weight
of edges (number of transitions) crossing this threshold along the trajectory, and plots the normalized weight in
logarithmic fashion (see <a href="outputfiles.html#MFPT_yyy_CFEP_xxxxxxxx.dat">elsewhere</a> for details). Because
the iterative algorithm may be slow to converge, its maximum execution time can be controlled by
keyword <a href="keywords.html#MAXTIME_ITERS">MAXTIME_ITERS</a>. In this mode, a separate profile for each strongly
connected component of a nonergodic graph can be produced if <a href="keywords.html#INISYNSNAP">INISYNSNAP</a> is -1.
These profiles are referenced to the respective largest clusters (by sampling weight) in each component.
The iterative algorithm used here benefits from CAMPARI's <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a>
(similar to <a href="keywords.html#CREWEIGHT">network equilibration</a>). Parallelization is such
that the results should always be identical to serial execution.</li>
<li value="8">The (+) committor probabilities for a set of clusters defining a <a href="keywords.html#CLUFOLDFILE">target set</a>
and an <a href="keywords.html#CLUUNFOLDFILE">unfolded set</a> are used to sort all clusters (folded and unfolded set members
have values of 1.0 and 0.0 by definition, and clusters are sorted in decreasing order). This requires having
computed those committor probabilities separately (CMSMCFEP can <b>not</b> be used to enable this calculation) with
the help of keyword <a href="keywords.html#DOPFOLD">DOPFOLD</a>. Because the committor probabilities are only available
for the reference component the sets reside in, <a href="keywords.html#INISYNSNAP">INISYNSNAP</a> has no direct influence
(in particular, option -1 is not available). See <a href="outputfiles.html#PFOLD_PLUS_yyy_CFEP_xxxxxxxx.dat">elsewhere</a> for details
on the corresponding output file(s).</li>
<li>This is the same as the previous option only that the (-) committor probabilities are used instead, which
additionally relies on keyword <a href="keywords.html#DOPFOLD_MINUS">DOPFOLD_MINUS</a>. See <a href="outputfiles.html#PFOLD_MINUS_yyy_CFEP_xxxxxxxx.dat">elsewhere</a> for details
on the corresponding output file(s).</li>
<li>This is the combination of the prior 2 options, <i>i.e.</i>, separate profiles based on both (+) and (-) committor probabilities
are produced. The same dependencies and restrictions apply.</li>
</ol>
Note that in general the deferred selection of reference clusters chooses by sampling weights, which are
not the same as the steady state weights of the underlying transition matrix. This means that the largest cluster
in steady state probability may not be the same. These effects become more pronounced with lower sampling quality
and larger amounts of link structure modifications (see <a href="keywords.html#TMAT_MD">TMAT_MD</a> for details).<br/>
<!-- ************************************************************************************************* -->
<!-- **************************************** SYNTRAJ_MD ********************************************* -->
<h4><a class="NoHi" id="SYNTRAJ_MD"><b>SYNTRAJ_MD</b></a></h4>
If any type of structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), this keyword specifies whether random walks on
a transition network should be performed (and recorded), and how the initial and termination conditions are chosen.
Synthetic trajectories are always confined within the 
strongly connected component that contains the cluster that hosts the initial reference snapshot (<a href="keywords.html#INISYNSNAP">INISYNSNAP</a>). 
The values allowed for the present keyword and their associated outcomes are:<br/>
<ol start="0">
<li>No synthetic trajectories are generated (default).</li>
<li>Random walks are initiated in the cluster that contains the reference initial snapshot (<a href="keywords.html#INISYNSNAP">INISYNSNAP</a>) 
and are terminated either when the walker hits the cluster that contains the target snapshot (<a href="keywords.html#ENDSYNSNAP">ENDSYNSNAP</a>) 
or when the target number of steps per trajectory is exceeded (<a href="keywords.html#NSYNSNAPS">NSYNSNAPS</a>). 
In the latter scenario, the unsuccessful trajectory is not written to file (<a href="outputfiles.html#MSM_SYN_TRAJ_xxxxx_yyy.frames">MSM_SYN_TRAJ_xxxxx_yyy.frames</a>). 
The target number of trajectories to be generated is set by the keyword <a href="keywords.html#NSYNTRAJS">NSYNTRAJS</a>. 
Since trajectories may fail to hit the target end node, it is possible that the number of successful trajectories is less than <a href="keywords.html#NSYNTRAJS">NSYNTRAJS</a>. 
If trajectories fail repeatedly, it is advisable to increase the number of steps per trajectory (<a href="keywords.html#NSYNSNAPS">NSYNSNAPS</a>). If the fraction
of productive trajectories is small, their lengths will obviously be biased systematically toward shorter lengths.</li>
<li>Synthetic trajectories are started at the cluster that hosts the reference snapshot (<a href="keywords.html#INISYNSNAP">INISYNSNAP</a>) 
and propagated for <a href="keywords.html#NSYNSNAPS">NSYNSNAPS</a> steps, regardless where they end. Therefore, the generation of a trajectory is always successful, 
<i>viz.</i>, <a href="keywords.html#NSYNTRAJS">NSYNTRAJS</a> trajectories are always written to file (<a href="outputfiles.html#MSM_SYN_TRAJ_xxxxx_yyy.frames">MSM_SYN_TRAJ_xxxxx_yyy.frames</a>).</li>
<li>Each <a href="keywords.html#NSYNTRAJS">NSYNTRAJS</a> trajectory starts in a random cluster. 
The probability that a cluster is the starting one reflects its statistical weight, which is proportional  
to the raw population of the cluster if no equilibration of the transition network is performed or to the steady state of the Markov State Model 
otherwise (see <a href="keywords.html#CREWEIGHT">CREWEIGHT</a> and <a href="keywords.html#EIGVAL_MD">EIGVAL_MD</a>).
Each trajectory is propagated for <a href="keywords.html#NSYNSNAPS">NSYNSNAPS</a> 
steps and written to file (<a href="outputfiles.html#MSM_SYN_TRAJ_xxxxx_yyy.frames">MSM_SYN_TRAJ_xxxxx_yyy.frames</a>). Keyword <a href="keywords.html#INISYNSNAP">INISYNSNAP</a> 
is used solely to identify the strongly connected component where the random walk takes place.</li>
</ol>
This keyword allows the user to generate synthetic trajectories, which are random walks on the state space 
defined by a coarse graining into clusters of the input MD trajectory (<a href="outputfiles.html#STRUCT_CLUSTERING.clu">STRUCT_CLUSTERING.clu</a>). 
The connectivity between the clusters, <i>viz.</i>, the number of transitions between the nodes of the network, 
is inferred directly from the input data and is used to construct the so-called transition matrix, 
which is ultimately the propagator of the synthetic dynamics. Many keywords, when in use, have an impact on the transition matrix and therefore 
on the random walks (see <a href="keywords.html#TMAT_MD">elsewhere</a> for a list). The actual connectivity
is available from output files <a href="outputfiles.html#STRUCT_CLUSTERING.graphml">STRUCT_CLUSTERING.graphml</a> and
<a href="outputfiles.html#TMAT_xxxxxx_yyy.dat">TMAT_xxxxxx_yyy.dat</a> where the availability of the latter 
depends on <a href="keywords.html#TMATREPORT">TMATREPORT</a>. The output files can be numerous and grow quickly, which is why
keyword  <a href="keywords.html#SYNTRAJOUT">SYNTRAJOUT</a> can be used to control the output frequency. Note that
the <a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization of CAMPARI</a> supports generating these 
trajectories in parallel. It must be mentioned, however, that the main cost can easily be the file system bandwidth
(the inherent cost of trajectory generation is marginal) consumed for writing the output files, which may limit
or even eliminate any benefits from parallelization.<br/>
<!-- ************************************************************************************************* -->
<!-- **************************************** ENDSYNSNAP ********************************************* -->
<h4><a class="NoHi" id="ENDSYNSNAP"><b>ENDSYNSNAP</b></a></h4>
If any type of structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), and 
<a href="keywords.html#SYNTRAJ_MD">the generation of synthetic trajectories with a target end point</a> has been
requested, this keyword lets the user select the target snapshot for these random walks. 
It works analogously to keyword <a href="keywords.html#INISYNSNAP">INISYNSNAP</a>,
and it is up to the user to ensure that the reference end target node selected this way differs 
from the starting one and belongs to the same strongly connected component. If these conditions are not met,
the relevant analyses will be skipped. In case <a href="keywords.html#DOPFOLD">committor probabilities</a> are requested but 
no input clusters are provided (<a href="outputfiles.html#CLUUNFOLDFILE">CLUUNFOLDFILE</a>) for set <i>A</i> 
(see <a href="keywords.html#DOPFOLD">DOPFOLD</a> for definitions), CAMPARI reverts to use the 
cluster selected here as the only one forming set <i>A</i>. If this keyword is not specified 
but needed, CAMPARI will use the last stored snapshot from the trajectory as reference end snapshot (default).<br/>
Because, like <a href="keywords.html#INISYNSNAP">INISYNSNAP</a>, the keyword uses a snapshot index,
it is important to point out that the value of this keyword must 
always be specified in absolute terms of the input data, <i>i.e.</i>, generally speaking, no corrections must be applied
in case <a href="keywords.html#CCOLLECT">CCOLLECT</a> is greater than 1, a sequential access
<a href="keywords.html#FRAMESFILE">file with user-selected input frames</a> is specified, 
or <a href="keywords.html#EQUIL">frames are discarded at the beginning</a>. CAMPARI takes care of
this automatically. The use of a frames file requires particular care. If the file accesses the trajectory in random access ("as is") mode,
the snapshot index is assumed to refer to the line number in the frames file rather than the index of the frame on that line. This is 
a general change of interpretation inherent to <a href="keywords.html#FRAMESFILE">FMCSC_FRAMESFILE</a> with certain 
<a href="keywords.html#PDB_FORMAT">input file formats</a>. Conversely, if the file accesses the trajectory in strictly sequential
mode, step numbers continue to refer to the <i>original</i> trajectory.<br/>
<!-- ************************************************************************************************* -->
<!-- **************************************** NSYNTRAJS *********************************************** -->
<h4><a class="NoHi" id="NSYNTRAJS"><b>NSYNTRAJS</b></a></h4>
If any type of structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), and 
<a href="keywords.html#SYNTRAJ_MD">the generation of synthetic trajectories</a> has been requested,
this keyword specifies the target number of synthetic trajectories (random walks) to be generated.
The default value is 10 and the upper limit is 10<sup>4</sup>. 
This number is guaranteed to be the actual number of generated trajectories only if <a href="keywords.html#SYNTRAJ_MD">SYNTRAJ_MD</a> 
is not set to 1. For trajectories with requested start and end points (mode 1), this keyword specifies the
total number of <i>attempts</i> instead. The fraction and average length of productive trajectories will be reported
to log output, but only successful trajectories are written to file.<br/>
<!-- ************************************************************************************************* -->
<!-- **************************************** NSYNSNAPS ********************************************* -->
<h4><a class="NoHi" id="NSYNSNAPS"><b>NSYNSNAPS</b></a></h4>
If any type of structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), and 
<a href="keywords.html#SYNTRAJ_MD">the generation of synthetic trajectories</a> has been requested,
this keyword sets the (maximum) number of steps per synthetic trajectory (random walk). All trajectories will have this
length unless keyword <a href="keywords.html#SYNTRAJ_MD">SYNTRAJ_MD</a> is set to 1. Note that in mode
1 where both a <a href="keywords.html#INISYNSNAP">starting</a> and an <a href="keywords.html#ENDSYNSNAP">end point</a>
are used, too small a value for NSYNSNAPS will obviously bias the distribution of productive (reactive) trajectories to short ones.<br/>
<h4><a class="NoHi" id="SYNTRAJOUT"><b>SYNTRAJOUT</b></a></h4>
If any type of structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), and 
<a href="keywords.html#SYNTRAJ_MD">the generation of synthetic trajectories</a> has been requested,
this keyword sets the output frequency for the synthetic trajectories (random walks) themselves. These files are
<a href="outputfiles.html#MSM_SYN_TRAJ_xxxxx_yyy.dat">documented elsewhere</a>, but they ultimately contain
lists of integers, which can get large (in total file size) very quickly. This is why this keyword
allows the user to print only every SYNTRAJOUT<sup>th</sup> step of each random walk to the corresponding output file. If
<a href="keywords.html#SYNTRAJ_MD">SYNTRAJ_MD</a> is 1, the keyword can also be set to 0, in which case all output is suppressed (using 
a very large value instead causes the individual files and just their respective header lines to be written).<br/>
<!-- ************************************************************************************************* -->
<!-- **************************************** DOPFOLD ************************************************ -->
<h4><a class="NoHi" id="DOPFOLD"><b>DOPFOLD</b></a></h4>
If any type of structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), 
and CAMPARI was compiled and liked with HSL support (→ <a href="install.html">installation instructions</a>), 
this simple logical (1 is true) selects whether or not to compute (+) committor probabilities (or p<sub>folds</sub><sup>+</sup> values) 
for the clusters that belong to the reference component of the graph
inferred from the clustering. The underlying transition matrix can be modified in various ways
(see <a href="keywords.html#TMAT_MD">TMAT_MD</a> for details), which may weaken or fracture the graph into multiple strongly connected components.<br/>
A set of clusters to form the target set <i>B</i> (<a href="keywords.html#CLUFOLDFILE">CLUFOLDFILE</a>) 
and a set of clusters to form an alternative set <i>A</i> (<a href="keywords.html#CLUUNFOLDFILE">CLUUNFOLDFILE</a>) are
required and must belong to the same component. If these input files are missing choices are deferred to 
keywords <a href="keywords.html#INISYNSNAP">INISYNSNAP</a> and <a href="keywords.html#ENDSYNSNAP">ENDSYNSNAP</a>.
The remaining clusters in the same component constitute the intermediate set and for them the probability that 
a random walker started in that intermediate state reaches any cluster in the <a href="keywords.html#CLUFOLDFILE">target set <i>B</i></a> 
before it reaches any cluster in the <a href="keywords.html#CLUUNFOLDFILE">other set <i>A</i></a> can be calculated.
By definition (as boundary condition), all the nodes that belong to the target set <i>B</i> have a p<sub>fold</sub><sup>+</sup> 
value equal to 1, while all the clusters that belong to set <i>A</i> have a p<sub>fold</sub><sup>+</sup> value equal to 0.<br/>
If DOPFOLD is set to 1, with the aid of HSL-provided (double precision) external routines (<a href="http://www.hsl.rl.ac.uk/catalogue/hsl_ma48.html">HSL_MA48</a>), 
the solution is the solution of a linear system of equations for the clusters <i>i</i> in the intermediate set <i>I</i> (<a href="references.html#ref23_20">Noé <i>et al.</i></a>):
<br/>
-p<sub>fold<sub>i</sub></sub><sup>+</sup> + &Sigma;<sub>j&#8712;I</sub> T<sub>ij</sub>p<sub>fold<sub>j</sub></sub><sup>+</sup> = - &Sigma;<sub>j&#8712;B</sub>T<sub>ij</sub>
<br/>
Here, <i>T</i> is the underlying transition matrix (&rarr; <a href="keywords.html#TMAT_MD">TMAT_MD</a>).
Once solved, the committor probabilities are written to a specific output file (<a href="outputfiles.html#PFOLD_PLUS_xxx.dat">PFOLD_PLUS_xxx.dat</a>).
The computed p<sub>fold</sub><sup>+</sup> values are obviously 
sensitive to any modifications to the <a href="keywords.html#TMAT_MD">transition matrix</a>. The time direction matters
unless detailed balance holds (&rarr; <a href="keywords.html#CADDLINKMODE">CADDLINKMODE</a>), in which case the 
p<sub>fold</sub><sup>+</sup> values become equivalent to 1.0-p<sub>fold</sub><sup>-</sup> computed via keyword
<a href="keywords.html#DOPFOLD_MINUS">DOPFOLD_MINUS</a>. In case detailed balance does not hold,
the values for the (-) committors (p<sub>folds</sub><sup>-</sup>) must be computed separately.<br/>
One of the reasons to compute 
committor probabilities may be probability flux analyses and decompositions of pathways 
according to transition path theory (<a href="references.html#ref23_20">Noé <i>et al.</i></a>, <a href="references.html#ref23_21">Berezhkovskii <i>et al.</i></a>),
and committors are indeed fundamental to these analyses.
<br/>
Because the HSL routines are not (currently) threads-parallel, this functionality does not benefit from CAMPARI's
<a href="keywords.html#NRTHREADS">shared memory (OpenMP) parallelization</a>, which is a limitation.<br/>
<!-- ************************************************************************************************* -->
<!-- **************************************** DOPFOLD_MINUS ****************************************** -->
<h4><a class="NoHi" id="DOPFOLD_MINUS"><b>DOPFOLD_MINUS</b></a></h4>
If any type of structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), 
CAMPARI was compiled and liked with HSL support (→ <a href="install.html">installation instructions</a>), 
and <a href="keywords.html#DOPFOLD">(+) committor probabilities</a> have been computed, 
this simple logical keyword (1 is true) lets the user request the computation of (-) committor probabilities or p<sub>folds</sub><sup>-</sup> values
as well. These committors are defined as the probability that a random walk that reaches an intermediate state <i>i</i> 
was last seen in <a href="keywords.html#CLUUNFOLDFILE">the alternative set (<i>A</i>)</a> rather than in the <a href="keywords.html#CLUFOLDFILE">target set (<i>B</i>)</a>.
Details on nomenclature and background are found in the description of keyword <a href="keywords.html#DOPFOLD">DOPFOLD</a>.
Their computation requires the solution  of a linear system similar to the one specified for the (+) committors (p<sub>fold</sub><sup>+</sup>):
<br/>
-p<sub>fold<sub>i</sub></sub><sup>-</sup> + &Sigma;<sub>j&#8712;I</sub> X&#772;<sub>ij</sub>p<sub>fold<sub>j</sub></sub><sup>-</sup> = - &Sigma;<sub>j&#8712;A</sub>X&#772;<sub>ij</sub>
<br/>
Here, X&#772; is defined as T&#772;<sub>ij</sub> = (&pi;<sub>j</sub>/&pi;<sub>i</sub>) T<sub>ji</sub>, 
&pi;<sub>i</sub> is the steady state probability of node <i>i</i> of the original transition matrix T.
The underlying transition matrix is affected by a number of keywords (see <a href="keywords.html#TMAT_MD">TMAT_MD</a> for details).
The resultant (-) committor probabilities are written to a specific output file (<a href="outputfiles.html#PFOLD_MINUS_xxx.dat">PFOLD_MINUS_xxx.dat</a>).
If microscopic reversibility (detailed imbalance) holds (&rarr; <a href="keywords.html#CADDLINKMODE">CADDLINKMODE</a>),
the (-) committor probabilities can simply be computed as 1.0-p<sub>fold</sub><sup>+</sup>, and there is no need
to use this DOPFOLD_MINUS. If it does not hold, X&#772; is not simply the backward time transition matrix (&rarr; <a href="keywords.html#TMAT_MD">TMAT_MD</a>).
Therefore, if DOPFOLD_MINUS is used, CAMPARI always computes T&#772; 
from the definition above, which may be numerically problematic in case state probabilities differ 
by some orders of magnitude. Since we require the steady state or first eigenvector,
CAMPARI will check whether an acceptable solution is already available from the use of keywords <a href="keywords.html#EIGVAL_MD">EIGVAL_MD</a> or
<a href="keywords.html#CREWEIGHT">CREWEIGHT</a> (in this order). If not, CAMPARI attempts to solve the steady state
using the HSL library <a href="http://www.hsl.rl.ac.uk/catalogue/eb13.html">EB13</a> similar to what would be done if 
<a href="keywords.html#EIGVAL_MD">EIGVAL_MD</a> is 2, <a href="keywords.html#DOEIGVECT">DOEIGVECT</a> is 1, and 
 <a href="keywords.html#NEIGV">NEIGV</a> is 1. For this solution, keywords 
<a href="keywords.html#NEIGBLOCKS">NEIGBLOCKS</a> and <a href="keywords.html#NEIGSTEPS">NEIGSTEPS</a> are not respected (values of 3 and 3 are used instead), but the settings
for <a href="keywords.html#EIGTOL">EIGTOL</a> and <a href="keywords.html#NEIGRST">NEIGRST</a> remain relevant.
If the solution is successful and acceptable, it will also be reported in <a href="outputfiles.html#STRUCT_CLUSTERING.graphml">output file STRUCT_CLUSTERING.graphml</a>.<br/>
<!-- ************************************************************************************************* -->
<!-- **************************************** PFOLDREPORT ******************************************** -->
<h4><a class="NoHi" id="PFOLDREPORT"><b>PFOLDREPORT</b></a></h4>
If this simple logical is enabled (1 is true) several files that inform on the linear system(s) relevant 
to the achievement of committor probabilities (<a href="keywords.html#DOPFOLD">DOPFOLD</a>, <a href="keywords.html#DOPFOLD_MINUS">DOPFOLD_MINUS</a>) 
may be written. Those files are: <a href="outputfiles.html#fold_clus.out">fold_clus.out</a>, <a href="outputfiles.html#unfold_clus.out">unfold_clus.out</a>, 
<a href="outputfiles.html#mat_pfold_XXX_YYY.dat">mat_pfold_XXX_YYY.dat</a>, <a href="outputfiles.html#rhs_pfold_XXX_YYY.dat">rhs_pfold_XXX_YYY.dat</a>, 
and possibly <a href="outputfiles.html#tmat_pfold_XXX_minus.dat">tmat_pfold_XXX_minus.dat</a> and <a href="outputfiles.html#ss_pfold_XXX.dat">ss_pfold_XXX.dat</a>. 
Files <a href="outputfiles.html#fold_clus.out">fold_clus.out</a> and  <a href="outputfiles.html#unfold_clus.out">unfold_clus.out</a> 
simply replicate the clusters that make up <a href="keywords.html#CLUFOLDFILE">set <i>B</i></a> 
and <a href="keywords.html#CLUUNFOLDFILE">set <i>A</i></a> (see also <a href="keywords.html#DOPFOLD">DOPFOLD</a> for definitions) 
respectively, while files <a href="outputfiles.html#mat_pfold_XXX_YYY.dat">mat_pfold_XXX_YYY.dat</a> 
contain the coefficients of the linear system(s) solved to achieve committors, <i>viz.</i> <i>T - I</i> for <a href="keywords.html#DOPFOLD">DOPFOLD</a> 
and/or <i>T&#772; - I</i> for <a href="keywords.html#DOPFOLD_MINUS">DOPFOLD_MINUS</a>.
These last two outputs obviously consider only the entries relevant to the edges between the intermediate states 
and the self transitions, similarly to the <a href="outputfiles.html#rhs_pfold_XXX_YYY.dat">rhs_pfold_XXX_YYY.dat</a> 
files, where the right hand side of the linear systems (<a href="keywords.html#DOPFOLD">DOPFOLD</a> and/or <a href="keywords.html#DOPFOLD_MINUS">DOPFOLD_MINUS</a>) 
are written. Files <a href="outputfiles.html#tmat_pfold_XXX_minus.dat">tmat_pfold_XXX_minus.dat</a> contain the entries of T&#772; 
and are written only if <a href="keywords.html#DOPFOLD_MINUS">DOPFOLD_MINUS</a> is enabled, while files <a href="outputfiles.html#ss_pfold_XXX.dat">ss_pfold_XXX.dat</a> 
contain the steady state that was used to achieve T&#772;. Those are written only in case the steady state 
was not available from other options (for details see <a href="keywords.html#DOPFOLD_MINUS">DOPFOLD_MINUS</a>).
<br/>
<!-- ************************************************************************************************* -->
<!-- **************************************** CLUFOLDFILE ******************************************** -->
<h4><a class="NoHi" id="CLUFOLDFILE"><b>CLUFOLDFILE</b></a></h4>
If any type of structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), 
CAMPARI was compiled and liked with HSL support (→ <a href="install.html">installation instructions</a>), 
and the computation of at least <a href="keywords.html#DOPFOLD">(+) committor probabilities</a> has been requested,
this keyword let the user specify the path and name of the file that stores the reference snapshots 
for the selection of the clusters forming the target set <i>B</i> for all committor probabilities.
Details on the format and interpretation of the input are provided <a href="inputfiles.html#CLUFOLDFILE">elsewhere</a>.<br/>
In case this file is not provided or not found, CAMPARI will revert to the cluster 
defined by keyword <a href="keywords.html#INISYNSNAP">INISYNSNAP</a> as the only representative of set <i>B</i>.
In case keyword <a href="keywords.html#INISYNSNAP">INISYNSNAP</a> is not specified either, CAMPARI will 
use the cluster that contains the largest number of snapshots.
Because the sets <i>A</i> and <i>B</i> have to reside in the same strongly connected component of the 
clustering graph, it may not be possible to know reasonable values <i>a priori</i>. It can therefore
be helpful to use this analysis in conjunction with a previously generated
<a href="outputfiles.html#STRUCT_CLUSTERING.graphml">clustering-derived graph</a>. The graph 
can be analyzed to identify suitable values, and the committor probability analysis can be performed
in a second step by reading the <a href="outputfiles.html#STRUCT_CLUSTERING.clu">coarse-grained trajectory</a>
in conjunction with any link structure modifications back in by means of file-based clustering
(modes 6-7 for <a href="keywords.html#CMODE">CMODE</a>).<br/>
<!-- ************************************************************************************************* -->
<!-- **************************************** CLUUNFOLDFILE ****************************************** -->
<h4><a class="NoHi" id="CLUUNFOLDFILE"><b>CLUUNFOLDFILE</b></a></h4>
If any type of structural clustering is performed (&rarr; <a href="keywords.html#CCOLLECT">CCOLLECT</a>), 
CAMPARI was compiled and liked with HSL support (→ <a href="install.html">installation instructions</a>), 
and the computation of at least <a href="keywords.html#DOPFOLD">(+) committor probabilities</a> has been requested,
this keyword let the user specify the path and name of the file that stores the reference snapshots 
for the selection of the clusters forming the alternative set <i>A</i> for all committor probabilities.
Details on the format and interpretation of the input are provided <a href="inputfiles.html#CLUUNFOLDFILE">elsewhere</a>.<br/>
In case this file is not provided or not found, CAMPARI will revert to the cluster 
defined by keyword <a href="keywords.html#ENDSYNSNAP">ENDSYNSNAP</a> as the only representative of set <i>A</i>.
In case keyword <a href="keywords.html#ENDSYNSNAP">ENDSYNSNAP</a> is not specified either, CAMPARI will 
use the cluster that contains the last snapshot of the trajectory, which is not generally meaningful.
Because the sets <i>A</i> and <i>B</i> have to reside in the same strongly connected component of the 
clustering graph, it may not be possible to know reasonable values <i>a priori</i>. It can therefore
be helpful to use this analysis in conjunction with a previously generated
<a href="outputfiles.html#STRUCT_CLUSTERING.graphml">clustering-derived graph</a>. The graph 
can be analyzed to identify suitable values, and the committor probability analysis can be performed
in a second step by reading the <a href="outputfiles.html#STRUCT_CLUSTERING.clu">coarse-grained trajectory</a>
in conjunction with any link structure modifications back in by means of file-based clustering
(modes 6-7 for <a href="keywords.html#CMODE">CMODE</a>).<br/>
<!-- ************************************************************************************************* -->
<br/>
<br/>
<br/>
<h3><a class="NoHi" id="netcdf_analysis">NetCDF Data Mining:</a></h3>
<hr style="width: 100%; height: 2px;"></hr> (<a href="keywords.html#TOP">back to top</a>)<br/>
<h4><i>Preamble (this is not a keyword)</i></h4>
This mode is enabled by a separate executable that, however, rests on the same library as CAMPARI itself.
The compilation of this executable is analogous to CAMPARI executables and described in the <a href="install.html">installation instructions</a>.
This executable provides functionality to analyse input data provided in <a href="keywords.html#NCDM_NCFILE">NetCDF binary format</a>. 
The conversion of compliant <a href="keywords.html#NCDM_ASFILE">ASCII files</a> to the required NetCDF standard is also possible.
It is only available if the code was compiled and linked with NetCDF-support (see <a href="install.html">installation instructions</a>).
The available functionality is restricted to <a href="keywords.html#CMODE">structural clustering</a> 
of the input data (permissible values of <a href="keywords.html#CDISTANCE">CDISTANCE</a> 
are currently limited to 1, 2, 7, 8 and 9) and downstream analyses such as, <i>e.g.</i>, <a href="keywords.html#CMSMCFEP">cut-based free energy profile</a>,
<a href="keywords.html#CPROGINDMODE">progress index</a>, <a href="keywords.html#PCAMODE">principal component analysis</a>
and other network analyses (see for instance <a href="keywords.html#CREWEIGHT">CREWEIGHT</a>, <a href="keywords.html#SYNTRAJ_MD">SYNTRAJ_MD</a> <i>etc.</i>).
In case the code was also compiled with HSL support (→ <a href="install.html">installation instructions</a>), 
<a href="keywords.html#EIGVAL_MD">spectral decomposition</a> of <a href="keywords.html#TMAT_MD">transition matrices</a> 
and the computation of <a href="keywords.html#DOPFOLD">committor probabilities</a> 
are also supported. The presence of the keyword <a href="keywords.html#TRACEFILE">trace file</a> 
in the input key file is explicitly not allowed and results in a halt of the execution if 
detected.<br/>
<br/>
<hr/>
<!-- ************************* NCDM_NCFILE *********************************************************** -->
<h4><a class="NoHi" id="NCDM_NCFILE"><b>NCDM_NCFILE</b></a></h4>
With this keyword the user specifies the path and name of the input file in NetCDF format that 
encodes the data to be analyzed. For the required file standard (dimensions, variables, attributes 
etc.) we refer the user to the relevant <a href="inputfiles.html#FMCSC_NCDM_NCFILE">input file</a>
delineation and to the external <a href="references.html#ref16_1">NetCDF library documentation</a>. 
Keyword <a href="keywords.html#NCDM_WRTINPUT">NCDM_WRTINPUT</a> can be used to produce a summary 
of the information that was processed from the input NetCDF data source file in the guise of a NetCDF output file. 
This output file, useful for debug, is in compliance with the <a href="inputfiles.html#FMCSC_NCDM_NCFILE">internal standard</a>, 
but since it reflects choices such as <a href="keywords.html#CCOLLECT">CCOLLECT</a>, <a href="keywords.html#NCDM_FRAMESFILE">NCDM_FRAMESFILE</a> 
and <a href="keywords.html#NCDM_CFILE">NCDM_CFILE</a>, it should not be used as input for the present keyword. 
The reason lies in the fact that it may result incomplete if the same key file is used again (see <a href="keywords.html#NCDM_WRTINPUT">NCDM_WRTINPUT</a>). 
As a final note, it is important to mention that keyword NCDM_NCFILE is mutually exclusive with respect to <a href="keywords.html#NCDM_ASFILE">NCDM_ASFILE</a>: 
either the user provides a binary NetCDF as input or an ASCII file.
<br/>
<!-- ************************************************************************************************* -->
<!-- ************************* NCDM_ASFILE *********************************************************** -->
<h4><a class="NoHi" id="NCDM_ASFILE"><b>NCDM_ASFILE</b></a></h4>
This keyword is used to indicate the path and name of the input ASCII file that 
contains the data to be either converted to NetCDF format according to <a href="inputfiles.html#FMCSC_NCDM_NCFILE">internal conventions</a>, 
or analyzed with <a href="keywords.html#CMODE">structural clustering</a> and downstream routines, 
or both. This behavior is controlled by keywords <a href="keywords.html#NCDM_WRTINPUT">NCDM_WRTINPUT</a>
(to explicitly write down all the contents of the ASCII file in a NetCDF data base compliant 
with the correct <a href="inputfiles.html#FMCSC_NCDM_NCFILE">standard</a>) and <a href="keywords.html#NCDM_ANONAS">NCDM_ANONAS</a> 
(to do the analysis on the input ASCII data) and either one, or both, should be specified. 
For the ASCII file standard required by the program see <a href="inputfiles.html#FMCSC_NCDM_ASFILE">elsewhere</a>.
This keyword is mutually exclusive with respect to <a href="keywords.html#NCDM_NCFILE">NCDM_NCFILE</a>: 
either the user provides a binary NetCDF as input or an ASCII file. When an ASCII file is provided as 
input, there are more requirements from the user side than when a <a href="keywords.html#NCDM_NCFILE">NetCDF file</a> 
is used, and keywords <a href="keywords.html#NCDM_NRFEATS">NCDM_NRFEATS</a>, <a href="keywords.html#NCDM_NRFRMS">NCDM_NRFRMS</a> 
and <a href="keywords.html#NCDM_CHECKAS">NCDM_CHECKAS</a> become relevant in addition to, possibly, <a href="keywords.html#NCDM_PRDCRNG">NCDM_PRDCRNG</a>.
<br/>
<!-- ************************************************************************************************* -->
<!-- ************************* NCDM_WRTINPUT ********************************************************* -->
<h4><a class="NoHi" id="NCDM_WRTINPUT"><b>NCDM_WRTINPUT</b></a></h4>
By setting this keyword to 1, it is possible to ask the program to write a <a href="inputfiles.html#FMCSC_NCDM_NCFILE">NetCDF file</a> 
that is either the converted input <a href="keywords.html#NCDM_ASFILE">ASCII file</a> (and in this case choices from 
keywords such as <a href="keywords.html#CCOLLECT">CCOLLECT</a>, <a href="keywords.html#NCDM_FRAMESFILE">NCDM_FRAMESFILE</a>, <a href="keywords.html#NCDM_CFILE">NCDM_CFILE</a>, 
<i>etc.</i>, have no influence on the output, only on the possible downstream analyses, see <a href="keywords.html#NCDM_ANONAS">NCDM_ANONAS</a>) 
or the key information of the input <a href="keywords.html#NCDM_NCFILE">NetCDF database</a> 
that have been inferred by the software (for debug). The output names are "<a href="keywords.html#BASENAME">BASENAME</a>_converted.nc" 
and "<a href="keywords.html#BASENAME">BASENAME</a>_checked.nc", respectively. It is important to mention 
here that only the converted ASCII file is safe to be used as input <a href="keywords.html#NCDM_NCFILE">NetCDF database</a> 
since the output named as "<a href="keywords.html#BASENAME">BASENAME</a>_checked.nc" may not fully reflect 
the input <a href="keywords.html#NCDM_NCFILE">NetCDF file</a> which it corresponds to. This is because "<a href="keywords.html#BASENAME">BASENAME</a>_checked.nc"
 is sensible to keywords such as <a href="keywords.html#CCOLLECT">CCOLLECT</a>, <a href="keywords.html#NCDM_FRAMESFILE">NCDM_FRAMESFILE</a> 
and <a href="keywords.html#NCDM_CFILE">NCDM_CFILE</a>, differently from the output named "<a href="keywords.html#BASENAME">BASENAME</a>_converted.nc".
<br/>
<!-- ************************************************************************************************* -->
<!-- ************************* NCDM_PRDCRNG ********************************************************** -->
<h4><a class="NoHi" id="NCDM_PRDCRNG"><b>NCDM_PRDCRNG</b></a></h4>
Needed only when <a href="keywords.html#NCDM_WRTINPUT">conversion</a> and/or <a href="keywords.html#NCDM_ANONAS">analysis</a> 
of an input <a href="keywords.html#NCDM_ASFILE">ASCII file</a> that contains periodic variables is requested, 
this keyword lets the user specify the left and right boundaries of the periodic range of the degrees of freedom 
as two consecutive real values, respectively. The program will possibly use this information in <a href="keywords.html#NCDM_ANONAS">analysis</a> 
if <a href="keywords.html#CDISTANCE">CDISTANCE</a> is compatible with periodic data (set to either 1 or 2) 
and always adds the "periodic_range" attribute to the <a href="keywords.html#NCDM_NMFV">NetCDF variable</a> 
that contains the degrees of freedom if <a href="keywords.html#NCDM_WRTINPUT">conversion</a> 
is requested (see also <a href="inputfiles.html#FMCSC_NCDM_NCFILE">elsewhere</a>). 
<br/>
For periodic 
variables CAMPARI uses the interval [-180&deg;:180&deg;] as reference. This can be tricky 
if periodic variables are defined on a different interval, <i>e.g.</i>, [0&deg;:360&deg;]. 
In that case NCDM_PRDCRNG should still be set to -180 180 as the correct remapping happens 
automatically. In other words, even if the periodic variables take values in [0&deg;:360&deg;], 
setting NCDM_PRDCRNG to 0 360, or having the <a href="keywords.html#NCDM_NMFV">periodic attribute of the NetCDF variable</a> 
(see also <a href="inputfiles.html#FMCSC_NCDM_NCFILE">elsewhere</a>) to 0 360, would generate wrong 
results. These aspects are presented and discussed in Part B of <a href="tutorial14.html">Tutorial 14</a>, 
especially in Step B.4.
<br/>
<!-- ************************************************************************************************* -->
<!-- ************************* NCDM_NMFV ************************************************************* -->
<h4><a class="NoHi" id="NCDM_NMFV"><b>NCDM_NMFV</b></a></h4>
This keyword is useful to inform the program on the name of the variable in the input <a href="keywords.html#NCDM_NCFILE">NetCDF file</a>
that contains the values of the coordinates per frame to be analyzed. The default choice is "featuresvals".
It is important to note that there are tools that allow renaming variables, dimensions and attributes 
of a NetCDF database (see <a href="inputfiles.html#FMCSC_NCDM_NCFILE">NCDM_NCFILE</a>, <a href="references.html#ref16_1">NetCDF documentation</a>
and the Internet) as the software does not offer the possibility to specify names for all the required 
specifications of the <a href="keywords.html#NCDM_NCFILE">standard</a> it expects. It is also used 
to turn the name of the same variable from the default ("featuresvals") in case <a href="keywords.html#NCDM_WRTINPUT">conversion</a>
of an input <a href="keywords.html#NCDM_ASFILE">ASCII file</a> is requested.
<br/>
<!-- ************************************************************************************************* -->
<!-- ************************* NCDM_ANONAS ********************************************************** -->
<h4><a class="NoHi" id="NCDM_ANONAS"><b>NCDM_ANONAS</b></a></h4>
This simple logical (1 is true) allows the user to activate the analysis (<a href="keywords.html#CMODE">structural clustering</a> 
and possibly downstream routines) on the input <a href="keywords.html#NCDM_ASFILE">ASCII file</a> 
according to the specifications in the key file.
<br/>
<!-- ************************************************************************************************* -->
<!-- ************************* NCDM_NRFEATS ********************************************************** -->
<h4><a class="NoHi" id="NCDM_NRFEATS"><b>NCDM_NRFEATS</b></a></h4>
Number of features contained in the input <a href="keywords.html#NCDM_ASFILE">ASCII file</a>, required for 
<a href="keywords.html#NCDM_WRTINPUT">conversion</a> and/or <a href="keywords.html#NCDM_ANONAS">analysis</a>.
This number has to strictly correspond to the number of columns of the input <a href="keywords.html#NCDM_ASFILE">ASCII file</a> 
(see also <a href="inputfiles.html#FMCSC_NCDM_ASFILE">elsewhere</a>). The only way to subsample the 
provided degrees of freedom is to use the dedicated <a href="keywords.html#NCDM_NCFILE">analysis input file</a>.
Disabled by default, the user can request specific (but slow) row-by-row checks 
of the integrity of the input <a href="keywords.html#NCDM_ASFILE">ASCII file</a> 
(see <a href="keywords.html#NCDM_CHECKAS">NCDM_CHECKAS</a>).
<br/>
<!-- ************************************************************************************************* -->
<!-- ************************* NCDM_NRFRMS *********************************************************** -->
<h4><a class="NoHi" id="NCDM_NRFRMS"><b>NCDM_NRFRMS</b></a></h4>
Number of frames contained in the input <a href="keywords.html#NCDM_ASFILE">ASCII file</a>, required for 
<a href="keywords.html#NCDM_WRTINPUT">conversion</a> and/or <a href="keywords.html#NCDM_ANONAS">analysis</a>.
This keyword corresponds to the number of rows in the input <a href="keywords.html#NCDM_ASFILE">ASCII file</a> 
that contain the degrees of freedom (number of frames). This means that the possible presence of feature weights 
in the ASCII file must not be accounted for here (see <a href="inputfiles.html#FMCSC_NCDM_ASFILE">elsewhere</a> 
for the ASCII standard that the data mining executable expects).
<br/>
<!-- ************************************************************************************************* -->
<!-- ************************* NCDM_CFILE ************************************************************ -->
<h4><a class="NoHi" id="NCDM_CFILE"><b>NCDM_CFILE</b></a></h4>
This keyword provides the path and location to an input file selecting a subset of the system coordinates for <a href="keywords.html#CMODE">structural clustering</a> 
and dependent analyses. It is always a column list of integer indices specifying a set of the system degrees of freedom 
encoded in the input files (<a href="keywords.html#NCDM_NCFILE">NCDM_NCFILE</a> or <a href="keywords.html#NCDM_ASFILE">NCDM_ASFILE</a>).
<br/>
<!-- ************************************************************************************************* -->
<!-- ************************* NCDM_FRAMESFILE ******************************************************* -->
<h4><a class="NoHi" id="NCDM_FRAMESFILE"><b>NCDM_FRAMESFILE</b></a></h4>
It is possible to analyze just a specific set of frames from the input file 
(<a href="keywords.html#NCDM_NCFILE">NCDM_NCFILE</a> or <a href="keywords.html#NCDM_ASFILE">NCDM_ASFILE</a>).
The entries in NCDM_FRAMESFILE always refer to the frames, <i>viz.</i>, possible <a href="keywords.html#CMODWEIGHTS">features weights</a> 
are adjusted automatically to match the specified frames, regardless input file of origin (<a href="keywords.html#NCDM_ASFILE">ASCII file</a> 
or <a href="keywords.html#NCDM_NCFILE">NetCDF file</a>).
Referring to the specular keyword <a href="keywords.html#FRAMESFILE">FRAMESFILE</a>, 
the frames file for the <a href="keywords.html#netcdf_analysis">NetCDF analysis mode</a> 
is always read "as is" (it is not sorted and duplicates are allowed). 
Therefore, <i> frames </i> weights are not allowed and the contents of <a href="keywords.html#TRAJBREAKSFILE">TRAJBREAKSFILE</a> 
and/or <a href="keywords.html#TRAJLINKSFILE">TRAJLINKSFILE</a> have to be treated accordingly. 
This means that the numbers specified in <a href="keywords.html#TRAJLINKSFILE">TRAJLINKSFILE</a> and/or <a href="keywords.html#TRAJBREAKSFILE">TRAJBREAKSFILE</a> 
are interpreted as referring to the lines of the frames file. This is because the frames file becomes 
the actual trajectory. For example, if the first two frames in the frames file are 1541 and 760, then specifying 
a 2 in the break file entails enforcing a break after the second snapshot of the frames file, <i>i.e.</i> of the 
actual trajectory (here snapshot 760 of the original trajectory) with respect to everything that follows in the 
actual trajectory (<i>i.e.</i> in the frames file after the second line). These changes in connectivity are reflected 
in network analyses (see for example <a href="keywords.html#TMAT_MD">TMAT_MD</a>), and in the relevant output files (<i>e.g.</i>, 
<a href="outputfiles.html#STRUCT_CLUSTERING.graphml">STRUCT_CLUSTERING.graphml</a> and <a href="outputfiles.html#TMAT_xxxxxx_yyy.dat">TMAT_xxxxxx_yyy.dat</a>).
The same behavior involves all that keyords that specify frames numbering, <i>e.g.</i> <a href="keywords.html#INISYNSNAP">INISYNSNAP</a>.
For example, if frames 760 of the original trajectory has to be served as <a href="keywords.html#INISYNSNAP">INISYNSNAP</a> 
and its position in the frames file is in the second line, than a 2 has to be specified as <a href="keywords.html#INISYNSNAP">INISYNSNAP</a>.
The other keywords affetcted are: <a href="keywords.html#ENDSYNSNAP">ENDSYNSNAP</a>, <a href="keywords.html#CLUFOLDFILE">folded set</a>, 
<a href="keywords.html#CLUUNFOLDFILE">unfolded set</a> and <a href="keywords.html#CPROGINDSTART">CPROGINDSTART</a>. 
The format of the <a href="keywords.html#FRAMESFILE">NCDM_FRAMESFILE</a> 
file is a single column of integers and is detailed <a href="inputfiles.html#FMCSC_NCDM_FRAMESFILE">elsewhere</a>.
The choices made with NCDM_FRAMESFILE are not reflected in the possible conversion of an <a href="keywords.html#NCDM_ASFILE">ASCII file</a>, 
but are reflected in the output database in case an input <a href="keywords.html#NCDM_NCFILE">NetCDF file</a> 
is provided and debug output requested (see <a href="keywords.html#NCDM_WRTINPUT">NCDM_WRTINPUT</a>). 
As a final note, the use of NCDM_FRAMESFILE with <a href="keywords.html#CCOLLECT">CCOLLECT</a> 
not equal to 1 is explicitly disabled.
<br/>
<!-- ************************************************************************************************* -->
<!-- ************************* NCDM_CHECKAS ********************************************************** -->
<h4><a class="NoHi" id="NCDM_CHECKAS"><b>NCDM_CHECKAS</b></a></h4>
This simple logical (disabled by default, 1 is true) allows the user to check the integrity (appropriateness) 
of the numbers contained in the colums of the input <a href="keywords.html#NCDM_ASFILE">ASCII file</a>. 
This considerably slows down the reading of the input ASCII file and should be enabled only for debug 
purposes.
<br/>
<!-- ************************************************************************************************* -->
<!--
< style="width: 103px; height: 16px;" alt="a_j = sum_i{f_ij*phi_i}"
 src="website_equations/keywords_TORLCMODE2.gif">. This
keyword is important for the analyses/functionalities spec.d
through the keyword <a href="keywords.html#TORLCCALC">TORLCCALC</a>.</li>
</ol>
-->
<br/>
<br/>
(<a href="keywords.html#TOP">back to top</a>)<br/>
<br/>
</div>
                    
                </div>
                </div>
                </div>
                
            <!-- Side Navigation Bar -->
            <!--<div class="art-sidebar1">  -->  
                                            
                <!-- Contributors Block -->
                <!--
                <div class="art-Block">
                    <div class="art-Block-tl"></div>
                    <div class="art-Block-tr"></div>
                    <div class="art-Block-bl"></div>
                    <div class="art-Block-br"></div>
                    <div class="art-Block-tc"></div>
                    <div class="art-Block-bc"></div>
                    <div class="art-Block-cl"></div>
                    <div class="art-Block-cr"></div>
                    <div class="art-Block-cc"></div>
                    <div class="art-Block-body">
                        <div class="art-BlockHeader">
                            <div class="l"></div>
                            <div class="r"></div>
                            <div class="art-header-tag-icon">
                                <div class="t">Contributors - Links</div>
                            </div>
                        </div>
                        <div class="art-BlockContent">
                            <div class="art-BlockContent-body">
<ol>
  <li><a id="TOP"></a><a href="keywords.html#parameter_files">Parameter file:</a></li>
  <li><a href="keywords.html#PRNG">Random number generator:</a></li>
  <li><a href="keywords.html#Simulation_Setup:">Simulation setup:</a></li>
  <li><a href="keywords.html#box_settings">Box settings:</a></li>
  <li><a href="keywords.html#integrator_controls">Integrator controls (MD/BD/LD/Minimization):</a></li>
  <li><a href="keywords.html#movesetcontrols">Moveset controls (MC):</a></li>
  <li><a href="keywords.html#files_directories">Files and directories:</a></li>
  <li><a href="keywords.html#structure_manipulation">Structure input and manipulation:</a></li>
  <li><a href="keywords.html#energy_terms">Energy terms:</a></li>
  <li><a href="keywords.html#cutoff_settings">Cutoff settings:</a></li>
  <li><a href="keywords.html#MPI_settings">MPI settings (Replica exchange (RE) and MPI averaging) settings:</a></li>
  <li><a href="keywords.html#output_analysis">Output and analysis:</a></li>
  <li><a href="keywords.html#netcdf_analysis">NetCDF analysis mode:</a></li>
</ol>
                            </div>
                        </div>
                    </div>
                </div>-->
                
                <!-- Search Block -->
                <!--
                <div class="art-Block">
                    <div class="art-Block-tl"></div>
                    <div class="art-Block-tr"></div>
                    <div class="art-Block-bl"></div>
                    <div class="art-Block-br"></div>
                    <div class="art-Block-tc"></div>
                    <div class="art-Block-bc"></div>
                    <div class="art-Block-cl"></div>
                    <div class="art-Block-cr"></div>
                    <div class="art-Block-cc"></div>
                    <div class="art-Block-body">
                        <div class="art-BlockHeader">
                            <div class="l"></div>
                            <div class="r"></div>
                            <div class="art-header-tag-icon">
                                <div class="t">Find Text</div>
                            </div>
                        </div><div class="art-BlockContent">
                            <div class="art-BlockContent-body">
                                <div><form method="get" id="newsletterform" action="javascript:void(0)">
                                <input type="text" value="" id="email" id="s" style="width: 95%;" />
                                <span class="art-button-wrapper">
                                    <span class="l"> </span>
                                    <span class="r"> </span>
                                    <input class="art-button" type="submit" id="search" value="Search"/>
                                </span>
                                </form></div>
                            </div>
                        </div>
                    </div>
                </div> 
                -->
                
                <!-- News/Updates Block -->
                <!--
                <div class="art-Block">
                    <div class="art-Block-tl"></div>
                    <div class="art-Block-tr"></div>
                    <div class="art-Block-bl"></div>
                    <div class="art-Block-br"></div>
                    <div class="art-Block-tc"></div>
                    <div class="art-Block-bc"></div>
                    <div class="art-Block-cl"></div>
                    <div class="art-Block-cr"></div>
                    <div class="art-Block-cc"></div>
                    <div class="art-Block-body">
                        <div class="art-BlockHeader">
                            <div class="l"></div>
                            <div class="r"></div>
                            <div class="art-header-tag-icon">
                                <div class="t">Recent News</div>
                            </div>
                        </div><div class="art-BlockContent">
                            <div class="art-BlockContent-body">
                                <div>
                                    <p><b>Jun 14, 2008</b><br/>
                                    Aliquam sit amet felis. Mauris semper, 
                                    velit semper laoreet dictum, quam 
                                    diam dictum urna, nec placerat elit 
                                    nisl in quam. Etiam augue pede, 
                                    molestie eget, rhoncus at, convallis 
                                    ut, eros. Aliquam pharetra.<br/>
                                    <a href="javascript:void(0)">Read more...</a></p>
                                                          
                                    <p><b>Aug 24, 2008</b><br/>
                                    Aliquam sit amet felis. Mauris semper, 
                                    velit semper laoreet dictum, quam 
                                    diam dictum urna, nec placerat elit 
                                    nisl in quam. Etiam augue pede, 
                                    molestie eget, rhoncus at, convallis 
                                    ut, eros. Aliquam pharetra.<br/>
                                    <a href="javascript:void(0)">Read more...</a></p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div> -->
            <!--</div> --> <!-- End Sidebar -->

            </div>
        </div>
    </div> <!-- End main page contents -->

            
    <!-- Footer -->
    <div class="art-Footer">
    <div class="art-Footer-background">
    <div class="art-Footer-inner">
        <a href="#" class="art-rss-tag-icon" title="RSS"></a>
        <div class="art-Footer-text">
        <p><a href="#">Contact Us</a> | <a href="#">Terms of Use</a>
        | <a href="#">License Information</a><br />
        Copyright &copy; 2010 . All Rights Reserved.</p>
        </div>
    </div>
    </div>
    </div>
    <p class="art-page-footer">XHTML and CSS valid. Powered by <a href="http://www.flashmint.com/">FlashMint</a> - flash templates provider.</p>
    <div style="text-align: center; font-size: 0.75em;">Design downloaded from <a href="http://www.freewebtemplates.com/">free website templates</a>.</div>
                
</div>
</body>
</html>
